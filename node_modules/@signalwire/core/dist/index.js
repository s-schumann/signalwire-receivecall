var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __reflectGet = Reflect.get;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AuthError: () => AuthError,
  BaseClient: () => BaseClient,
  BaseComponent: () => BaseComponent,
  BaseConsumer: () => BaseConsumer,
  BaseJWTSession: () => BaseJWTSession,
  BaseSession: () => BaseSession,
  Chat: () => chat_exports,
  ChatMember: () => ChatMember,
  ChatMessage: () => ChatMessage,
  DEFAULT_CONNECT_VERSION: () => DEFAULT_CONNECT_VERSION,
  EventEmitter: () => import_eventemitter3.default,
  GLOBAL_VIDEO_EVENTS: () => GLOBAL_VIDEO_EVENTS,
  HttpError: () => HttpError,
  INTERNAL_MEMBER_UPDATABLE_PROPS: () => INTERNAL_MEMBER_UPDATABLE_PROPS,
  INTERNAL_MEMBER_UPDATED_EVENTS: () => INTERNAL_MEMBER_UPDATED_EVENTS,
  MEMBER_UPDATABLE_PROPS: () => MEMBER_UPDATABLE_PROPS,
  MEMBER_UPDATED_EVENTS: () => MEMBER_UPDATED_EVENTS,
  MemberPosition: () => memberPosition_exports,
  PubSub: () => pubSub_exports,
  PubSubMessage: () => PubSubMessage,
  RPCConnect: () => RPCConnect,
  RPCDisconnectResponse: () => RPCDisconnectResponse,
  RPCExecute: () => RPCExecute,
  RPCPing: () => RPCPing,
  RPCPingResponse: () => RPCPingResponse,
  RPCReauthenticate: () => RPCReauthenticate,
  Rooms: () => rooms_exports,
  VertoAnswer: () => VertoAnswer,
  VertoAttach: () => VertoAttach,
  VertoBye: () => VertoBye,
  VertoInfo: () => VertoInfo,
  VertoInvite: () => VertoInvite,
  VertoModify: () => VertoModify,
  VertoPong: () => VertoPong,
  VertoResult: () => VertoResult,
  actions: () => actions_exports,
  componentActions: () => componentActions,
  componentReducer: () => componentReducer,
  componentSelectors: () => componentSelectors_exports,
  configureStore: () => configureStore2,
  connect: () => connect,
  debounce: () => debounce,
  extendComponent: () => extendComponent,
  findNamespaceInPayload: () => findNamespaceInPayload,
  getEventEmitter: () => getEventEmitter,
  getLogger: () => getLogger,
  initialComponentState: () => initialComponentState,
  initialSessionState: () => initialSessionState,
  isGlobalEvent: () => isGlobalEvent,
  makeRPCRequest: () => makeRPCRequest,
  makeRPCResponse: () => makeRPCResponse,
  sagaEffects: () => sagaEffects,
  sagaHelpers: () => sagaHelpers_exports,
  selectors: () => selectors,
  serializeableProxy: () => serializeableProxy,
  sessionActions: () => sessionActions,
  sessionReducer: () => sessionReducer,
  setLogger: () => setLogger,
  testUtils: () => testUtils_exports,
  timeoutPromise: () => timeoutPromise,
  toExternalJSON: () => toExternalJSON,
  toInternalAction: () => toInternalAction,
  toInternalEventName: () => toInternalEventName,
  toLocalEvent: () => toLocalEvent,
  toSnakeCaseKeys: () => toSnakeCaseKeys,
  toSyntheticEvent: () => toSyntheticEvent,
  uuid: () => import_uuid.v4,
  validateEventsToSubscribe: () => validateEventsToSubscribe
});
module.exports = __toCommonJS(src_exports);

// src/utils/constants.ts
var DEFAULT_HOST = "wss://relay.signalwire.com";
var EVENT_NAMESPACE_DIVIDER = ":";
var LOCAL_EVENT_PREFIX = "__local__";
var SYNTHETIC_EVENT_PREFIX = "__synthetic__";
var PRODUCT_PREFIX_VIDEO = "video";
var PRODUCT_PREFIX_CHAT = "chat";
var PRODUCT_PREFIX_PUBSUB = "chat";
var GLOBAL_VIDEO_EVENTS = ["room.started", "room.ended"];
var INTERNAL_GLOBAL_VIDEO_EVENTS = GLOBAL_VIDEO_EVENTS.map((event) => `${PRODUCT_PREFIX_VIDEO}.${event}`);

// src/utils/logger.ts
var import_loglevel = __toESM(require("loglevel"));
var datetime = () => new Date().toISOString();
var defaultLogger = import_loglevel.default.getLogger("signalwire");
var originalFactory = defaultLogger.methodFactory;
defaultLogger.methodFactory = (methodName, logLevel, loggerName) => {
  const rawMethod = originalFactory(methodName, logLevel, loggerName);
  return function(...args) {
    args.unshift(datetime(), "-");
    rawMethod.apply(void 0, args);
  };
};
var defaultLoggerLevel = process.env.NODE_ENV === "development" ? defaultLogger.levels.DEBUG : defaultLogger.getLevel();
defaultLogger.setLevel(defaultLoggerLevel);
var userLogger;
var setLogger = (logger) => {
  userLogger = logger;
};
var debugOptions = {};
var setDebugOptions = (options) => {
  if (options == null) {
    debugOptions = {};
    return;
  }
  Object.assign(debugOptions, options);
};
var getLoggerInstance = () => {
  return userLogger != null ? userLogger : defaultLogger;
};
var shouldStringify = (payload) => {
  if ("method" in payload && payload.method === "signalwire.ping") {
    return false;
  }
  return true;
};
var wsTraffic = ({ type, payload }) => {
  const logger = getLoggerInstance();
  const { logWsTraffic } = debugOptions || {};
  if (!logWsTraffic) {
    return void 0;
  }
  const msg = shouldStringify(payload) ? JSON.stringify(payload, null, 2) : payload;
  return logger.info(`${type.toUpperCase()}: 
`, msg, "\n");
};
var getLogger = () => {
  const logger = getLoggerInstance();
  return new Proxy(logger, {
    get(target, prop, receiver) {
      if (prop === "wsTraffic") {
        return wsTraffic;
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/utils/index.ts
var import_uuid = require("uuid");

// src/utils/parseRPCResponse.ts
var parseRPCResponse = ({
  response,
  request
}) => {
  const { result = {}, error } = response;
  if (error) {
    return {
      error
    };
  }
  switch (request.method) {
    case "signalwire.connect":
      return { result };
    default:
      return parseResponse(response);
  }
};
var parseResponse = (response, nodeId) => {
  const { result = {}, error } = response;
  if (error) {
    return { error };
  }
  const { code, node_id, result: nestedResult = null } = result;
  if (code && code !== "200") {
    return { error: result };
  }
  if (nestedResult === null) {
    if (nodeId) {
      result.node_id = nodeId;
    }
    return { result };
  }
  if (nestedResult) {
    if (nestedResult.jsonrpc) {
      return parseResponse(nestedResult, node_id);
    }
    return { result: nestedResult };
  }
  return { result };
};

// src/utils/toExternalJSON.ts
var toDateObject = (timestamp) => {
  if (typeof timestamp === "undefined") {
    return timestamp;
  }
  const date = new Date(timestamp * 1e3);
  if (isNaN(date.getTime())) {
    return timestamp;
  }
  return date;
};
var DEFAULT_OPTIONS = {
  propsToUpdateValue: [
    "updated",
    "layers",
    "members",
    "recordings",
    "playbacks"
  ]
};
var isTimestampProperty = (prop) => {
  return prop.endsWith("At");
};
var toExternalJSON = (input, options = DEFAULT_OPTIONS) => {
  if ((input == null ? void 0 : input.__sw_symbol) || (input == null ? void 0 : input.__sw_proxy)) {
    return input;
  }
  return Object.entries(input).reduce((reducer, [key, value]) => {
    const prop = fromSnakeToCamelCase(key);
    const propType = typeof value;
    if (propType === "object" && value) {
      if (Array.isArray(value)) {
        if (options.propsToUpdateValue.includes(key)) {
          reducer[prop] = value.map((v) => {
            if (typeof v === "string") {
              return fromSnakeToCamelCase(v);
            }
            return toExternalJSON(v);
          });
        } else {
          reducer[prop] = value;
        }
      } else {
        reducer[prop] = toExternalJSON(value);
      }
    } else {
      if (isTimestampProperty(prop)) {
        reducer[prop] = toDateObject(value);
      } else {
        reducer[prop] = value;
      }
    }
    return reducer;
  }, {});
};
var fromSnakeToCamelCase = (input) => {
  if (!input.includes("_")) {
    return input;
  }
  return input.split("_").reduce((reducer, part, index) => {
    const fc = part.trim().charAt(0);
    const remainingChars = part.substr(1).toLowerCase();
    return `${reducer}${index === 0 ? fc.toLowerCase() : fc.toUpperCase()}${remainingChars}`;
  }, "");
};

// src/utils/common.ts
var UPPERCASE_REGEX = /[A-Z]/g;
var fromCamelToSnakeCase = (event) => {
  return event.replace(UPPERCASE_REGEX, (letter) => {
    return `_${letter.toLowerCase()}`;
  });
};

// src/utils/toInternalEventName.ts
var toInternalEventName = ({
  event,
  namespace
}) => {
  if (typeof event === "string") {
    event = getNamespacedEvent({
      event,
      namespace
    });
    event = fromCamelToSnakeCase(event);
  }
  return event;
};
var getNamespacedEvent = ({
  namespace,
  event
}) => {
  if (!namespace || event.startsWith(namespace)) {
    return event;
  }
  return `${namespace}${EVENT_NAMESPACE_DIVIDER}${event}`;
};

// src/utils/toInternalAction.ts
var toInternalAction = (event) => {
  const { event_type, params, node_id } = event;
  if (event_type === "queuing.relay.tasks") {
    return {
      type: event_type,
      payload: event
    };
  }
  if (event_type === "webrtc.message" && (params == null ? void 0 : params.jsonrpc)) {
    const vertoRPC = params;
    if (vertoRPC.params) {
      vertoRPC.params.nodeId = node_id;
    }
    return {
      type: event_type,
      payload: vertoRPC
    };
  }
  return {
    type: event_type,
    payload: params
  };
};

// src/utils/toSnakeCaseKeys.ts
var toSnakeCaseKeys = (obj, transform = (value) => value, result = {}) => {
  if (Array.isArray(obj)) {
    result = obj.map((item, index) => {
      if (typeof item === "object") {
        return toSnakeCaseKeys(item, transform, result[index]);
      }
      return item;
    });
  } else {
    Object.keys(obj).forEach((key) => {
      const newKey = fromCamelToSnakeCase(key);
      if (obj[key] && typeof obj[key] === "object") {
        result[newKey] = toSnakeCaseKeys(obj[key], transform, result[newKey]);
      } else {
        result[newKey] = transform(obj[key]);
      }
    });
  }
  return result;
};

// src/utils/extendComponent.ts
var extendComponent = (klass, methods) => {
  Object.keys(methods).forEach((methodName) => {
    if (klass.prototype.hasOwnProperty(methodName)) {
      throw new Error(`[extendComponent] Duplicated method name: ${methodName}`);
    }
  });
  Object.defineProperties(klass.prototype, methods);
  return klass;
};

// src/utils/proxyUtils.ts
var proxyToString = ({
  property,
  payload
}) => {
  return typeof property === "function" ? () => JSON.stringify(payload) : property;
};
var getAllMethods = (objTarget) => {
  let methods = {};
  let obj = objTarget;
  let shouldContinue = true;
  while (shouldContinue) {
    Object.getOwnPropertyNames(obj).forEach((k) => {
      if (typeof objTarget[k] === "function" && typeof k === "string" && !(k in methods)) {
        methods[k] = objTarget[k];
      }
    });
    if (!obj || !obj.__sw_symbol) {
      shouldContinue = false;
    } else {
      obj = Object.getPrototypeOf(obj);
    }
  }
  return methods;
};
var serializeableProxy = ({
  instance,
  proxiedObj,
  payload,
  transformedPayload,
  transform
}) => {
  const data = __spreadValues(__spreadProps(__spreadValues({}, transformedPayload), {
    _eventsNamespace: transform.getInstanceEventNamespace ? transform.getInstanceEventNamespace(payload) : void 0,
    eventChannel: transform.getInstanceEventChannel ? transform.getInstanceEventChannel(payload) : void 0
  }), getAllMethods(instance));
  return Object.defineProperties(proxiedObj, Object.entries(data).reduce((reducer, [key, value]) => {
    if (value === void 0) {
      return reducer;
    }
    reducer[key] = {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    };
    return reducer;
  }, {}));
};
var proxyFactory = ({
  instance,
  transform,
  payload,
  transformedPayload
}) => {
  const proxiedObj = new Proxy(instance, {
    get(target, prop, receiver) {
      if (prop === "__sw_proxy") {
        return true;
      }
      if (prop === "toString") {
        return proxyToString({
          property: target[prop],
          payload: transformedPayload
        });
      } else if (prop === "_eventsNamespace" && transform.getInstanceEventNamespace) {
        return transform.getInstanceEventNamespace(payload);
      } else if (prop === "eventChannel" && transform.getInstanceEventChannel) {
        return transform.getInstanceEventChannel(payload);
      } else if (prop in transformedPayload) {
        return transformedPayload[prop];
      }
      return Reflect.get(target, prop, receiver);
    }
  });
  return serializeableProxy({
    instance,
    proxiedObj,
    payload,
    transformedPayload,
    transform
  });
};

// src/utils/eventTransformUtils.ts
var _instanceByTransformType = /* @__PURE__ */ new Map();
var _getOrCreateInstance = ({
  transform,
  payload
}) => {
  if (!_instanceByTransformType.has(transform.type)) {
    const instance = transform.instanceFactory(payload);
    _instanceByTransformType.set(transform.type, instance);
    return instance;
  }
  return _instanceByTransformType.get(transform.type);
};
var instanceProxyFactory = ({
  transform,
  payload
}) => {
  const cachedInstance = _getOrCreateInstance({
    transform,
    payload
  });
  const transformedPayload = transform.payloadTransform(payload);
  const proxiedObj = proxyFactory({
    transform,
    payload,
    instance: cachedInstance,
    transformedPayload
  });
  return proxiedObj;
};

// src/utils/debounce.ts
function debounce(fn, wait2 = 0, callFirst) {
  let timeout = null;
  let debouncedFn = null;
  const clear = function() {
    if (timeout) {
      clearTimeout(timeout);
      debouncedFn = null;
      timeout = null;
    }
  };
  const flush = function() {
    const call4 = debouncedFn;
    clear();
    if (call4) {
      call4();
    }
  };
  const debounceWrapper = function() {
    if (!wait2) {
      return fn.apply(this, arguments);
    }
    const context = this;
    const args = arguments;
    const callNow = callFirst && !timeout;
    clear();
    debouncedFn = function() {
      fn.apply(context, args);
    };
    timeout = setTimeout(function() {
      timeout = null;
      if (!callNow) {
        const call4 = debouncedFn;
        debouncedFn = null;
        return call4 == null ? void 0 : call4();
      }
    }, wait2);
    if (callNow && debouncedFn) {
      return debouncedFn();
    }
  };
  debounceWrapper.cancel = clear;
  debounceWrapper.flush = flush;
  return debounceWrapper;
}

// src/utils/index.ts
var safeParseJson = (value) => {
  if (typeof value !== "string") {
    return value;
  }
  try {
    return JSON.parse(value);
  } catch (error) {
    return value;
  }
};
var PROTOCOL_PATTERN = /^(ws|wss):\/\//;
var checkWebSocketHost = (host) => {
  const protocol = PROTOCOL_PATTERN.test(host) ? "" : "wss://";
  return `${protocol}${host}`;
};
var timeoutPromise = (promise, time, exception) => {
  let timer = null;
  return Promise.race([
    promise,
    new Promise((_resolve, reject) => timer = setTimeout(reject, time, exception))
  ]).finally(() => clearTimeout(timer));
};
var isGlobalEvent = (event) => {
  return GLOBAL_VIDEO_EVENTS.includes(event);
};
var isInternalGlobalEvent = (event) => {
  return INTERNAL_GLOBAL_VIDEO_EVENTS.includes(event);
};
var isSyntheticEvent = (event) => {
  return event.includes(SYNTHETIC_EVENT_PREFIX);
};
var isSessionEvent = (event) => {
  return event.includes("session.");
};
var cleanupEventNamespace = (event) => {
  const eventParts = event.split(EVENT_NAMESPACE_DIVIDER);
  return eventParts[eventParts.length - 1];
};
var WITH_CUSTOM_EVENT_NAMES = [
  "video.member.updated",
  "video.member.talking"
];
var CLIENT_SIDE_EVENT_NAMES = [
  "video.room.joined",
  "video.track",
  "video.active",
  "video.answering",
  "video.destroy",
  "video.early",
  "video.hangup",
  "video.held",
  "video.new",
  "video.purge",
  "video.recovering",
  "video.requesting",
  "video.ringing",
  "video.trying"
];
var validateEventsToSubscribe = (events) => {
  const valid = events.map((internalEvent) => {
    if (typeof internalEvent === "string") {
      const event = cleanupEventNamespace(internalEvent);
      if (CLIENT_SIDE_EVENT_NAMES.includes(event) || isSyntheticEvent(event) || isLocalEvent(event) || isSessionEvent(event)) {
        return null;
      }
      const found = WITH_CUSTOM_EVENT_NAMES.find((withCustomName) => {
        return event.startsWith(withCustomName);
      });
      return found || event;
    }
    return internalEvent;
  });
  return Array.from(new Set(valid)).filter(Boolean);
};
var isLocalEvent = (event) => {
  return event.includes(LOCAL_EVENT_PREFIX);
};
var toLocalEvent = (event) => {
  const eventParts = event.split(".");
  const prefix = eventParts[0];
  return event.split(".").reduce((reducer, item) => {
    reducer.push(item);
    if (item === prefix) {
      reducer.push(LOCAL_EVENT_PREFIX);
    }
    return reducer;
  }, []).join(".");
};
var toSyntheticEvent = (event) => {
  const eventParts = event.split(".");
  const prefix = eventParts[0];
  return event.split(".").reduce((reducer, item) => {
    reducer.push(item);
    if (item === prefix) {
      reducer.push(SYNTHETIC_EVENT_PREFIX);
    }
    return reducer;
  }, []).join(".");
};
var isJSONRPCRequest = (e) => {
  return Boolean(e.method);
};
var isJSONRPCResponse = (e) => {
  return !isJSONRPCRequest(e);
};

// src/RPCMessages/helpers.ts
var makeRPCRequest = (params) => {
  var _a;
  return __spreadValues({
    jsonrpc: "2.0",
    id: (_a = params.id) != null ? _a : (0, import_uuid.v4)()
  }, params);
};
var makeRPCResponse = (params) => {
  return __spreadValues({
    jsonrpc: "2.0"
  }, params);
};

// src/RPCMessages/RPCConnect.ts
var DEFAULT_CONNECT_VERSION = {
  major: 3,
  minor: 0,
  revision: 0
};
var RPCConnect = (params) => {
  return makeRPCRequest({
    method: "signalwire.connect",
    params: __spreadValues({
      version: DEFAULT_CONNECT_VERSION
    }, params)
  });
};

// src/RPCMessages/RPCReauthenticate.ts
var RPCReauthenticate = (authentication) => {
  return makeRPCRequest({
    method: "signalwire.reauthenticate",
    params: {
      authentication
    }
  });
};

// src/RPCMessages/RPCPing.ts
var RPCPing = () => {
  return makeRPCRequest({
    method: "signalwire.ping",
    params: {
      timestamp: Date.now() / 1e3
    }
  });
};
var RPCPingResponse = (id, timestamp) => {
  return makeRPCResponse({
    id,
    result: {
      timestamp: timestamp || Date.now() / 1e3
    }
  });
};

// src/RPCMessages/RPCExecute.ts
var RPCExecute = ({ method, params }) => {
  return makeRPCRequest({
    method,
    params
  });
};

// src/RPCMessages/RPCDisconnect.ts
var RPCDisconnectResponse = (id) => {
  return makeRPCResponse({
    id,
    result: {}
  });
};

// src/RPCMessages/VertoMessages.ts
var tmpMap = {
  id: "callID",
  destinationNumber: "destination_number",
  remoteCallerName: "remote_caller_id_name",
  remoteCallerNumber: "remote_caller_id_number",
  callerName: "caller_id_name",
  callerNumber: "caller_id_number"
};
var filterVertoParams = (params) => {
  if (params.hasOwnProperty("dialogParams")) {
    const _a = params.dialogParams, {
      remoteSdp,
      localStream,
      remoteStream
    } = _a, dialogParams = __objRest(_a, [
      "remoteSdp",
      "localStream",
      "remoteStream"
    ]);
    for (const key in tmpMap) {
      if (key && dialogParams.hasOwnProperty(key)) {
        dialogParams[tmpMap[key]] = dialogParams[key];
        delete dialogParams[key];
      }
    }
    params.dialogParams = dialogParams;
  }
  return params;
};
var buildVertoRPCMessage = (method) => {
  return (params = {}) => {
    return makeRPCRequest({
      method,
      params: filterVertoParams(params)
    });
  };
};
var VertoInvite = buildVertoRPCMessage("verto.invite");
var VertoBye = buildVertoRPCMessage("verto.bye");
var VertoAttach = buildVertoRPCMessage("verto.attach");
var VertoModify = buildVertoRPCMessage("verto.modify");
var VertoInfo = buildVertoRPCMessage("verto.info");
var VertoAnswer = buildVertoRPCMessage("verto.answer");
var VertoPong = buildVertoRPCMessage("verto.pong");
var VertoResult = (id, method) => {
  return makeRPCResponse({
    id,
    result: {
      method
    }
  });
};

// src/redux/actions.ts
var actions_exports = {};
__export(actions_exports, {
  authErrorAction: () => authErrorAction,
  authExpiringAction: () => authExpiringAction,
  authSuccessAction: () => authSuccessAction,
  compoundEventAttachAction: () => compoundEventAttachAction,
  createAction: () => createAction,
  destroyAction: () => destroyAction,
  executeAction: () => executeAction,
  getCustomSagaActionType: () => getCustomSagaActionType,
  initAction: () => initAction,
  makeCustomSagaAction: () => makeCustomSagaAction,
  reauthAction: () => reauthAction,
  sessionAuthErrorAction: () => sessionAuthErrorAction,
  sessionConnectedAction: () => sessionConnectedAction,
  sessionDisconnectedAction: () => sessionDisconnectedAction,
  sessionExpiringAction: () => sessionExpiringAction,
  sessionReconnectingAction: () => sessionReconnectingAction,
  socketMessageAction: () => socketMessageAction
});

// src/redux/toolkit/index.ts
var toolkit_exports = {};
__export(toolkit_exports, {
  configureStore: () => configureStore,
  createAction: () => createAction
});
__reExport(toolkit_exports, require("redux"));

// src/redux/toolkit/createAction.ts
function createAction(type, prepareAction) {
  function actionCreator(...args) {
    if (prepareAction) {
      let prepared = prepareAction(...args);
      if (!prepared) {
        throw new Error("prepareAction did not return an object");
      }
      return __spreadValues(__spreadValues({
        type,
        payload: prepared.payload
      }, "meta" in prepared && { meta: prepared.meta }), "error" in prepared && { error: prepared.error });
    }
    return { type, payload: args[0] };
  }
  actionCreator.toString = () => `${type}`;
  actionCreator.type = type;
  actionCreator.match = (action) => action.type === type;
  return actionCreator;
}

// src/redux/toolkit/configureStore.ts
var import_redux2 = require("redux");

// src/redux/toolkit/devtoolsExtension.ts
var import_redux = require("redux");
var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
  if (arguments.length === 0)
    return void 0;
  if (typeof arguments[0] === "object")
    return import_redux.compose;
  return import_redux.compose.apply(null, arguments);
};
var devToolsEnhancer = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function() {
  return function(noop) {
    return noop;
  };
};

// src/redux/toolkit/isPlainObject.ts
function isPlainObject(value) {
  if (typeof value !== "object" || value === null)
    return false;
  let proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  let baseProto = proto;
  while (Object.getPrototypeOf(baseProto) !== null) {
    baseProto = Object.getPrototypeOf(baseProto);
  }
  return proto === baseProto;
}

// src/redux/toolkit/getDefaultMiddleware.ts
function curryGetDefaultMiddleware() {
  return function curriedGetDefaultMiddleware() {
    return [];
  };
}

// src/redux/toolkit/configureStore.ts
var IS_PRODUCTION = process.env.NODE_ENV === "production";
function configureStore(options) {
  const curriedGetDefaultMiddleware = curryGetDefaultMiddleware();
  const {
    reducer = void 0,
    middleware = curriedGetDefaultMiddleware(),
    devTools = true,
    preloadedState = void 0,
    enhancers = void 0
  } = options || {};
  let rootReducer2;
  if (typeof reducer === "function") {
    rootReducer2 = reducer;
  } else if (isPlainObject(reducer)) {
    rootReducer2 = (0, import_redux2.combineReducers)(reducer);
  } else {
    throw new Error('"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');
  }
  let finalMiddleware = middleware;
  if (typeof finalMiddleware === "function") {
    finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware);
    if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) {
      throw new Error("when using a middleware builder function, an array of middleware must be returned");
    }
  }
  if (!IS_PRODUCTION && finalMiddleware.some((item) => typeof item !== "function")) {
    throw new Error("each middleware provided to configureStore must be a function");
  }
  const middlewareEnhancer = (0, import_redux2.applyMiddleware)(...finalMiddleware);
  let finalCompose = import_redux2.compose;
  if (devTools) {
    finalCompose = composeWithDevTools(__spreadValues({
      trace: !IS_PRODUCTION
    }, typeof devTools === "object" && devTools));
  }
  let storeEnhancers = [middlewareEnhancer];
  if (Array.isArray(enhancers)) {
    storeEnhancers = [middlewareEnhancer, ...enhancers];
  } else if (typeof enhancers === "function") {
    storeEnhancers = enhancers(storeEnhancers);
  }
  const composedEnhancer = finalCompose(...storeEnhancers);
  return (0, import_redux2.createStore)(rootReducer2, preloadedState, composedEnhancer);
}

// src/redux/actions.ts
var initAction = createAction("swSdk/init");
var destroyAction = createAction("swSdk/destroy");
var reauthAction = createAction("swSdk/reauth");
var executeAction = createAction("swSdk/executeRequest");
var authErrorAction = createAction("auth/error");
var authSuccessAction = createAction("auth/success");
var authExpiringAction = createAction("auth/expiring");
var socketMessageAction = createAction("socket/message");
var sessionConnectedAction = createAction("session.connected");
var sessionDisconnectedAction = createAction("session.disconnected");
var sessionReconnectingAction = createAction("session.reconnecting");
var sessionAuthErrorAction = createAction("session.auth_error");
var sessionExpiringAction = createAction("session.expiring");
var formatCustomSagaAction = (id, action) => {
  return `${action.type}/${id}`;
};
var makeCustomSagaAction = (id, action) => {
  return __spreadProps(__spreadValues({}, action), {
    type: formatCustomSagaAction(id, action)
  });
};
var getCustomSagaActionType = (id, action) => {
  return formatCustomSagaAction(id, action);
};
var compoundEventAttachAction = createAction("compound_event:attach");

// src/redux/toolkit/mapBuilders.ts
function executeReducerBuilderCallback(builderCallback) {
  const actionsMap = {};
  const actionMatchers = [];
  let defaultCaseReducer;
  const builder = {
    addCase(typeOrActionCreator, reducer) {
      if (process.env.NODE_ENV !== "production") {
        if (actionMatchers.length > 0) {
          throw new Error("`builder.addCase` should only be called before calling `builder.addMatcher`");
        }
        if (defaultCaseReducer) {
          throw new Error("`builder.addCase` should only be called before calling `builder.addDefaultCase`");
        }
      }
      const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
      if (type in actionsMap) {
        throw new Error("addCase cannot be called with two reducers for the same action type");
      }
      actionsMap[type] = reducer;
      return builder;
    },
    addMatcher(matcher, reducer) {
      if (process.env.NODE_ENV !== "production") {
        if (defaultCaseReducer) {
          throw new Error("`builder.addMatcher` should only be called before calling `builder.addDefaultCase`");
        }
      }
      actionMatchers.push({ matcher, reducer });
      return builder;
    },
    addDefaultCase(reducer) {
      if (process.env.NODE_ENV !== "production") {
        if (defaultCaseReducer) {
          throw new Error("`builder.addDefaultCase` can only be called once");
        }
      }
      defaultCaseReducer = reducer;
      return builder;
    }
  };
  builderCallback(builder);
  return [actionsMap, actionMatchers, defaultCaseReducer];
}

// src/redux/toolkit/createReducer.ts
function isStateFunction(x) {
  return typeof x === "function";
}
function createReducer(initialState, mapOrBuilderCallback, actionMatchers = [], defaultCaseReducer) {
  let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = typeof mapOrBuilderCallback === "function" ? executeReducerBuilderCallback(mapOrBuilderCallback) : [mapOrBuilderCallback, actionMatchers, defaultCaseReducer];
  let getInitialState;
  if (isStateFunction(initialState)) {
    getInitialState = () => initialState();
  } else {
    getInitialState = () => initialState;
  }
  function reducer(state = getInitialState(), action) {
    let caseReducers = [
      actionsMap[action.type],
      ...finalActionMatchers.filter(({ matcher }) => matcher(action)).map(({ reducer: reducer2 }) => reducer2)
    ];
    if (caseReducers.filter((cr) => !!cr).length === 0) {
      caseReducers = [finalDefaultCaseReducer];
    }
    return caseReducers.reduce((previousState, caseReducer) => {
      if (caseReducer) {
        return caseReducer(previousState, action);
      }
      return previousState;
    }, state);
  }
  reducer.getInitialState = getInitialState;
  return reducer;
}

// src/redux/toolkit/createSlice.ts
function getType(slice, actionKey) {
  return `${slice}/${actionKey}`;
}
function createSlice(options) {
  const { name } = options;
  if (!name) {
    throw new Error("`name` is a required option for createSlice");
  }
  const initialState = options.initialState;
  const reducers = options.reducers || {};
  const reducerNames = Object.keys(reducers);
  const sliceCaseReducersByName = {};
  const sliceCaseReducersByType = {};
  const actionCreators = {};
  reducerNames.forEach((reducerName) => {
    const maybeReducerWithPrepare = reducers[reducerName];
    const type = getType(name, reducerName);
    let caseReducer;
    let prepareCallback;
    if ("reducer" in maybeReducerWithPrepare) {
      caseReducer = maybeReducerWithPrepare.reducer;
      prepareCallback = maybeReducerWithPrepare.prepare;
    } else {
      caseReducer = maybeReducerWithPrepare;
    }
    sliceCaseReducersByName[reducerName] = caseReducer;
    sliceCaseReducersByType[type] = caseReducer;
    actionCreators[reducerName] = prepareCallback ? createAction(type, prepareCallback) : createAction(type);
  });
  function buildReducer() {
    const [
      extraReducers = {},
      actionMatchers = [],
      defaultCaseReducer = void 0
    ] = typeof options.extraReducers === "function" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers];
    const finalCaseReducers = __spreadValues(__spreadValues({}, extraReducers), sliceCaseReducersByType);
    return createReducer(initialState, finalCaseReducers, actionMatchers, defaultCaseReducer);
  }
  let _reducer;
  return {
    name,
    reducer(state, action) {
      if (!_reducer)
        _reducer = buildReducer();
      return _reducer(state, action);
    },
    actions: actionCreators,
    caseReducers: sliceCaseReducersByName,
    getInitialState() {
      if (!_reducer)
        _reducer = buildReducer();
      return _reducer.getInitialState();
    }
  };
}

// src/redux/utils/createDestroyableSlice.ts
var createDestroyableSlice = ({
  name = "",
  initialState,
  reducers,
  extraReducers
}) => {
  return createSlice({
    name,
    initialState,
    reducers,
    extraReducers: (builder) => {
      builder.addCase(destroyAction.type, () => {
        return initialState;
      });
      if (typeof extraReducers === "function") {
        extraReducers(builder);
      }
    }
  });
};

// src/redux/features/session/sessionSlice.ts
var initialSessionState = {
  protocol: "",
  iceServers: [],
  authStatus: "unknown",
  authState: void 0,
  authError: void 0,
  authCount: 0
};
function authorizingAction(action) {
  return [initAction.type, reauthAction.type].includes(action.type);
}
var sessionSlice = createDestroyableSlice({
  name: "session",
  initialState: initialSessionState,
  reducers: {
    connected: (state, { payload }) => {
      var _a, _b;
      return __spreadProps(__spreadValues({}, state), {
        authStatus: "authorized",
        authState: payload == null ? void 0 : payload.authorization,
        authCount: state.authCount + 1,
        protocol: (_a = payload == null ? void 0 : payload.protocol) != null ? _a : "",
        iceServers: (_b = payload == null ? void 0 : payload.ice_servers) != null ? _b : []
      });
    },
    authStatus: (state, { payload }) => {
      return __spreadProps(__spreadValues({}, state), {
        authStatus: payload
      });
    },
    updateAuthState: (state, { payload }) => {
      return __spreadProps(__spreadValues({}, state), {
        authState: payload
      });
    }
  },
  extraReducers: (builder) => {
    builder.addCase(authErrorAction.type, (state, { payload }) => {
      return __spreadProps(__spreadValues({}, state), {
        authStatus: "unauthorized",
        authError: payload.error
      });
    });
    builder.addMatcher(authorizingAction, (state) => {
      return __spreadProps(__spreadValues({}, state), {
        authStatus: "authorizing"
      });
    });
  }
});
var {
  actions: sessionActions,
  reducer: sessionReducer
} = sessionSlice;

// src/BaseSession.ts
var SW_SYMBOL = Symbol("BaseSession");
var randomInt = (min, max) => {
  return Math.floor(Math.random() * (max - min + 1) + min);
};
var reconnectDelay = () => {
  return randomInt(1, 4) * 1e3;
};
var BaseSession = class {
  constructor(options) {
    this.options = options;
    __publicField(this, "__sw_symbol", SW_SYMBOL);
    __publicField(this, "uuid", (0, import_uuid.v4)());
    __publicField(this, "WebSocketConstructor");
    __publicField(this, "agent");
    __publicField(this, "connectVersion", DEFAULT_CONNECT_VERSION);
    __publicField(this, "_rpcConnectResult");
    __publicField(this, "_requests", /* @__PURE__ */ new Map());
    __publicField(this, "_socket", null);
    __publicField(this, "_host", DEFAULT_HOST);
    __publicField(this, "_executeTimeoutMs", 10 * 1e3);
    __publicField(this, "_executeTimeoutError", Symbol.for("sw-execute-timeout"));
    __publicField(this, "_executeQueue", /* @__PURE__ */ new Set());
    __publicField(this, "_checkPingDelay", 15 * 1e3);
    __publicField(this, "_checkPingTimer", null);
    __publicField(this, "_reconnectTimer");
    __publicField(this, "_status", "unknown");
    __publicField(this, "wsOpenHandler");
    __publicField(this, "wsCloseHandler");
    __publicField(this, "wsErrorHandler");
    var _a, _b;
    const { host, logLevel = "info" } = options;
    if (host) {
      this._host = checkWebSocketHost(host);
    }
    if (logLevel) {
      (_b = (_a = this.logger).setLevel) == null ? void 0 : _b.call(_a, logLevel);
    }
    this._onSocketOpen = this._onSocketOpen.bind(this);
    this._onSocketError = this._onSocketError.bind(this);
    this._onSocketClose = this._onSocketClose.bind(this);
    this._onSocketMessage = this._onSocketMessage.bind(this);
    this.execute = this.execute.bind(this);
    this.connect = this.connect.bind(this);
    this.wsOpenHandler = (event) => {
      var _a2;
      (_a2 = this._socket) == null ? void 0 : _a2.removeEventListener("open", this.wsOpenHandler);
      this._onSocketOpen(event);
    };
    this.wsCloseHandler = (event) => {
      var _a2;
      (_a2 = this._socket) == null ? void 0 : _a2.removeEventListener("close", this.wsCloseHandler);
      this._onSocketClose(event);
    };
    this.wsErrorHandler = (event) => {
      var _a2;
      (_a2 = this._socket) == null ? void 0 : _a2.removeEventListener("error", this.wsErrorHandler);
      this._onSocketError(event);
    };
  }
  get host() {
    return this._host;
  }
  get rpcConnectResult() {
    return this._rpcConnectResult;
  }
  get relayProtocol() {
    var _a, _b;
    return (_b = (_a = this._rpcConnectResult) == null ? void 0 : _a.protocol) != null ? _b : "";
  }
  get signature() {
    var _a, _b;
    return (_b = (_a = this._rpcConnectResult) == null ? void 0 : _a.authorization) == null ? void 0 : _b.signature;
  }
  get logger() {
    return getLogger();
  }
  get connecting() {
    var _a;
    return ((_a = this._socket) == null ? void 0 : _a.readyState) === 0 /* CONNECTING */;
  }
  get connected() {
    var _a;
    return ((_a = this._socket) == null ? void 0 : _a.readyState) === 1 /* OPEN */;
  }
  get closing() {
    var _a;
    return ((_a = this._socket) == null ? void 0 : _a.readyState) === 2 /* CLOSING */;
  }
  get closed() {
    return this._socket ? this._socket.readyState === 3 /* CLOSED */ : true;
  }
  get status() {
    return this._status;
  }
  get idle() {
    return this._status === "idle";
  }
  get ready() {
    return !Boolean(this.idle || !this.connected);
  }
  set token(token) {
    this.options.token = token;
  }
  connect() {
    if (!(this == null ? void 0 : this.WebSocketConstructor)) {
      throw new Error("Missing WebSocketConstructor");
    }
    this._clearTimers();
    if (this.connecting || this.connected) {
      this.logger.warn("Session already connected.");
      return;
    }
    this._removeSocketListeners();
    this.destroySocket();
    this._clearCheckPingTimer();
    this._socket = this._createSocket();
    this._addSocketListeners();
  }
  _createSocket() {
    return new this.WebSocketConstructor(this._host);
  }
  destroySocket() {
    if (this._socket) {
      this._socket.close();
      this._socket = null;
    }
  }
  _addSocketListeners() {
    if (!this._socket) {
      return this.logger.debug("Invalid socket instance to add listeners");
    }
    this._removeSocketListeners();
    this._socket.addEventListener("open", this.wsOpenHandler);
    this._socket.addEventListener("close", this.wsCloseHandler);
    this._socket.addEventListener("error", this.wsErrorHandler);
    this._socket.addEventListener("message", this._onSocketMessage);
  }
  _removeSocketListeners() {
    if (!this._socket) {
      return this.logger.debug("Invalid socket instance to remove listeners");
    }
    this._socket.removeEventListener("open", this.wsOpenHandler);
    this._socket.removeEventListener("close", this.wsCloseHandler);
    this._socket.removeEventListener("error", this.wsErrorHandler);
    this._socket.removeEventListener("message", this._onSocketMessage);
  }
  disconnect() {
    return __async(this, null, function* () {
      if (!this._socket || this.closing) {
        this.logger.debug("Session not connected or already in closing state.");
        return;
      }
      this._clearCheckPingTimer();
      this._requests.clear();
      this._closeConnection("disconnected");
      this.dispatch(sessionDisconnectedAction());
    });
  }
  execute(msg) {
    let promise = Promise.resolve();
    if ("params" in msg) {
      promise = new Promise((resolve, reject) => {
        this._requests.set(msg.id, { rpcRequest: msg, resolve, reject });
      });
    }
    if (!this.ready) {
      this._addToExecuteQueue(msg);
      this.connect();
      return promise;
    }
    this._send(msg);
    return timeoutPromise(promise, this._executeTimeoutMs, this._executeTimeoutError).catch((error) => {
      if (error === this._executeTimeoutError) {
        this.logger.error("Request Timeout", msg);
        if (this.status === "disconnected") {
          return this.logger.debug("Request failed because the session is disconnected", this.status, this._socket);
        }
        this._closeConnection("reconnecting");
      } else {
        throw error;
      }
    });
  }
  authenticate() {
    return __async(this, null, function* () {
      var _a;
      const params = {
        agent: this.agent,
        version: this.connectVersion,
        authentication: {
          project: this.options.project,
          token: this.options.token
        }
      };
      if (this._relayProtocolIsValid()) {
        params.protocol = this.relayProtocol;
      }
      if ((_a = this.options.contexts) == null ? void 0 : _a.length) {
        params.contexts = this.options.contexts;
      }
      this._rpcConnectResult = yield this.execute(RPCConnect(params));
    });
  }
  authError(error) {
    this._removeSocketListeners();
    this.dispatch(authErrorAction({ error }));
  }
  _onSocketOpen(event) {
    return __async(this, null, function* () {
      this.logger.debug("_onSocketOpen", event.type);
      try {
        this._clearTimers();
        yield this.authenticate();
        this._status = "connected";
        this._flushExecuteQueue();
        this.dispatch(authSuccessAction());
      } catch (error) {
        this.logger.error("Auth Error", error);
        this.authError(error);
      }
    });
  }
  _onSocketError(event) {
    this.logger.debug("_onSocketError", event);
  }
  _onSocketClose(event) {
    this.logger.debug("_onSocketClose", event.type, event.code, event.reason);
    if (this._status !== "disconnected") {
      this._status = "reconnecting";
      this.dispatch(sessionReconnectingAction());
      this._clearTimers();
      this._reconnectTimer = setTimeout(() => {
        this.connect();
      }, reconnectDelay());
    }
    this._socket = null;
  }
  _clearTimers() {
    clearTimeout(this._reconnectTimer);
  }
  _onSocketMessage(event) {
    const payload = this.decode(event.data);
    this.logger.wsTraffic({ type: "recv", payload });
    if (isJSONRPCResponse(payload)) {
      const request = this._requests.get(payload.id);
      if (request) {
        const { rpcRequest, resolve, reject } = request;
        this._requests.delete(payload.id);
        const { result, error } = parseRPCResponse({
          response: payload,
          request: rpcRequest
        });
        return error ? reject(error) : resolve(result);
      }
      return this.logger.warn("Unknown request for", payload);
    }
    switch (payload.method) {
      case "signalwire.ping":
        return this._pingHandler(payload);
      case "signalwire.disconnect": {
        this.execute(RPCDisconnectResponse(payload.id)).catch((error) => {
          this.logger.error("SwDisconnect Error", error);
        }).finally(() => {
          this._status = "idle";
        });
        break;
      }
      default:
        this.dispatch(socketMessageAction(payload));
        this._handleWebSocketMessage(payload);
    }
  }
  _handleWebSocketMessage(_payload) {
  }
  dispatch(_payload) {
    throw new Error("Method not implemented");
  }
  _relayProtocolIsValid() {
    var _a;
    return this.signature && ((_a = this == null ? void 0 : this.relayProtocol) == null ? void 0 : _a.split("_")[1]) === this.signature;
  }
  encode(input) {
    return JSON.stringify(input);
  }
  decode(input) {
    return safeParseJson(input);
  }
  _send(msg) {
    this.logger.wsTraffic({ type: "send", payload: msg });
    this._socket.send(this.encode(msg));
  }
  _addToExecuteQueue(msg) {
    this.logger.warn("Request queued waiting for session to reconnect", msg);
    this._executeQueue.add(msg);
  }
  _flushExecuteQueue() {
    if (!this._executeQueue.size) {
      return;
    }
    if (!this.ready) {
      this.logger.warn(`Session not ready to flush the queue.`);
      this._closeConnection("reconnecting");
      return;
    }
    this.logger.debug(`${this._executeQueue.size} messages to flush`);
    this._executeQueue.forEach((msg) => {
      this._send(msg);
      this._executeQueue.delete(msg);
    });
    this._executeQueue.clear();
  }
  _clearCheckPingTimer() {
    clearTimeout(this._checkPingTimer);
  }
  _pingHandler(payload) {
    return __async(this, null, function* () {
      var _a;
      this._clearCheckPingTimer();
      this._checkPingTimer = setTimeout(() => {
        this.logger.debug("Timeout waiting for ping");
        this._closeConnection("reconnecting");
      }, this._checkPingDelay);
      yield this.execute(RPCPingResponse(payload.id, (_a = payload == null ? void 0 : payload.params) == null ? void 0 : _a.timestamp));
    });
  }
  _closeConnection(status) {
    this._clearCheckPingTimer();
    this.logger.debug("Close Connection");
    this._status = status;
    this.dispatch(sessionActions.authStatus(status === "disconnected" ? "unauthorized" : "unknown"));
    this.destroySocket();
  }
};

// src/BaseJWTSession.ts
var BaseJWTSession = class extends BaseSession {
  constructor(options) {
    super(options);
    this.options = options;
    __publicField(this, "_expiredDiffSeconds", 0);
    __publicField(this, "_refreshTokenNotificationDiff", 120);
    __publicField(this, "_checkTokenExpirationDelay", 20 * 1e3);
    __publicField(this, "_checkTokenExpirationTimer", null);
    this._checkTokenExpiration = this._checkTokenExpiration.bind(this);
    this.reauthenticate = this.reauthenticate.bind(this);
  }
  get expiresAt() {
    var _a, _b, _c;
    const expiresAt = (_c = (_b = (_a = this == null ? void 0 : this._rpcConnectResult) == null ? void 0 : _a.authorization) == null ? void 0 : _b.expires_at) != null ? _c : 0;
    if (typeof expiresAt === "string") {
      const parsed = Date.parse(expiresAt);
      if (!isNaN(parsed)) {
        return Math.floor(parsed / 1e3);
      }
    }
    return expiresAt;
  }
  get expiresIn() {
    const now = Math.floor(Date.now() / 1e3);
    return this.expiresAt - now;
  }
  get expired() {
    return this.expiresAt > 0 && this.expiresIn <= this._expiredDiffSeconds;
  }
  authenticate() {
    return __async(this, null, function* () {
      const params = {
        agent: this.agent,
        version: this.connectVersion,
        authentication: {
          jwt_token: this.options.token
        }
      };
      if (this._relayProtocolIsValid()) {
        params.protocol = this.relayProtocol;
      } else {
        const prevProtocol = yield this.retrieveRelayProtocol();
        if (prevProtocol) {
          params.protocol = prevProtocol;
        }
      }
      this._rpcConnectResult = yield this.execute(RPCConnect(params));
      yield this.persistRelayProtocol();
      this._checkTokenExpiration();
    });
  }
  retrieveRelayProtocol() {
    return __async(this, null, function* () {
      return "";
    });
  }
  persistRelayProtocol() {
    return __async(this, null, function* () {
    });
  }
  reauthenticate() {
    return __async(this, null, function* () {
      this.logger.debug("Session Reauthenticate", {
        ready: this.ready,
        expired: this.expired
      });
      if (!this.ready || this.expired) {
        return this.connect();
      }
      const params = {
        project: this._rpcConnectResult.authorization.project,
        jwt_token: this.options.token
      };
      try {
        this._rpcConnectResult = yield this.execute(RPCReauthenticate(params));
      } catch (error) {
        clearTimeout(this._checkTokenExpirationTimer);
        throw error;
      }
    });
  }
  _onSocketClose(event) {
    clearTimeout(this._checkTokenExpirationTimer);
    super._onSocketClose(event);
  }
  _checkTokenExpiration() {
    if (!this.expiresAt) {
      return;
    }
    if (this.expiresIn <= this._refreshTokenNotificationDiff) {
      this.dispatch(authExpiringAction());
      if (this.options._onRefreshToken) {
        this.options._onRefreshToken();
      } else {
        this.logger.warn("The token is going to expire!");
      }
    }
    clearTimeout(this._checkTokenExpirationTimer);
    if (!this.expired) {
      this._checkTokenExpirationTimer = setTimeout(this._checkTokenExpiration, this._checkTokenExpirationDelay);
    }
  }
};

// src/redux/index.ts
var redux_exports = {};
__export(redux_exports, {
  authErrorAction: () => authErrorAction,
  authExpiringAction: () => authExpiringAction,
  authSuccessAction: () => authSuccessAction,
  compoundEventAttachAction: () => compoundEventAttachAction,
  configureStore: () => configureStore2,
  connect: () => connect,
  createAction: () => createAction,
  createCatchableSaga: () => createCatchableSaga,
  createRestartableSaga: () => createRestartableSaga,
  destroyAction: () => destroyAction,
  eventChannel: () => import_core.eventChannel,
  executeAction: () => executeAction,
  getCustomSagaActionType: () => getCustomSagaActionType,
  initAction: () => initAction,
  makeCustomSagaAction: () => makeCustomSagaAction,
  reauthAction: () => reauthAction,
  sessionAuthErrorAction: () => sessionAuthErrorAction,
  sessionConnectedAction: () => sessionConnectedAction,
  sessionDisconnectedAction: () => sessionDisconnectedAction,
  sessionExpiringAction: () => sessionExpiringAction,
  sessionReconnectingAction: () => sessionReconnectingAction,
  socketMessageAction: () => socketMessageAction
});
var import_core3 = __toESM(require("@redux-saga/core"));

// src/redux/features/component/componentSlice.ts
var initialComponentState = {
  byId: {}
};
var requestUpdater = ({
  state,
  payload,
  componentId,
  key,
  requestId
}) => {
  if (componentId in state.byId) {
    return __spreadProps(__spreadValues({}, state), {
      byId: __spreadProps(__spreadValues({}, state.byId), {
        [componentId]: __spreadProps(__spreadValues({}, state.byId[componentId]), {
          [key]: __spreadProps(__spreadValues({}, state.byId[componentId][key]), {
            [requestId]: payload
          })
        })
      })
    });
  } else {
    return __spreadProps(__spreadValues({}, state), {
      byId: __spreadProps(__spreadValues({}, state.byId), {
        [componentId]: {
          id: componentId,
          [key]: {
            [requestId]: payload
          }
        }
      })
    });
  }
};
var componentSlice = createDestroyableSlice({
  name: "components",
  initialState: initialComponentState,
  reducers: {
    upsert: (state, { payload }) => {
      if (payload.id in state.byId) {
        return __spreadProps(__spreadValues({}, state), {
          byId: __spreadProps(__spreadValues({}, state.byId), {
            [payload.id]: __spreadValues(__spreadValues({}, state.byId[payload.id]), payload)
          })
        });
      } else {
        return __spreadProps(__spreadValues({}, state), {
          byId: __spreadProps(__spreadValues({}, state.byId), {
            [payload.id]: payload
          })
        });
      }
    },
    executeSuccess: (state, { payload }) => {
      const { componentId, requestId, response } = payload;
      return requestUpdater({
        componentId,
        requestId,
        state,
        key: "responses",
        payload: response
      });
    },
    executeFailure: (state, { payload }) => {
      const { componentId, requestId, error, action } = payload;
      return requestUpdater({
        componentId,
        requestId,
        state,
        key: "errors",
        payload: {
          action,
          jsonrpc: error
        }
      });
    },
    cleanup: (state, { payload }) => {
      return __spreadProps(__spreadValues({}, state), {
        byId: Object.entries(state.byId).reduce((reducer, [componentId, value]) => {
          if (!payload.ids.includes(componentId)) {
            reducer[componentId] = value;
          }
          return reducer;
        }, {})
      });
    }
  }
});
var {
  actions: componentActions,
  reducer: componentReducer
} = componentSlice;

// src/redux/features/executeQueue/executeQueueSlice.ts
var initialExecuteQueueState = {
  queue: []
};
var executeQueueSlice = createDestroyableSlice({
  name: "executeQueue",
  initialState: initialExecuteQueueState,
  reducers: {
    add: (state, { payload }) => {
      return __spreadProps(__spreadValues({}, state), {
        queue: state.queue.concat(payload)
      });
    },
    clean: () => {
      return initialExecuteQueueState;
    }
  }
});
var {
  actions: executeQueueActions,
  reducer: executeQueueReducer
} = executeQueueSlice;

// src/redux/rootReducer.ts
var rootReducer = (0, toolkit_exports.combineReducers)({
  components: componentReducer,
  session: sessionReducer,
  executeQueue: executeQueueReducer
});

// src/redux/rootSaga.ts
var import_effects4 = require("@redux-saga/core/effects");

// src/redux/features/session/sessionSaga.ts
var import_core2 = require("@redux-saga/core");
var import_effects2 = require("@redux-saga/core/effects");

// src/redux/utils/sagaHelpers.ts
var sagaHelpers_exports = {};
__export(sagaHelpers_exports, {
  createCatchableSaga: () => createCatchableSaga,
  createRestartableSaga: () => createRestartableSaga,
  eventChannel: () => import_core.eventChannel
});
var import_effects = require("@redux-saga/core/effects");
var import_core = require("@redux-saga/core");
var createRestartableSaga = (saga) => {
  return function* () {
    (0, import_effects.spawn)(function* () {
      while (true) {
        try {
          getLogger().debug("Run a restartable saga");
          yield (0, import_effects.call)(saga);
          getLogger().debug("One of the restartable saga has ended. Restarting..");
        } catch (error) {
          getLogger().error("Restartable Saga Error", error);
        }
      }
    });
  };
};
var defaultCatchHandler = (error) => getLogger().error("Catchable Saga Error", error);
var createCatchableSaga = (saga, errorHandler = defaultCatchHandler) => {
  return function* (...params) {
    try {
      yield (0, import_effects.call)(saga, ...params);
    } catch (error) {
      errorHandler(error);
    }
  };
};

// src/redux/features/session/sessionSaga.ts
var isWebrtcEvent = (e) => {
  return (e == null ? void 0 : e.event_type) === "webrtc.message";
};
var isVideoEvent = (e) => {
  var _a;
  return !!((_a = e == null ? void 0 : e.event_type) == null ? void 0 : _a.startsWith("video."));
};
function* executeActionWatcher(session) {
  function* worker(action) {
    const { componentId, requestId, method, params } = action.payload;
    try {
      const message = RPCExecute({
        id: requestId,
        method,
        params
      });
      const response = yield (0, import_effects2.call)(session.execute, message);
      if (componentId && requestId) {
        yield (0, import_effects2.put)(componentActions.executeSuccess({
          componentId,
          requestId,
          response
        }));
      }
    } catch (error) {
      getLogger().warn("Execute error:", error);
      if (componentId && requestId) {
        yield (0, import_effects2.put)(componentActions.executeFailure({
          componentId,
          requestId,
          action,
          error
        }));
      }
    } finally {
      const isCancelled = yield (0, import_effects2.cancelled)();
      if (isCancelled && componentId && requestId) {
        const error = {
          jsonrpc: "2.0",
          id: requestId,
          error: {
            code: -32600,
            message: "Cancelled task"
          }
        };
        getLogger().debug("executeActionWorker cancelled", {
          requestId,
          componentId,
          error
        });
        yield (0, import_effects2.put)(componentActions.executeFailure({
          componentId,
          requestId,
          action,
          error
        }));
      }
    }
  }
  while (true) {
    const action = yield (0, import_effects2.take)(executeAction.type);
    yield (0, import_effects2.fork)(worker, action);
  }
}
function* sessionChannelWatcher({
  sessionChannel,
  pubSubChannel,
  swEventChannel
}) {
  function* videoAPIWorker(params) {
    switch (params.event_type) {
      case "video.room.audience_count": {
        yield (0, import_effects2.put)(pubSubChannel, {
          type: "video.room.audienceCount",
          payload: params.params
        });
        return;
      }
      case "video.member.updated": {
        return;
      }
      case "video.member.talking": {
        const { member } = params.params;
        if ("talking" in member) {
          const suffix = member.talking ? "started" : "ended";
          yield (0, import_effects2.put)(pubSubChannel, {
            type: `video.member.talking.${suffix}`,
            payload: params.params
          });
          const deprecatedSuffix = member.talking ? "start" : "stop";
          yield (0, import_effects2.put)(pubSubChannel, {
            type: `video.member.talking.${deprecatedSuffix}`,
            payload: params.params
          });
        }
        break;
      }
    }
    yield (0, import_effects2.put)(pubSubChannel, {
      type: params.event_type,
      payload: params.params
    });
  }
  function* swEventWorker(broadcastParams) {
    yield (0, import_effects2.put)(swEventChannel, toInternalAction(broadcastParams));
    if (isWebrtcEvent(broadcastParams)) {
      return;
    }
    if (isVideoEvent(broadcastParams)) {
      yield (0, import_effects2.fork)(videoAPIWorker, broadcastParams);
      return;
    }
    yield (0, import_effects2.put)({ type: broadcastParams.event_type, payload: broadcastParams });
  }
  function* sessionChannelWorker(action) {
    if (action.type !== socketMessageAction.type) {
      yield (0, import_effects2.put)(action);
      return;
    }
    const { method, params } = action.payload;
    switch (method) {
      case "signalwire.event":
        yield (0, import_effects2.fork)(swEventWorker, params);
        break;
      default:
        return getLogger().debug(`Unknown message: ${method}`, action);
    }
  }
  const sessionChannelWorkerCatchable = createCatchableSaga(sessionChannelWorker, (error) => {
    getLogger().error("Channel Error", error);
  });
  while (true) {
    try {
      while (true) {
        const action = yield (0, import_effects2.take)(sessionChannel);
        yield (0, import_effects2.fork)(sessionChannelWorkerCatchable, action);
      }
    } catch (error) {
      getLogger().error("sessionChannelWorker error:", error);
    } finally {
      getLogger().debug("sessionChannelWorker finally");
    }
  }
}
function createSessionChannel(session) {
  return (0, import_core2.eventChannel)((emit) => {
    session.dispatch = (payload) => {
      emit(payload);
    };
    const unsubscribe = () => {
      getLogger().debug("sessionChannel unsubscribe");
      session.disconnect();
    };
    return unsubscribe;
  });
}

// src/redux/features/pubSub/pubSubSaga.ts
var import_effects3 = require("@redux-saga/core/effects");

// src/redux/features/shared/namespace.ts
var isVideoMemberEvent = (action) => {
  return action.type.startsWith("video.member.") || action.type.startsWith("video.__synthetic__.member");
};
var isVideoRoomEvent = (action) => {
  return action.type.startsWith("video.room.");
};
var isVideoRoomAudienceCountEvent = (action) => {
  return action.type === "video.room.audience_count" || action.type === "video.room.audienceCount";
};
var isVideoLayoutEvent = (action) => {
  return action.type.startsWith("video.layout.");
};
var isVideoRecordingEvent = (action) => {
  return action.type.startsWith("video.recording.");
};
var isVideoPlaybackEvent = (action) => {
  return action.type.startsWith("video.playback.");
};
var isVideoStreamEvent = (action) => {
  return action.type.startsWith("video.stream.");
};
var isChatEvent = (action) => {
  return action.type.startsWith("chat.");
};
var isVoiceCallEvent = (action) => {
  return action.type.startsWith("calling.");
};
var findNamespaceInPayload = (action) => {
  var _a;
  if (action.payload === void 0) {
    return "";
  } else if (isVideoMemberEvent(action) || isVideoLayoutEvent(action) || isVideoRecordingEvent(action) || isVideoPlaybackEvent(action) || isVideoStreamEvent(action) || isVideoRoomAudienceCountEvent(action)) {
    return action.payload.room_session_id;
  } else if (isVideoRoomEvent(action)) {
    return action.payload.room_session.id;
  } else if (isChatEvent(action)) {
    return "";
  } else if (isVoiceCallEvent(action)) {
    return (_a = action.payload.tag) != null ? _a : "";
  }
  if (process.env.NODE_ENV === "development") {
    getLogger().info("Namespace not found for action.type: ", action == null ? void 0 : action.type);
  }
  return "";
};

// src/redux/features/pubSub/pubSubSaga.ts
function* pubSubSaga({
  pubSubChannel,
  emitter
}) {
  getLogger().debug("pubSubSaga [started]");
  try {
    while (true) {
      const pubSubAction = yield (0, import_effects3.take)(pubSubChannel, "*");
      const { type, payload } = pubSubAction;
      try {
        const namespace = findNamespaceInPayload(pubSubAction);
        if (isInternalGlobalEvent(type)) {
          emitter.emit(type, payload);
        }
        getLogger().trace("Emit:", toInternalEventName({ namespace, event: type }));
        emitter.emit(toInternalEventName({ namespace, event: type }), payload);
      } catch (error) {
        getLogger().error(error);
      }
    }
  } finally {
    if (yield (0, import_effects3.cancelled)()) {
      getLogger().debug("pubSubSaga [cancelled]");
    }
  }
}

// src/CustomErrors.ts
var AuthError = class extends Error {
  constructor(code, message) {
    super(message);
    this.code = code;
    this.message = message;
    __publicField(this, "name", "AuthError");
    Object.setPrototypeOf(this, AuthError.prototype);
  }
};
var HttpError = class extends Error {
  constructor(code, message, response) {
    super(message);
    this.code = code;
    this.message = message;
    this.response = response;
    __publicField(this, "name", "HttpError");
    Object.setPrototypeOf(this, HttpError.prototype);
  }
};

// src/redux/rootSaga.ts
function* initSessionSaga({
  SessionConstructor,
  userOptions,
  channels
}) {
  var _a;
  const session = new SessionConstructor(userOptions);
  const sessionChannel = yield (0, import_effects4.call)(createSessionChannel, session);
  const pubSubChannel = channels.pubSubChannel;
  const swEventChannel = channels.swEventChannel;
  let customTasks = [];
  if ((_a = userOptions.workers) == null ? void 0 : _a.length) {
    try {
      const effects = userOptions.workers.map((saga) => {
        return (0, import_effects4.call)(createRestartableSaga(saga));
      });
      customTasks = yield (0, import_effects4.all)(effects);
    } catch (error) {
      getLogger().error("Error running custom workers", error);
    }
  }
  yield (0, import_effects4.fork)(sessionChannelWatcher, {
    sessionChannel,
    pubSubChannel,
    swEventChannel
  });
  const pubSubTask = yield (0, import_effects4.fork)(pubSubSaga, {
    pubSubChannel,
    emitter: userOptions.emitter
  });
  const sessionStatusTask = yield (0, import_effects4.fork)(sessionStatusWatcher, {
    session,
    sessionChannel,
    pubSubChannel,
    userOptions
  });
  const executeActionTask = yield (0, import_effects4.fork)(executeActionWatcher, session);
  session.connect();
  yield (0, import_effects4.take)(destroyAction.type);
  pubSubTask.cancel();
  sessionStatusTask.cancel();
  executeActionTask.cancel();
  sessionChannel.close();
  customTasks.forEach((task) => task.cancel());
}
function* reauthenticateWorker({
  session,
  token,
  pubSubChannel
}) {
  try {
    if (session.reauthenticate) {
      session.token = token;
      yield (0, import_effects4.call)(session.reauthenticate);
      yield (0, import_effects4.put)(sessionActions.connected(session.rpcConnectResult));
      yield (0, import_effects4.put)(pubSubChannel, sessionConnectedAction());
    }
  } catch (error) {
    getLogger().error("Reauthenticate Error", error);
    session.authError(error);
  }
}
function* sessionStatusWatcher(options) {
  getLogger().debug("sessionStatusWatcher [started]");
  try {
    while (true) {
      const action = yield (0, import_effects4.take)([
        authSuccessAction.type,
        authErrorAction.type,
        authExpiringAction.type,
        reauthAction.type,
        sessionReconnectingAction.type,
        sessionDisconnectedAction.type
      ]);
      getLogger().debug("sessionStatusWatcher", action.type, action.payload);
      switch (action.type) {
        case authSuccessAction.type: {
          const { session, pubSubChannel } = options;
          yield (0, import_effects4.put)(sessionActions.connected(session.rpcConnectResult));
          yield (0, import_effects4.put)(pubSubChannel, sessionConnectedAction());
          break;
        }
        case authErrorAction.type: {
          yield (0, import_effects4.fork)(sessionAuthErrorSaga, __spreadProps(__spreadValues({}, options), {
            action
          }));
          break;
        }
        case authExpiringAction.type: {
          yield (0, import_effects4.put)(options.pubSubChannel, sessionExpiringAction());
          break;
        }
        case reauthAction.type: {
          yield (0, import_effects4.fork)(reauthenticateWorker, {
            session: options.session,
            token: action.payload.token,
            pubSubChannel: options.pubSubChannel
          });
          break;
        }
        case sessionReconnectingAction.type: {
          yield (0, import_effects4.put)(options.pubSubChannel, sessionReconnectingAction());
          break;
        }
        case sessionDisconnectedAction.type: {
          yield (0, import_effects4.put)(options.pubSubChannel, sessionDisconnectedAction());
          yield (0, import_effects4.put)(destroyAction());
          break;
        }
      }
    }
  } finally {
    if (yield (0, import_effects4.cancelled)()) {
      getLogger().debug("sessionStatusWatcher [cancelled]");
    }
  }
}
function* sessionAuthErrorSaga(options) {
  getLogger().debug("sessionAuthErrorSaga [started]");
  try {
    const { pubSubChannel, action } = options;
    const { error: authError } = action.payload;
    const error = authError ? new AuthError(authError.code, authError.message) : new Error("Unauthorized");
    yield (0, import_effects4.put)(pubSubChannel, sessionAuthErrorAction(error));
  } finally {
    if (yield (0, import_effects4.cancelled)()) {
      getLogger().debug("sessionAuthErrorSaga [cancelled]");
    }
  }
}
var rootSaga_default = (options) => {
  return function* root({
    userOptions,
    channels
  }) {
    var _a;
    if (userOptions.logger) {
      setLogger(userOptions.logger);
    }
    if (userOptions.debug) {
      setDebugOptions(userOptions.debug);
    }
    while (true) {
      const action = yield (0, import_effects4.take)([initAction.type, reauthAction.type]);
      if ((_a = action == null ? void 0 : action.payload) == null ? void 0 : _a.token) {
        userOptions.token = action.payload.token;
      }
      try {
        yield (0, import_effects4.call)(initSessionSaga, __spreadProps(__spreadValues({}, options), {
          userOptions,
          channels
        }));
      } catch (error) {
        getLogger().error("RootSaga Error:", error);
      } finally {
        if (yield (0, import_effects4.cancelled)()) {
          getLogger().debug("rootSaga [cancelled]");
        }
        getLogger().debug("Reboot rootSaga");
      }
    }
  };
};

// src/redux/features/component/componentSelectors.ts
var componentSelectors_exports = {};
__export(componentSelectors_exports, {
  getComponent: () => getComponent,
  getComponentsById: () => getComponentsById,
  getComponentsToCleanup: () => getComponentsToCleanup
});
var getComponent = ({ components }, id) => {
  var _a;
  return (_a = components.byId) == null ? void 0 : _a[id];
};
var getComponentsById = ({ components }) => {
  return components.byId;
};
var getComponentsToCleanup = (state) => {
  const components = getComponentsById(state);
  let toCleanup = [];
  Object.keys(components).forEach((id) => {
    if (components[id].responses || components[id].errors) {
      toCleanup.push(id);
    }
  });
  return toCleanup;
};

// src/redux/features/session/sessionSelectors.ts
var sessionSelectors_exports = {};
__export(sessionSelectors_exports, {
  getAuthError: () => getAuthError,
  getAuthState: () => getAuthState,
  getAuthStatus: () => getAuthStatus,
  getIceServers: () => getIceServers,
  getSession: () => getSession
});
var getIceServers = ({ session }) => {
  var _a;
  return (_a = session == null ? void 0 : session.iceServers) != null ? _a : [];
};
var getSession = (store) => {
  return store.session;
};
var getAuthStatus = ({ session }) => {
  return session.authStatus;
};
var getAuthError = ({ session }) => {
  return session.authError;
};
var getAuthState = ({ session }) => {
  return session.authState;
};

// src/redux/connect.ts
var connect = (options) => {
  const {
    componentListeners = {},
    sessionListeners = {},
    store,
    Component,
    customSagas = []
  } = options;
  const componentKeys = Object.keys(componentListeners);
  const sessionKeys = Object.keys(sessionListeners);
  return (userOptions) => {
    const instance = new Component(__spreadProps(__spreadValues({}, userOptions), { store }));
    const cacheMap = /* @__PURE__ */ new Map();
    let run = true;
    const storeUnsubscribe = store.subscribe(() => {
      const state = store.getState();
      const component = getComponent(state, instance.__uuid) || {};
      for (const reduxKey of componentKeys) {
        if (run === false) {
          return;
        }
        const cacheKey = `${instance.__uuid}.${reduxKey}`;
        const current = cacheMap.get(cacheKey);
        const updatedValue = component[reduxKey];
        if (updatedValue !== void 0 && current !== updatedValue) {
          cacheMap.set(cacheKey, updatedValue);
          const fnName = componentListeners[reduxKey];
          if (typeof fnName === "string") {
            instance[fnName](component);
          } else {
            fnName(component);
          }
        }
      }
      const session = getSession(state);
      for (const reduxKey of sessionKeys) {
        if (run === false) {
          return;
        }
        const cacheKey = `session.${reduxKey}`;
        const current = cacheMap.get(cacheKey);
        const updatedValue = session[reduxKey];
        if (updatedValue !== void 0 && current !== updatedValue) {
          cacheMap.set(cacheKey, updatedValue);
          const fnName = sessionListeners[reduxKey];
          if (typeof fnName === "string") {
            instance[fnName](session);
          } else if (typeof fnName === "function") {
            fnName(session);
          }
        }
      }
    });
    const taskList = customSagas == null ? void 0 : customSagas.map((saga) => {
      return store.runSaga(saga, { instance, runSaga: store.runSaga });
    });
    instance.destroyer = () => {
      run = false;
      storeUnsubscribe();
      cacheMap.clear();
      if (taskList == null ? void 0 : taskList.length) {
        taskList.forEach((task) => task.cancel());
      }
    };
    return instance;
  };
};

// src/redux/index.ts
__reExport(redux_exports, toolkit_exports);
var configureStore2 = (options) => {
  var _a;
  const {
    userOptions,
    SessionConstructor,
    preloadedState = {},
    runSagaMiddleware = true
  } = options;
  const sagaMiddleware = (0, import_core3.default)();
  const pubSubChannel = (0, import_core3.multicastChannel)();
  const swEventChannel = (0, import_core3.multicastChannel)();
  const channels = {
    pubSubChannel,
    swEventChannel
  };
  const store = configureStore({
    devTools: (_a = userOptions == null ? void 0 : userOptions.devTools) != null ? _a : true,
    reducer: rootReducer,
    preloadedState,
    middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(sagaMiddleware)
  });
  const runSaga = (saga, args) => {
    return sagaMiddleware.run(saga, __spreadProps(__spreadValues({}, args), {
      channels
    }));
  };
  if (runSagaMiddleware) {
    const saga = rootSaga_default({
      SessionConstructor
    });
    sagaMiddleware.run(saga, { userOptions, channels });
  }
  return __spreadProps(__spreadValues({}, store), {
    runSaga
  });
};

// src/BaseComponent.ts
var identity = (payload) => payload;
var SW_SYMBOL2 = Symbol("BaseComponent");
var BaseComponent = class {
  constructor(options) {
    this.options = options;
    __publicField(this, "__sw_symbol", SW_SYMBOL2);
    __publicField(this, "uuid", (0, import_uuid.v4)());
    __publicField(this, "_eventsPrefix", "");
    __publicField(this, "_eventsRegisterQueue", /* @__PURE__ */ new Set());
    __publicField(this, "_eventsEmitQueue", /* @__PURE__ */ new Set());
    __publicField(this, "_eventsNamespace");
    __publicField(this, "_eventsTransformsCache", /* @__PURE__ */ new Map());
    __publicField(this, "_requests", /* @__PURE__ */ new Map());
    __publicField(this, "_customSagaTriggers", /* @__PURE__ */ new Map());
    __publicField(this, "_destroyer");
    __publicField(this, "_emitterTransforms", /* @__PURE__ */ new Map());
    __publicField(this, "_emitterListenersCache", /* @__PURE__ */ new Map());
    __publicField(this, "_trackedEvents", []);
    __publicField(this, "_runningWorkers", []);
    __publicField(this, "_workers", /* @__PURE__ */ new Map());
  }
  get __uuid() {
    return this.uuid;
  }
  _handleCompoundEvents(event) {
    const internalEvent = this._getInternalEvent(event);
    let compoundEvents;
    for (const evt of this.getCompoundEvents().keys()) {
      if (this._getInternalEvent(evt) === internalEvent) {
        compoundEvents = this.getCompoundEvents().get(evt);
        break;
      }
    }
    if (!compoundEvents || compoundEvents.length === 0) {
      return;
    }
    this.store.dispatch(compoundEventAttachAction({
      compoundEvents,
      event: internalEvent,
      namespace: this._eventsNamespace
    }));
    compoundEvents.forEach((compoundEvent) => {
      if (typeof compoundEvent === "string") {
        this._trackEvent(compoundEvent);
      }
    });
  }
  _getNamespacedEvent(event) {
    let namespace = this._eventsNamespace;
    if (typeof event === "string" && isLocalEvent(event)) {
      namespace = this.__uuid;
    }
    return toInternalEventName({
      event,
      namespace
    });
  }
  _getPrefixedEvent(event) {
    if (this._eventsPrefix && typeof event === "string" && !event.includes(`${this._eventsPrefix}.`) && !isSessionEvent(event)) {
      return `${this._eventsPrefix}.${event}`;
    }
    return event;
  }
  _getInternalEvent(event) {
    return this._getNamespacedEvent(this._getPrefixedEvent(event));
  }
  get logger() {
    return getLogger();
  }
  set destroyer(d) {
    this._destroyer = d;
  }
  get store() {
    return this.options.store;
  }
  get emitter() {
    return this.options.emitter;
  }
  addEventToRegisterQueue(options) {
    const [event, fn] = options.params;
    this.logger.trace("Adding event to the register queue", { event, fn });
    this._eventsRegisterQueue.add({
      type: options.type,
      params: options.params
    });
    return this.emitter;
  }
  _addEventToEmitQueue(event, args) {
    this.logger.trace("Adding to the emit queue", event);
    this._eventsEmitQueue.add({ event, args });
  }
  shouldAddToQueue() {
    return this._eventsNamespace === void 0;
  }
  runAndCacheEventHandlerTransform({
    internalEvent,
    transform,
    payload
  }) {
    if (transform.mode === "no-cache") {
      const instance = transform.instanceFactory(payload);
      return instance;
    } else if (!this._eventsTransformsCache.has(internalEvent)) {
      const instance = transform.instanceFactory(payload);
      this._eventsTransformsCache.set(internalEvent, instance);
      return instance;
    }
    return this._eventsTransformsCache.get(internalEvent);
  }
  cleanupEventHandlerTransformCache({
    internalEvent,
    force
  }) {
    const instance = this._eventsTransformsCache.get(internalEvent);
    const eventCount = this.listenerCount(internalEvent);
    if (instance && (force || eventCount <= 1)) {
      if (instance.__uuid !== this.__uuid && typeof instance.destroy === "function") {
        instance.destroy();
      }
      return this._eventsTransformsCache.delete(internalEvent);
    }
    this.logger.trace(`[cleanupEventHandlerTransformCache] Key wasn't cached`, internalEvent);
    return false;
  }
  getEmitterListenersMapByInternalEventName(internalEvent) {
    var _a;
    return (_a = this._emitterListenersCache.get(internalEvent)) != null ? _a : /* @__PURE__ */ new Map();
  }
  getAndRemoveStableEventHandler(internalEvent, fn) {
    const cacheByEventName = this.getEmitterListenersMapByInternalEventName(internalEvent);
    if (fn && cacheByEventName.has(fn)) {
      const handler = cacheByEventName.get(fn);
      cacheByEventName.delete(fn);
      this._emitterListenersCache.set(internalEvent, cacheByEventName);
      return handler;
    }
    return fn;
  }
  _createStableEventHandler(internalEvent, fn) {
    const wrapperHandler = (payload) => {
      const transform = this._emitterTransforms.get(internalEvent);
      this.logger.trace("Got emitterTransform for", internalEvent, transform);
      if (!transform) {
        return fn(payload);
      }
      const cachedInstance = this.runAndCacheEventHandlerTransform({
        internalEvent,
        transform,
        payload
      });
      let proxiedObj;
      const transformedPayload = this._parseNestedFields(payload, transform);
      proxiedObj = proxyFactory({
        instance: cachedInstance,
        payload,
        transformedPayload,
        transform
      });
      return fn(proxiedObj);
    };
    return wrapperHandler;
  }
  _parseNestedFields(obj, transform, process2 = (p) => p, result = void 0) {
    if (!transform.nestedFieldsToProcess) {
      return transform.payloadTransform(obj);
    }
    if (obj.__sw_proxy) {
      return obj;
    }
    if (!result) {
      const r = transform.payloadTransform(obj);
      return this._parseNestedFields(r, transform, process2, r);
    }
    if (Array.isArray(obj)) {
      result = obj.map((item, index) => {
        return this._parseNestedFields(process2(item), transform, process2, obj[index]);
      });
    } else if (obj && typeof obj === "object") {
      Object.entries(obj).forEach(([key, value]) => {
        var _a;
        const nestedTransform = (_a = transform.nestedFieldsToProcess) == null ? void 0 : _a[key];
        const transformToUse = nestedTransform ? this._emitterTransforms.get(nestedTransform.eventTransformType) : void 0;
        if (value && typeof value === "object") {
          result[key] = this._parseNestedFields(value, transform, (p) => {
            if (nestedTransform && transformToUse && p && typeof p === "object") {
              return instanceProxyFactory({
                transform: transformToUse,
                payload: process2(nestedTransform.processInstancePayload(p))
              });
            }
            return p;
          }, result[key]);
        } else {
          result[key] = process2(value);
        }
      });
    }
    return result;
  }
  getOrCreateStableEventHandler(internalEvent, fn) {
    const cacheByEventName = this.getEmitterListenersMapByInternalEventName(internalEvent);
    let handler = cacheByEventName.get(fn);
    if (!handler) {
      handler = this._createStableEventHandler(internalEvent, fn);
      cacheByEventName.set(fn, handler);
      this._emitterListenersCache.set(internalEvent, cacheByEventName);
    }
    return handler;
  }
  _trackEvent(internalEvent) {
    this._trackedEvents = Array.from(new Set(this._trackedEvents.concat(internalEvent)));
  }
  _untrackEvent(internalEvent) {
    this._trackedEvents = this._trackedEvents.filter((evt) => evt !== internalEvent);
  }
  _addListener(event, fn, once) {
    this._handleCompoundEvents(event);
    const internalEvent = this._getInternalEvent(event);
    this._trackEvent(internalEvent);
    const type = once ? "once" : "on";
    if (this.shouldAddToQueue()) {
      this.addEventToRegisterQueue({
        type,
        params: [event, fn]
      });
      return this.emitter;
    }
    const wrappedHandler = this.getOrCreateStableEventHandler(internalEvent, fn);
    this.logger.trace("Registering event", internalEvent);
    return this.emitter[type](internalEvent, wrappedHandler);
  }
  on(event, fn) {
    return this._addListener(event, fn);
  }
  once(event, fn) {
    return this._addListener(event, fn, true);
  }
  off(event, fn) {
    if (this.shouldAddToQueue()) {
      this.addEventToRegisterQueue({
        type: "off",
        params: [event, fn]
      });
      return this.emitter;
    }
    const internalEvent = this._getInternalEvent(event);
    const handler = this.getAndRemoveStableEventHandler(internalEvent, fn);
    this.cleanupEventHandlerTransformCache({
      internalEvent,
      force: !handler
    });
    this.logger.trace("Removing event listener", internalEvent);
    this._untrackEvent(internalEvent);
    return this.emitter.off(internalEvent, handler);
  }
  removeAllListeners(event) {
    if (this.shouldAddToQueue()) {
      this.addEventToRegisterQueue({
        type: "removeAllListeners",
        params: [event]
      });
      return this.emitter;
    }
    if (event) {
      return this.off(event);
    }
    this.eventNames().forEach((eventName) => {
      this.off(eventName);
    });
    return this.emitter;
  }
  eventNames() {
    return this._trackedEvents;
  }
  getSubscriptions() {
    return validateEventsToSubscribe(this.eventNames());
  }
  emit(event, ...args) {
    if (this.shouldAddToQueue()) {
      this._addEventToEmitQueue(event, args);
      return false;
    }
    const internalEvent = this._getInternalEvent(event);
    this.logger.trace("Emit on event:", internalEvent);
    return this.emitter.emit(internalEvent, ...args);
  }
  listenerCount(event) {
    return this.emitter.listenerCount(event);
  }
  destroy() {
    var _a;
    (_a = this._destroyer) == null ? void 0 : _a.call(this);
    this.removeAllListeners();
    this.detachWorkers();
  }
  execute({ method, params }, {
    transformParams = identity,
    transformResolve = identity,
    transformReject = identity
  } = {
    transformParams: identity,
    transformResolve: identity,
    transformReject: identity
  }) {
    return new Promise((resolve, reject) => {
      const requestId = (0, import_uuid.v4)();
      this._requests.set(requestId, {
        resolve,
        reject,
        transformResolve,
        transformReject
      });
      this.store.dispatch(executeAction({
        requestId,
        componentId: this.__uuid,
        method,
        params: transformParams(params)
      }));
    });
  }
  triggerCustomSaga(action) {
    return new Promise((resolve, reject) => {
      const dispatchId = (0, import_uuid.v4)();
      this._customSagaTriggers.set(dispatchId, { resolve, reject });
      this.store.dispatch(__spreadValues({
        dispatchId
      }, makeCustomSagaAction(this.__uuid, action)));
    });
  }
  settleCustomSagaTrigger({
    dispatchId,
    payload,
    kind
  }) {
    const actions = this._customSagaTriggers.get(dispatchId);
    if (actions) {
      actions[kind](payload);
      this._customSagaTriggers.delete(dispatchId);
    }
  }
  select(selectorFn) {
    return selectorFn(this.store.getState());
  }
  onError(component) {
    this._requests.forEach((value, key) => {
      if ((component == null ? void 0 : component.errors[key]) !== void 0) {
        value.reject(value.transformReject(component.errors[key]));
        this._requests.delete(key);
      }
    });
  }
  onSuccess(component) {
    this._requests.forEach((value, key) => {
      if ((component == null ? void 0 : component.responses[key]) !== void 0) {
        value.resolve(value.transformResolve(component.responses[key]));
        this._requests.delete(key);
      }
    });
  }
  getStateProperty(param) {
    return this[param];
  }
  flushEventsRegisterQueue() {
    this._eventsRegisterQueue.forEach((item) => {
      this[item.type](...item.params);
      this._eventsRegisterQueue.delete(item);
    });
  }
  flushEventsEmitQueue() {
    this._eventsEmitQueue.forEach((item) => {
      const { event, args } = item;
      this.emit(event, ...args);
      this._eventsEmitQueue.delete(item);
    });
  }
  flushEventsQueue() {
    this.flushEventsRegisterQueue();
    this.flushEventsEmitQueue();
  }
  _attachListeners(namespace) {
    if (typeof namespace === "string") {
      this._eventsNamespace = namespace;
    }
    this.flushEventsQueue();
  }
  getCompoundEvents() {
    return /* @__PURE__ */ new Map();
  }
  getEmitterTransforms() {
    return /* @__PURE__ */ new Map();
  }
  get _sessionAuthStatus() {
    return getAuthStatus(this.store.getState());
  }
  get _sessionAuthState() {
    return getAuthState(this.store.getState());
  }
  _waitUntilSessionAuthorized() {
    const authStatus = getAuthStatus(this.store.getState());
    switch (authStatus) {
      case "authorized":
        return Promise.resolve(this);
      case "unknown":
      case "authorizing":
        return new Promise((resolve, reject) => {
          const unsubscribe = this.store.subscribe(() => {
            const authStatus2 = getAuthStatus(this.store.getState());
            const authError = getAuthError(this.store.getState());
            if (authStatus2 === "authorized") {
              resolve(this);
              unsubscribe();
            } else if (authStatus2 === "unauthorized") {
              const error = authError ? new AuthError(authError.code, authError.message) : new Error("Unauthorized");
              reject(error);
              unsubscribe();
            }
          });
        });
      case "unauthorized":
        return Promise.reject(new Error("Unauthorized"));
    }
  }
  _setEmitterTransform({
    event,
    handler,
    local
  }) {
    const internalEvent = this._getInternalEvent(event);
    if (local ? !isLocalEvent(event) : isLocalEvent(event) || !this.eventNames().includes(internalEvent)) {
      return;
    }
    this._emitterTransforms.set(internalEvent, handler);
  }
  applyEmitterTransforms({ local = false } = { local: false }) {
    this.getEmitterTransforms().forEach((handlersObj, key) => {
      if (Array.isArray(key)) {
        key.forEach((k) => {
          this._setEmitterTransform({
            event: k,
            handler: handlersObj,
            local
          });
        });
      } else {
        this._setEmitterTransform({
          event: key,
          handler: handlersObj,
          local
        });
      }
      this._emitterTransforms.set(handlersObj.type, handlersObj);
    });
  }
  runWorker(name, def) {
    if (this._workers.has(name)) {
      getLogger().warn(`[runWorker] Worker with name ${name} has already been registerd.`);
    } else {
      this._setWorker(name, def);
    }
    this._attachWorker(name, def);
  }
  _setWorker(name, def) {
    this._workers.set(name, def);
  }
  _attachWorker(name, _a) {
    var _b = _a, { worker } = _b, params = __objRest(_b, ["worker"]);
    const task = this.store.runSaga(worker, __spreadValues({
      instance: this,
      runSaga: this.store.runSaga
    }, params));
    this._runningWorkers.push(task);
    this._workers.delete(name);
  }
  detachWorkers() {
    this._runningWorkers.forEach((task) => {
      task.cancel();
    });
    this._runningWorkers = [];
  }
};

// src/BaseClient.ts
var BaseClient = class extends BaseComponent {
  constructor(options) {
    super(options);
    this.options = options;
    this._attachListeners("");
  }
  connect() {
    const authStatus = getAuthStatus(this.store.getState());
    if (authStatus === "unknown" || authStatus === "unauthorized") {
      this.store.dispatch(initAction());
    }
    return this._waitUntilSessionAuthorized();
  }
  disconnect() {
    this.store.dispatch(destroyAction());
  }
};

// src/BaseConsumer.ts
var BaseConsumer = class extends BaseComponent {
  constructor(options) {
    super(options);
    this.options = options;
    __publicField(this, "subscribeMethod", "signalwire.subscribe");
    __publicField(this, "subscribeParams", {});
    __publicField(this, "_latestExecuteParams");
    this.applyEmitterTransforms({ local: true });
    const resetLatestExecuteParams = () => {
      this._latestExecuteParams = void 0;
    };
    super.on("session.connected", resetLatestExecuteParams);
    super.on("session.disconnected", resetLatestExecuteParams);
    super.on("session.reconnecting", resetLatestExecuteParams);
  }
  shouldExecuteSubscribe(execParams) {
    return !this._latestExecuteParams || JSON.stringify(execParams) !== JSON.stringify(this._latestExecuteParams);
  }
  subscribe() {
    return __async(this, null, function* () {
      yield this._waitUntilSessionAuthorized();
      const subscriptions = this.getSubscriptions();
      if (subscriptions.length === 0) {
        this.logger.debug("`subscribe()` was called without any listeners attached.");
        return;
      }
      const execParams = {
        method: this.subscribeMethod,
        params: __spreadProps(__spreadValues({}, this.subscribeParams), {
          event_channel: this.getStateProperty("eventChannel"),
          events: subscriptions
        })
      };
      if (!this.shouldExecuteSubscribe(execParams)) {
        this.logger.debug("BaseConsumer.subscribe() - Skipped .execute() since the execParams are exactly the same as last time");
        return;
      }
      this._latestExecuteParams = execParams;
      return new Promise((resolve, reject) => __async(this, null, function* () {
        try {
          this.applyEmitterTransforms();
          yield this.execute(execParams);
          return resolve(void 0);
        } catch (error) {
          return reject(error);
        }
      }));
    });
  }
};

// src/utils/EventEmitter.ts
var import_eventemitter3 = __toESM(require("eventemitter3"));
var getEventEmitter = () => {
  return new import_eventemitter3.default();
};

// src/types/videoMember.ts
var INTERNAL_MEMBER_UPDATABLE_PROPS = {
  audio_muted: true,
  video_muted: true,
  deaf: true,
  visible: true,
  input_volume: 1,
  output_volume: 1,
  input_sensitivity: 1
};
var INTERNAL_MEMBER_UPDATED_EVENTS = Object.keys(INTERNAL_MEMBER_UPDATABLE_PROPS).map((key) => {
  return `${PRODUCT_PREFIX_VIDEO}.member.updated.${key}`;
});
var MEMBER_UPDATABLE_PROPS = toExternalJSON(INTERNAL_MEMBER_UPDATABLE_PROPS);
var MEMBER_UPDATED_EVENTS = Object.keys(MEMBER_UPDATABLE_PROPS).map((key) => {
  return `member.updated.${key}`;
});

// src/index.ts
var sagaEffects = __toESM(require("@redux-saga/core/effects"));

// src/rooms/index.ts
var rooms_exports = {};
__export(rooms_exports, {
  RoomSessionPlaybackAPI: () => RoomSessionPlaybackAPI,
  RoomSessionRecordingAPI: () => RoomSessionRecordingAPI,
  RoomSessionStreamAPI: () => RoomSessionStreamAPI,
  audioMuteMember: () => audioMuteMember,
  audioUnmuteMember: () => audioUnmuteMember,
  createRoomSessionPlaybackObject: () => createRoomSessionPlaybackObject,
  createRoomSessionRecordingObject: () => createRoomSessionRecordingObject,
  createRoomSessionStreamObject: () => createRoomSessionStreamObject,
  deafMember: () => deafMember,
  deleteMemberMeta: () => deleteMemberMeta,
  deleteMeta: () => deleteMeta,
  demote: () => demote,
  getLayouts: () => getLayouts,
  getMemberMeta: () => getMemberMeta,
  getMembers: () => getMembers,
  getMeta: () => getMeta,
  getPlaybacks: () => getPlaybacks,
  getRecordings: () => getRecordings,
  getStreams: () => getStreams,
  hideVideoMuted: () => hideVideoMuted,
  play: () => play,
  promote: () => promote,
  removeAllMembers: () => removeAllMembers,
  removeMember: () => removeMember,
  setDeaf: () => setDeaf,
  setHideVideoMuted: () => setHideVideoMuted,
  setInputSensitivityMember: () => setInputSensitivityMember,
  setInputVolumeMember: () => setInputVolumeMember,
  setLayout: () => setLayout,
  setMemberMeta: () => setMemberMeta,
  setMemberPosition: () => setMemberPosition,
  setMeta: () => setMeta,
  setOutputVolumeMember: () => setOutputVolumeMember,
  setPositions: () => setPositions,
  showVideoMuted: () => showVideoMuted,
  startRecording: () => startRecording,
  startStream: () => startStream,
  undeafMember: () => undeafMember,
  updateMemberMeta: () => updateMemberMeta,
  updateMeta: () => updateMeta,
  videoMuteMember: () => videoMuteMember,
  videoUnmuteMember: () => videoUnmuteMember
});

// src/rooms/methods.ts
var baseCodeTransform = () => {
};
var createRoomMethod = (method, options = {}) => ({
  value: function(params = {}) {
    return this.execute({
      method,
      params: __spreadValues({
        room_session_id: this.roomSessionId
      }, params)
    }, options);
  }
});
var createRoomMemberMethod = (method, options = {}) => ({
  value: function(_a = {}) {
    var _b = _a, { memberId } = _b, rest = __objRest(_b, ["memberId"]);
    return this.execute({
      method,
      params: __spreadValues({
        room_session_id: this.roomSessionId,
        member_id: memberId || this.memberId
      }, rest)
    }, options);
  }
});
var getLayouts = createRoomMethod("video.list_available_layouts", {
  transformResolve: (payload) => ({ layouts: payload.layouts })
});
var getMembers = createRoomMethod("video.members.get", {
  transformResolve: (payload) => ({ members: payload.members })
});
var setLayout = createRoomMethod("video.set_layout", {
  transformResolve: baseCodeTransform
});
var setPositions = createRoomMethod("video.set_position", {
  transformResolve: baseCodeTransform
});
var hideVideoMuted = createRoomMethod("video.hide_video_muted", {
  transformResolve: baseCodeTransform
});
var showVideoMuted = createRoomMethod("video.show_video_muted", {
  transformResolve: baseCodeTransform
});
var setHideVideoMuted = {
  value: function(value) {
    return this.execute({
      method: value ? "video.hide_video_muted" : "video.show_video_muted",
      params: {
        room_session_id: this.roomSessionId
      }
    }, {
      transformResolve: baseCodeTransform
    });
  }
};
var getRecordings = {
  value: function() {
    return new Promise((resolve) => __async(this, null, function* () {
      const handler = (instance) => {
        resolve(instance);
      };
      this.on(toLocalEvent("video.recording.list"), handler);
      try {
        const payload = yield this.execute({
          method: "video.recording.list",
          params: {
            room_session_id: this.roomSessionId
          }
        });
        this.emit(toLocalEvent("video.recording.list"), __spreadProps(__spreadValues({}, payload), {
          room_session_id: this.roomSessionId
        }));
      } catch (error) {
        this.off(toLocalEvent("video.recording.list"), handler);
        throw error;
      }
    }));
  }
};
var startRecording = {
  value: function() {
    return new Promise((resolve) => __async(this, null, function* () {
      const handler = (instance) => {
        resolve(instance);
      };
      this.on(toLocalEvent("video.recording.start"), handler);
      try {
        const payload = yield this.execute({
          method: "video.recording.start",
          params: {
            room_session_id: this.roomSessionId
          }
        });
        this.emit(toLocalEvent("video.recording.start"), __spreadProps(__spreadValues({}, payload), {
          room_session_id: this.roomSessionId
        }));
      } catch (error) {
        this.off(toLocalEvent("video.recording.start"), handler);
        throw error;
      }
    }));
  }
};
var getPlaybacks = {
  value: function() {
    return new Promise((resolve) => __async(this, null, function* () {
      const handler = (instance) => {
        resolve(instance);
      };
      this.on(toLocalEvent("video.playback.list"), handler);
      try {
        const payload = yield this.execute({
          method: "video.playback.list",
          params: {
            room_session_id: this.roomSessionId
          }
        });
        this.emit(toLocalEvent("video.playback.list"), __spreadProps(__spreadValues({}, payload), {
          room_session_id: this.roomSessionId
        }));
      } catch (error) {
        this.off(toLocalEvent("video.playback.list"), handler);
        throw error;
      }
    }));
  }
};
var play = {
  value: function(params) {
    return new Promise((resolve) => __async(this, null, function* () {
      const handler = (instance) => {
        resolve(instance);
      };
      this.on(toLocalEvent("video.playback.start"), handler);
      try {
        const payload = yield this.execute({
          method: "video.playback.start",
          params: __spreadValues({
            room_session_id: this.roomSessionId
          }, params)
        });
        this.emit(toLocalEvent("video.playback.start"), __spreadProps(__spreadValues({}, payload), {
          room_session_id: this.roomSessionId
        }));
      } catch (error) {
        this.off(toLocalEvent("video.playback.start"), handler);
        throw error;
      }
    }));
  }
};
var createRoomMetaMethod = (method) => {
  return createRoomMethod(method, {
    transformResolve: baseCodeTransform,
    transformParams: (params) => {
      const _a = params, { room_session_id } = _a, meta = __objRest(_a, ["room_session_id"]);
      return { room_session_id, meta };
    }
  });
};
var getMeta = createRoomMethod("video.get_meta", {
  transformResolve: ({ meta }) => ({ meta })
});
var setMeta = createRoomMetaMethod("video.set_meta");
var updateMeta = createRoomMetaMethod("video.update_meta");
var deleteMeta = {
  value: function(params) {
    return this.execute({
      method: "video.delete_meta",
      params: {
        room_session_id: this.roomSessionId,
        keys: params
      }
    });
  }
};
var getStreams = {
  value: function() {
    return new Promise((resolve) => __async(this, null, function* () {
      const handler = (instance) => {
        resolve(instance);
      };
      this.on(toLocalEvent("video.stream.list"), handler);
      try {
        const payload = yield this.execute({
          method: "video.stream.list",
          params: {
            room_session_id: this.roomSessionId
          }
        });
        this.emit(toLocalEvent("video.stream.list"), __spreadProps(__spreadValues({}, payload), {
          room_session_id: this.roomSessionId
        }));
      } catch (error) {
        this.off(toLocalEvent("video.stream.list"), handler);
        throw error;
      }
    }));
  }
};
var startStream = {
  value: function(params) {
    return new Promise((resolve) => __async(this, null, function* () {
      const handler = (instance) => {
        resolve(instance);
      };
      this.on(toLocalEvent("video.stream.start"), handler);
      try {
        const payload = yield this.execute({
          method: "video.stream.start",
          params: __spreadValues({
            room_session_id: this.roomSessionId
          }, params)
        });
        this.emit(toLocalEvent("video.stream.start"), __spreadProps(__spreadValues({}, payload), {
          room_session_id: this.roomSessionId
        }));
      } catch (error) {
        this.off(toLocalEvent("video.stream.start"), handler);
        throw error;
      }
    }));
  }
};
var audioMuteMember = createRoomMemberMethod("video.member.audio_mute", {
  transformResolve: baseCodeTransform
});
var audioUnmuteMember = createRoomMemberMethod("video.member.audio_unmute", {
  transformResolve: baseCodeTransform
});
var videoMuteMember = createRoomMemberMethod("video.member.video_mute", {
  transformResolve: baseCodeTransform
});
var videoUnmuteMember = createRoomMemberMethod("video.member.video_unmute", {
  transformResolve: baseCodeTransform
});
var deafMember = createRoomMemberMethod("video.member.deaf", {
  transformResolve: baseCodeTransform
});
var undeafMember = createRoomMemberMethod("video.member.undeaf", {
  transformResolve: baseCodeTransform
});
var setDeaf = {
  value: function(value) {
    return this.execute({
      method: value ? "video.member.deaf" : "video.member.undeaf",
      params: {
        room_session_id: this.roomSessionId,
        member_id: this.memberId
      }
    }, {
      transformResolve: baseCodeTransform
    });
  }
};
var setInputVolumeMember = createRoomMemberMethod("video.member.set_input_volume", {
  transformResolve: baseCodeTransform
});
var setOutputVolumeMember = createRoomMemberMethod("video.member.set_output_volume", {
  transformResolve: baseCodeTransform
});
var setInputSensitivityMember = createRoomMemberMethod("video.member.set_input_sensitivity", {
  transformResolve: baseCodeTransform
});
var promote = {
  value: function(_a) {
    var _b = _a, {
      memberId,
      mediaAllowed,
      joinAudioMuted,
      joinVideoMuted
    } = _b, rest = __objRest(_b, [
      "memberId",
      "mediaAllowed",
      "joinAudioMuted",
      "joinVideoMuted"
    ]);
    return this.execute({
      method: "video.member.promote",
      params: __spreadValues({
        room_session_id: this.roomSessionId,
        member_id: memberId,
        media_allowed: mediaAllowed,
        join_audio_muted: joinAudioMuted,
        join_video_muted: joinVideoMuted
      }, rest)
    }, {
      transformResolve: baseCodeTransform
    });
  }
};
var demote = {
  value: function({ memberId, mediaAllowed }) {
    return this.execute({
      method: "video.member.demote",
      params: {
        room_session_id: this.roomSessionId,
        member_id: memberId,
        media_allowed: mediaAllowed
      }
    }, {
      transformResolve: baseCodeTransform
    });
  }
};
var setMemberPosition = createRoomMemberMethod("video.member.set_position", {
  transformResolve: baseCodeTransform
});
var removeMember = {
  value: function(_a) {
    var _b = _a, { memberId } = _b, rest = __objRest(_b, ["memberId"]);
    if (!memberId) {
      throw new TypeError('Invalid or missing "memberId" argument');
    }
    return this.execute({
      method: "video.member.remove",
      params: __spreadValues({
        room_session_id: this.roomSessionId,
        member_id: memberId
      }, rest)
    }, {
      transformResolve: baseCodeTransform
    });
  }
};
var removeAllMembers = {
  value: function() {
    return this.execute({
      method: "video.member.remove",
      params: {
        room_session_id: this.roomSessionId,
        member_id: "all"
      }
    }, {
      transformResolve: baseCodeTransform
    });
  }
};
var getMemberMeta = createRoomMemberMethod("video.member.get_meta", {
  transformResolve: ({ meta }) => ({ meta })
});
var setMemberMeta = createRoomMemberMethod("video.member.set_meta", {
  transformResolve: baseCodeTransform
});
var updateMemberMeta = createRoomMemberMethod("video.member.update_meta", {
  transformResolve: baseCodeTransform
});
var deleteMemberMeta = createRoomMemberMethod("video.member.delete_meta", {
  transformResolve: baseCodeTransform
});

// src/rooms/RoomSessionRecording.ts
var RoomSessionRecordingAPI = class extends BaseComponent {
  pause() {
    return __async(this, null, function* () {
      yield this.execute({
        method: "video.recording.pause",
        params: {
          room_session_id: this.getStateProperty("roomSessionId"),
          recording_id: this.getStateProperty("id")
        }
      });
    });
  }
  resume() {
    return __async(this, null, function* () {
      yield this.execute({
        method: "video.recording.resume",
        params: {
          room_session_id: this.getStateProperty("roomSessionId"),
          recording_id: this.getStateProperty("id")
        }
      });
    });
  }
  stop() {
    return __async(this, null, function* () {
      yield this.execute({
        method: "video.recording.stop",
        params: {
          room_session_id: this.getStateProperty("roomSessionId"),
          recording_id: this.getStateProperty("id")
        }
      });
    });
  }
};
var createRoomSessionRecordingObject = (params) => {
  const recording = connect({
    store: params.store,
    Component: RoomSessionRecordingAPI,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(params);
  return recording;
};

// src/rooms/RoomSessionPlayback.ts
var RoomSessionPlaybackAPI = class extends BaseComponent {
  pause() {
    return __async(this, null, function* () {
      yield this.execute({
        method: "video.playback.pause",
        params: {
          room_session_id: this.getStateProperty("roomSessionId"),
          playback_id: this.getStateProperty("id")
        }
      });
    });
  }
  resume() {
    return __async(this, null, function* () {
      yield this.execute({
        method: "video.playback.resume",
        params: {
          room_session_id: this.getStateProperty("roomSessionId"),
          playback_id: this.getStateProperty("id")
        }
      });
    });
  }
  stop() {
    return __async(this, null, function* () {
      yield this.execute({
        method: "video.playback.stop",
        params: {
          room_session_id: this.getStateProperty("roomSessionId"),
          playback_id: this.getStateProperty("id")
        }
      });
    });
  }
  setVolume(volume) {
    return __async(this, null, function* () {
      yield this.execute({
        method: "video.playback.set_volume",
        params: {
          room_session_id: this.getStateProperty("roomSessionId"),
          playback_id: this.getStateProperty("id"),
          volume
        }
      });
    });
  }
  seek(timecode) {
    return __async(this, null, function* () {
      yield this.execute({
        method: "video.playback.seek_absolute",
        params: {
          room_session_id: this.getStateProperty("roomSessionId"),
          playback_id: this.getStateProperty("id"),
          position: Math.abs(timecode)
        }
      });
    });
  }
  forward(offset = 5e3) {
    return __async(this, null, function* () {
      yield this.execute({
        method: "video.playback.seek_relative",
        params: {
          room_session_id: this.getStateProperty("roomSessionId"),
          playback_id: this.getStateProperty("id"),
          position: Math.abs(offset)
        }
      });
    });
  }
  rewind(offset = 5e3) {
    return __async(this, null, function* () {
      yield this.execute({
        method: "video.playback.seek_relative",
        params: {
          room_session_id: this.getStateProperty("roomSessionId"),
          playback_id: this.getStateProperty("id"),
          position: -Math.abs(offset)
        }
      });
    });
  }
};
var createRoomSessionPlaybackObject = (params) => {
  const playback = connect({
    store: params.store,
    Component: RoomSessionPlaybackAPI,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(params);
  return playback;
};

// src/rooms/RoomSessionStream.ts
var RoomSessionStreamAPI = class extends BaseComponent {
  stop() {
    return __async(this, null, function* () {
      yield this.execute({
        method: "video.stream.stop",
        params: {
          room_session_id: this.getStateProperty("roomSessionId"),
          stream_id: this.getStateProperty("id")
        }
      });
    });
  }
};
var createRoomSessionStreamObject = (params) => {
  const stream = connect({
    store: params.store,
    Component: RoomSessionStreamAPI,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(params);
  return stream;
};

// src/chat/index.ts
var chat_exports = {};
__export(chat_exports, {
  BaseChatAPI: () => BaseChatAPI,
  BaseChatConsumer: () => BaseChatConsumer,
  ChatMember: () => ChatMember,
  ChatMessage: () => ChatMessage,
  createBaseChatObject: () => createBaseChatObject,
  getMemberState: () => getMemberState,
  getMembers: () => getMembers2,
  getMessages: () => getMessages,
  publish: () => publish,
  setMemberState: () => setMemberState
});

// src/chat/utils/toInternalChatChannels.ts
var toInternalChatChannels = (channels) => {
  const list = !channels || Array.isArray(channels) ? channels : [channels];
  if (Array.isArray(list)) {
    return list.map((name) => {
      return {
        name
      };
    });
  }
  return [];
};

// src/chat/utils/index.ts
var isValidChannels = (input) => {
  return Array.isArray(input) || typeof input === "string";
};

// src/chat/methods.ts
var baseCodeTransform2 = () => {
};
var createChatMethod = (method, options = {}) => ({
  value: function(params = {}) {
    return this.execute({
      method,
      params
    }, options);
  }
});
var createChatMemberMethod = (method, options = {}) => ({
  value: function(_a = {}) {
    var _b = _a, { memberId } = _b, rest = __objRest(_b, ["memberId"]);
    return this.execute({
      method,
      params: __spreadValues({
        member_id: memberId
      }, rest)
    }, options);
  }
});
var publish = createChatMethod("chat.publish", {
  transformResolve: baseCodeTransform2
});
var getMessages = createChatMethod("chat.messages.get", {
  transformResolve: (payload) => ({
    messages: payload.messages.map((message) => toExternalJSON(message)),
    cursor: payload.cursor
  })
});
var getMembers2 = createChatMethod("chat.members.get", {
  transformResolve: (payload) => ({
    members: payload.members.map((member) => toExternalJSON(member))
  })
});
var transformParamChannels = (params) => {
  const channels = isValidChannels(params == null ? void 0 : params.channels) ? toInternalChatChannels(params.channels) : void 0;
  return __spreadProps(__spreadValues({}, params), {
    channels
  });
};
var setMemberState = createChatMemberMethod("chat.member.set_state", {
  transformResolve: baseCodeTransform2,
  transformParams: transformParamChannels
});
var getMemberState = createChatMemberMethod("chat.member.get_state", {
  transformResolve: (payload) => ({ channels: payload.channels }),
  transformParams: transformParamChannels
});

// src/pubSub/index.ts
var pubSub_exports = {};
__export(pubSub_exports, {
  BasePubSubConsumer: () => BasePubSubConsumer,
  PubSubMessage: () => PubSubMessage,
  createBasePubSubObject: () => createBasePubSubObject
});

// src/pubSub/PubSubMessage.ts
var PubSubMessage = class {
  constructor(payload) {
    this.payload = payload;
  }
  get id() {
    return this.payload.id;
  }
  get channel() {
    return this.payload.channel;
  }
  get content() {
    return this.payload.content;
  }
  get meta() {
    return this.payload.meta;
  }
  get publishedAt() {
    return this.payload.publishedAt;
  }
};

// src/pubSub/workers.ts
var pubSubWorker = function* pubSubWorker2({ channels: { pubSubChannel } }) {
  while (true) {
    const action = yield sagaEffects.take((action2) => {
      return action2.type.startsWith(`${PRODUCT_PREFIX_PUBSUB}.`);
    });
    switch (action.type) {
      case `${PRODUCT_PREFIX_PUBSUB}.channel.message`: {
        yield sagaEffects.put(pubSubChannel, {
          type: `${PRODUCT_PREFIX_PUBSUB}.message`,
          payload: action.payload
        });
        break;
      }
      default: {
        getLogger().debug("[pubSubWorker] Unrecognized Action", action);
        break;
      }
    }
  }
};

// src/pubSub/BasePubSub.ts
var toInternalPubSubChannels = (channels) => {
  return channels.map((name) => {
    return {
      name
    };
  });
};
var BasePubSubConsumer = class extends BaseConsumer {
  constructor(options) {
    super(options);
    __publicField(this, "_eventsPrefix", PRODUCT_PREFIX_PUBSUB);
    __publicField(this, "subscribeMethod", `${PRODUCT_PREFIX_PUBSUB}.subscribe`);
    this._attachListeners("");
    this.runWorker("pubSub", { worker: pubSubWorker });
  }
  getEmitterTransforms() {
    return /* @__PURE__ */ new Map([
      [
        ["message"],
        {
          type: "pubSubMessage",
          instanceFactory: () => {
            return new PubSubMessage({});
          },
          payloadTransform: (payload) => {
            const {
              channel,
              message: _a
            } = payload.params, _b = _a, { member } = _b, restMessage = __objRest(_b, ["member"]);
            return toExternalJSON(__spreadProps(__spreadValues({}, restMessage), {
              channel
            }));
          }
        }
      ]
    ]);
  }
  _getChannelsParam(channels, method) {
    const _channels = !channels || Array.isArray(channels) ? channels : [channels];
    if (!Array.isArray(_channels) || _channels.length === 0) {
      throw new Error(`Please specify one or more channels when calling .${method}()`);
    }
    return {
      channels: toInternalPubSubChannels(_channels)
    };
  }
  _setSubscribeParams(params) {
    this.subscribeParams = __spreadValues(__spreadValues({}, this.subscribeParams), params);
  }
  _getSubscribeParams({ channels }) {
    return __spreadValues({}, this._getChannelsParam(channels, "subscribe"));
  }
  _getUnsubscribeParams({ channels }) {
    const channelsParam = this._getChannelsParam(channels, "unsubscribe");
    return __spreadValues({}, channelsParam);
  }
  _checkMissingSubscriptions() {
    const subscriptions = this.getSubscriptions();
    if (subscriptions.length === 0) {
      this.logger.info("Subscribe was called before any listeners were attached. Move `.subscribe()` right after your event listeners to suppress this message.");
      this.once("message", () => {
      });
    }
  }
  subscribe(channels) {
    return __async(this, null, function* () {
      this._checkMissingSubscriptions();
      const params = this._getSubscribeParams({ channels });
      this._setSubscribeParams(params);
      return __superGet(BasePubSubConsumer.prototype, this, "subscribe").call(this);
    });
  }
  unsubscribe(channels) {
    return __async(this, null, function* () {
      if (this._sessionAuthStatus === "unknown" || this._sessionAuthStatus === "unauthorized") {
        throw new Error("You must be authenticated to unsubscribe from a channel");
      }
      const params = this._getUnsubscribeParams({ channels });
      return new Promise((resolve, reject) => __async(this, null, function* () {
        const subscriptions = this.getSubscriptions();
        if (subscriptions.length > 0) {
          const execParams = {
            method: `${PRODUCT_PREFIX_PUBSUB}.unsubscribe`,
            params: __spreadProps(__spreadValues({}, params), {
              events: subscriptions
            })
          };
          try {
            yield this.execute(execParams);
          } catch (error) {
            return reject(error);
          }
        } else {
          this.logger.warn("`unsubscribe()` was called without any listeners attached.");
        }
        return resolve();
      }));
    });
  }
  updateToken(token) {
    return new Promise((resolve, reject) => {
      this.once("session.auth_error", (error) => {
        reject(error);
      });
      this.once("session.connected", () => {
        resolve();
      });
      this.store.dispatch(actions_exports.reauthAction({ token }));
    });
  }
  publish(params) {
    return this.execute({
      method: `${PRODUCT_PREFIX_PUBSUB}.publish`,
      params
    });
  }
  getAllowedChannels() {
    return __async(this, null, function* () {
      yield this._waitUntilSessionAuthorized();
      const authState = this.select(getAuthState);
      if (authState && "channels" in authState && authState.channels) {
        return authState.channels;
      }
      return {};
    });
  }
};
var createBasePubSubObject = (params) => {
  const pubSub = connect({
    store: params.store,
    Component: BasePubSubConsumer,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(params);
  return pubSub;
};

// src/chat/ChatMember.ts
var ChatMember = class {
  constructor(payload) {
    this.payload = payload;
  }
  get id() {
    return this.payload.id;
  }
  get channel() {
    return this.payload.channel;
  }
  get state() {
    var _a;
    return (_a = this.payload.state) != null ? _a : {};
  }
};

// src/chat/ChatMessage.ts
var ChatMessage = class extends PubSubMessage {
  get member() {
    return this.payload.member;
  }
};

// src/chat/workers.ts
var chatWorker = function* chatWorker2({
  channels: { pubSubChannel }
}) {
  while (true) {
    const action = yield sagaEffects.take((action2) => {
      return action2.type.startsWith("chat.");
    });
    switch (action.type) {
      case "chat.channel.message": {
        if (PRODUCT_PREFIX_CHAT === PRODUCT_PREFIX_PUBSUB) {
          break;
        }
        yield sagaEffects.put(pubSubChannel, {
          type: "chat.message",
          payload: action.payload
        });
        break;
      }
      case "chat.member.joined":
      case "chat.member.updated":
      case "chat.member.left":
        yield sagaEffects.put(pubSubChannel, action);
        break;
      default: {
        getLogger().debug("[chatWorker] Unrecognized Action", action);
        break;
      }
    }
  }
};

// src/chat/BaseChat.ts
var BaseChatConsumer = class extends BasePubSubConsumer {
  constructor(options) {
    super(options);
    __publicField(this, "_eventsPrefix", PRODUCT_PREFIX_CHAT);
    __publicField(this, "subscribeMethod", `${PRODUCT_PREFIX_CHAT}.subscribe`);
    this.runWorker("chat", { worker: chatWorker });
  }
  getEmitterTransforms() {
    return /* @__PURE__ */ new Map([
      [
        ["message"],
        {
          type: "chatMessage",
          instanceFactory: () => {
            return new ChatMessage({});
          },
          payloadTransform: (payload) => {
            const { channel, message } = payload.params;
            return toExternalJSON(__spreadProps(__spreadValues({}, message), {
              channel
            }));
          }
        }
      ],
      [
        ["member.joined", "member.left", "member.updated"],
        {
          type: "chatMember",
          instanceFactory: (payload) => {
            const { member } = payload.params;
            return new ChatMember(toExternalJSON(member));
          },
          payloadTransform: (payload) => {
            const { member } = payload.params;
            return toExternalJSON(member);
          }
        }
      ]
    ]);
  }
};
var BaseChatAPI = extendComponent(BaseChatConsumer, {
  publish,
  getMembers: getMembers2,
  getMessages,
  setMemberState,
  getMemberState
});
var createBaseChatObject = (params) => {
  const chat = connect({
    store: params.store,
    Component: BaseChatAPI,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(params);
  return chat;
};

// src/memberPosition/index.ts
var memberPosition_exports = {};
__export(memberPosition_exports, {
  MEMBER_POSITION_COMPOUND_EVENTS: () => MEMBER_POSITION_COMPOUND_EVENTS,
  memberPositionWorker: () => memberPositionWorker,
  memberUpdatedWorker: () => memberUpdatedWorker
});

// src/memberPosition/workers.ts
var import_effects5 = require("@redux-saga/core/effects");
function* memberPositionLayoutChangedWorker(options) {
  const {
    action,
    memberList,
    channels: { pubSubChannel }
  } = options;
  const layers = action.payload.layout.layers;
  const processedMembers = {};
  layers.forEach((layer) => {
    var _a;
    const memberId = layer.member_id;
    if (!memberId) {
      return;
    }
    const memberEventParams = memberList.get(memberId);
    if (memberEventParams && layer.position !== ((_a = memberEventParams.member) == null ? void 0 : _a.current_position)) {
      mutateMemberCurrentPosition({
        memberList,
        memberId,
        currentPosition: layer.position
      });
      processedMembers[memberId] = true;
    } else {
      processedMembers[memberId] = false;
    }
  });
  for (const [memberId, payload] of memberList) {
    if (processedMembers[memberId]) {
      yield (0, import_effects5.put)(pubSubChannel, {
        type: "video.member.updated",
        payload
      });
    } else if (processedMembers[memberId] === void 0) {
      const updatedMemberEventParams = mutateMemberCurrentPosition({
        memberList,
        memberId,
        currentPosition: "off-canvas"
      });
      if (!updatedMemberEventParams) {
        return;
      }
      yield (0, import_effects5.put)(pubSubChannel, {
        type: "video.member.updated",
        payload: updatedMemberEventParams
      });
    }
  }
}
function* memberUpdatedWorker({
  action,
  channels,
  memberList
}) {
  var _a, _b;
  const memberId = action.payload.member.id;
  const updatedMemberEventParams = mutateMemberCurrentPosition({
    memberList,
    memberId,
    currentPosition: (_b = (_a = memberList.get(memberId)) == null ? void 0 : _a.member) == null ? void 0 : _b.current_position
  });
  if (!updatedMemberEventParams) {
    return;
  }
  const {
    member: { updated = [] }
  } = action.payload;
  const memberUpdatedPayload = __spreadProps(__spreadValues({}, updatedMemberEventParams), {
    member: __spreadValues(__spreadValues({}, updatedMemberEventParams.member), action.payload.member)
  });
  memberList.set(memberId, memberUpdatedPayload);
  for (const key of updated) {
    const type = `${action.type}.${key}`;
    yield (0, import_effects5.put)(channels.pubSubChannel, {
      type,
      payload: memberUpdatedPayload
    });
  }
  yield (0, import_effects5.put)(channels.pubSubChannel, {
    type: action.type,
    payload: memberUpdatedPayload
  });
}
var MEMBER_POSITION_COMPOUND_EVENTS = /* @__PURE__ */ new Map([
  [
    "video.member.updated",
    [
      "video.layout.changed",
      "video.member.joined",
      "video.member.left"
    ]
  ]
]);
var memberPositionWorker = function* memberPositionWorker2({
  instance,
  channels,
  initialState
}) {
  if (!initialState) {
    return;
  }
  const { swEventChannel } = channels;
  let memberList = initializeMemberList(initialState);
  const addToMemberList = (payload) => {
    if (!memberList.has(payload.member.id)) {
      memberList.set(payload.member.id, payload);
    }
  };
  while (true) {
    const action = yield sagaEffects.take(swEventChannel, (action2) => {
      const istargetEvent = action2.type === "video.member.updated" || action2.type === "video.layout.changed" || action2.type === "video.member.joined" || action2.type === "video.member.left";
      return istargetEvent && findNamespaceInPayload(action2) === instance._eventsNamespace;
    });
    switch (action.type) {
      case "video.member.updated": {
        addToMemberList(action.payload);
        yield (0, import_effects5.fork)(memberUpdatedWorker, {
          action,
          channels,
          memberList,
          instance
        });
        break;
      }
      case "video.member.joined": {
        addToMemberList(action.payload);
        break;
      }
      case "video.member.left": {
        const member = action.payload.member;
        memberList.delete(member.id);
        break;
      }
      case "video.layout.changed": {
        yield (0, import_effects5.fork)(memberPositionLayoutChangedWorker, {
          action,
          channels,
          memberList,
          instance
        });
        break;
      }
    }
  }
};
var mutateMemberCurrentPosition = ({
  memberList,
  memberId,
  currentPosition
}) => {
  const memberEventParams = memberList.get(memberId);
  if (!memberEventParams) {
    return;
  } else if (!currentPosition) {
    return memberEventParams;
  }
  const updatedMemberEventParams = __spreadProps(__spreadValues({}, memberEventParams), {
    member: __spreadProps(__spreadValues({}, memberEventParams == null ? void 0 : memberEventParams.member), {
      current_position: currentPosition
    })
  });
  memberList.set(memberId, updatedMemberEventParams);
  return updatedMemberEventParams;
};
var initializeMemberList = (payload) => {
  const members = payload.room_session.members;
  const memberList = /* @__PURE__ */ new Map();
  members.forEach((member) => {
    memberList.set(member.id, {
      room_id: payload.room_session.room_id,
      room_session_id: payload.room_session.id,
      member
    });
  });
  return memberList;
};

// src/testUtils.ts
var testUtils_exports = {};
__export(testUtils_exports, {
  configureFullStack: () => configureFullStack,
  configureJestStore: () => configureJestStore,
  createMockedLogger: () => createMockedLogger,
  createPubSubChannel: () => createPubSubChannel,
  createSwEventChannel: () => createSwEventChannel,
  rpcConnectResultVRT: () => rpcConnectResultVRT,
  wait: () => wait
});
var import_core4 = require("@redux-saga/core");
var PROJECT_ID = "8f0a119a-cda7-4497-a47d-c81493b824d4";
var TOKEN = "<VRT>";
var createMockedLogger = () => ({
  fatal: jest.fn(),
  error: jest.fn(),
  warn: jest.fn(),
  info: jest.fn(),
  debug: jest.fn(),
  trace: jest.fn(),
  wsTraffic: jest.fn()
});
var configureJestStore = (options) => {
  return configureStore2(__spreadValues({
    userOptions: {
      project: PROJECT_ID,
      token: TOKEN,
      devTools: false,
      emitter: new import_eventemitter3.default()
    },
    SessionConstructor: BaseSession,
    runSagaMiddleware: false
  }, options));
};
var configureFullStack = () => {
  const session = {
    dispatch: console.log,
    connect: jest.fn(),
    disconnect: jest.fn(),
    execute: jest.fn()
  };
  const emitter = new import_eventemitter3.default();
  const store = configureStore2({
    userOptions: {
      project: PROJECT_ID,
      token: TOKEN,
      devTools: false,
      emitter
    },
    SessionConstructor: jest.fn().mockImplementation(() => {
      return session;
    })
  });
  store.dispatch(actions_exports.initAction());
  store.dispatch(actions_exports.authSuccessAction());
  return {
    store,
    session,
    emitter,
    destroy: () => store.dispatch(actions_exports.destroyAction())
  };
};
var wait = (ms) => {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
};
var rpcConnectResultVRT = {
  identity: "f3bc99df-2c3d-4fa4-b1dc-e8a8ffc579e6@e3fefa44-1bad-4be9-ad9b-1cbb9abd60c7.west-us",
  authorization: {
    type: "video",
    project: "8f0a119a-cda7-4497-a47d-c81493b824d4",
    scopes: ["video"],
    scope_id: "26675883-8499-4ee9-85eb-691c4aa209f8",
    resource: "9c80f1e8-9430-4070-a043-937eb3a96b38",
    join_as: "member",
    user_name: "Joe",
    room: {
      name: "lobby",
      display_name: "Lobby",
      scopes: ["room.self.audio_mute", "room.self.audio_unmute"],
      meta: {}
    },
    signature: "SGZtkRD9fvuBAOUp1UF56zESxdEvGT6qSGZtkRD9fvuBAOUp1UF56zESxdEvGT6q",
    media_allowed: "all",
    audio_allowed: "both",
    video_allowed: "both",
    meta: {}
  },
  protocol: "signalwire_SGZtkRD9fvuBAOUp1UF56zESxdEvGT6qSGZtkRD9fvuBAOUp1UF56zESxdEvGT6q_03e8c927-8ea3-4661-86d5-778c3e03296a_8f0a119a-cda7-4497-a47d-c81493b824d4",
  ice_servers: [
    {
      urls: "turn.swire.io:443",
      credential: "sFTwvi8ShXcYNOcyYjFy3ATIUpQ=",
      credentialType: "password",
      username: "1619521908:8f0a119a-cda7-4497-a47d-c81493b824d4"
    }
  ]
};
var createPubSubChannel = () => (0, import_core4.multicastChannel)();
var createSwEventChannel = () => (0, import_core4.multicastChannel)();

// src/index.ts
var selectors = __spreadValues({}, sessionSelectors_exports);
//# sourceMappingURL=index.js.map
