{
  "version": 3,
  "sources": ["../src/utils/constants.ts", "../src/utils/logger.ts", "../src/utils/index.ts", "../src/utils/parseRPCResponse.ts", "../src/utils/toExternalJSON.ts", "../src/utils/common.ts", "../src/utils/toInternalEventName.ts", "../src/utils/toInternalAction.ts", "../src/utils/toSnakeCaseKeys.ts", "../src/utils/extendComponent.ts", "../src/utils/proxyUtils.ts", "../src/utils/eventTransformUtils.ts", "../src/utils/debounce.ts", "../src/RPCMessages/helpers.ts", "../src/RPCMessages/RPCConnect.ts", "../src/RPCMessages/RPCReauthenticate.ts", "../src/RPCMessages/RPCPing.ts", "../src/RPCMessages/RPCExecute.ts", "../src/RPCMessages/RPCDisconnect.ts", "../src/RPCMessages/VertoMessages.ts", "../src/redux/actions.ts", "../src/redux/toolkit/index.ts", "../src/redux/toolkit/createAction.ts", "../src/redux/toolkit/configureStore.ts", "../src/redux/toolkit/devtoolsExtension.ts", "../src/redux/toolkit/isPlainObject.ts", "../src/redux/toolkit/getDefaultMiddleware.ts", "../src/redux/toolkit/mapBuilders.ts", "../src/redux/toolkit/createReducer.ts", "../src/redux/toolkit/createSlice.ts", "../src/redux/utils/createDestroyableSlice.ts", "../src/redux/features/session/sessionSlice.ts", "../src/BaseSession.ts", "../src/BaseJWTSession.ts", "../src/redux/index.ts", "../src/redux/features/component/componentSlice.ts", "../src/redux/features/executeQueue/executeQueueSlice.ts", "../src/redux/rootReducer.ts", "../src/redux/rootSaga.ts", "../src/redux/features/session/sessionSaga.ts", "../src/redux/utils/sagaHelpers.ts", "../src/redux/features/pubSub/pubSubSaga.ts", "../src/redux/features/shared/namespace.ts", "../src/CustomErrors.ts", "../src/redux/features/component/componentSelectors.ts", "../src/redux/features/session/sessionSelectors.ts", "../src/redux/connect.ts", "../src/BaseComponent.ts", "../src/BaseClient.ts", "../src/BaseConsumer.ts", "../src/utils/EventEmitter.ts", "../src/types/videoMember.ts", "../src/index.ts", "../src/rooms/index.ts", "../src/rooms/methods.ts", "../src/rooms/RoomSessionRecording.ts", "../src/rooms/RoomSessionPlayback.ts", "../src/rooms/RoomSessionStream.ts", "../src/chat/index.ts", "../src/chat/utils/toInternalChatChannels.ts", "../src/chat/utils/index.ts", "../src/chat/methods.ts", "../src/pubSub/index.ts", "../src/pubSub/PubSubMessage.ts", "../src/pubSub/workers.ts", "../src/pubSub/BasePubSub.ts", "../src/chat/ChatMember.ts", "../src/chat/ChatMessage.ts", "../src/chat/workers.ts", "../src/chat/BaseChat.ts", "../src/memberPosition/index.ts", "../src/memberPosition/workers.ts", "../src/testUtils.ts"],
  "sourcesContent": ["export const STORAGE_PREFIX = '@signalwire:'\nexport const ADD = 'add'\nexport const REMOVE = 'remove'\nexport const SESSION_ID = 'sessId'\nexport const DEFAULT_HOST = 'wss://relay.signalwire.com'\n\nexport enum WebSocketState {\n  CONNECTING = 0,\n  OPEN = 1,\n  CLOSING = 2,\n  CLOSED = 3,\n}\n\n/**\n * Used for namespacing events.\n */\nexport const EVENT_NAMESPACE_DIVIDER = ':'\n\nexport const LOCAL_EVENT_PREFIX = '__local__'\nexport const SYNTHETIC_EVENT_PREFIX = '__synthetic__'\n\nexport const PRODUCT_PREFIX_VIDEO = 'video'\n/**\n * video-manager is an [internal] superset of the video apis\n */\nexport const PRODUCT_PREFIX_VIDEO_MANAGER = 'video-manager'\nexport const PRODUCT_PREFIX_CHAT = 'chat' as const\n/**\n * For now both, `PubSub` and `Chat` share the same\n * namespace but this might change in the future.\n */\nexport const PRODUCT_PREFIX_PUBSUB = 'chat' as const\nexport const PRODUCT_PREFIX_TASK = 'tasking'\nexport const PRODUCT_PREFIX_MESSAGING = 'messaging'\nexport const PRODUCT_PREFIX_VOICE = 'voice'\nexport const PRODUCT_PREFIX_VOICE_CALL = 'calling'\n\nexport const GLOBAL_VIDEO_EVENTS = ['room.started', 'room.ended'] as const\n\nexport const PRODUCT_PREFIXES = [\n  PRODUCT_PREFIX_VIDEO,\n  PRODUCT_PREFIX_VIDEO_MANAGER,\n  PRODUCT_PREFIX_CHAT,\n  PRODUCT_PREFIX_PUBSUB,\n  PRODUCT_PREFIX_TASK,\n  PRODUCT_PREFIX_MESSAGING,\n  PRODUCT_PREFIX_VOICE,\n  PRODUCT_PREFIX_VOICE_CALL,\n] as const\n\n/**\n * For internal usage only. These are the fully qualified event names\n * sent by the server\n * @internal\n */\nexport const INTERNAL_GLOBAL_VIDEO_EVENTS = GLOBAL_VIDEO_EVENTS.map(\n  (event) => `${PRODUCT_PREFIX_VIDEO}.${event}` as const\n)\n", "import log from 'loglevel'\nimport type {\n  SDKLogger,\n  InternalSDKLogger,\n  WsTrafficOptions,\n  UserOptions,\n} from '..'\n\nconst datetime = () => new Date().toISOString()\nconst defaultLogger = log.getLogger('signalwire')\n\nconst originalFactory = defaultLogger.methodFactory\ndefaultLogger.methodFactory = (methodName, logLevel, loggerName) => {\n  const rawMethod = originalFactory(methodName, logLevel, loggerName)\n\n  return function (...args: any[]) {\n    args.unshift(datetime(), '-')\n    rawMethod.apply(undefined, args)\n  }\n}\n\nconst defaultLoggerLevel =\n  // @ts-ignore\n  'development' === process.env.NODE_ENV\n    ? defaultLogger.levels.DEBUG\n    : defaultLogger.getLevel()\ndefaultLogger.setLevel(defaultLoggerLevel)\n\nlet userLogger: SDKLogger | null\nconst setLogger = (logger: SDKLogger | null) => {\n  userLogger = logger\n}\n\nlet debugOptions: UserOptions['debug'] = {}\nconst setDebugOptions = (options: any) => {\n  if (options == null) {\n    debugOptions = {}\n    return\n  }\n  Object.assign(debugOptions, options)\n}\n\nconst getLoggerInstance = (): SDKLogger => {\n  return userLogger ?? (defaultLogger as any as SDKLogger)\n}\n\nconst shouldStringify = (payload: WsTrafficOptions['payload']) => {\n  if ('method' in payload && payload.method === 'signalwire.ping') {\n    return false\n  }\n\n  return true\n}\n\nconst wsTraffic: InternalSDKLogger['wsTraffic'] = ({ type, payload }) => {\n  const logger = getLoggerInstance()\n  const { logWsTraffic } = debugOptions || {}\n\n  if (!logWsTraffic) {\n    return undefined\n  }\n\n  const msg = shouldStringify(payload)\n    ? JSON.stringify(payload, null, 2)\n    : payload\n\n  return logger.info(`${type.toUpperCase()}: \\n`, msg, '\\n')\n}\n\nconst getLogger = (): InternalSDKLogger => {\n  const logger = getLoggerInstance()\n\n  return new Proxy(logger, {\n    get(target, prop: keyof InternalSDKLogger, receiver) {\n      if (prop === 'wsTraffic') {\n        return wsTraffic\n      }\n\n      return Reflect.get(target, prop, receiver)\n    },\n  }) as InternalSDKLogger\n}\n\nexport { setLogger, getLogger, setDebugOptions }\n", "import { JSONRPCRequest, JSONRPCResponse } from '..'\nimport {\n  STORAGE_PREFIX,\n  GLOBAL_VIDEO_EVENTS,\n  INTERNAL_GLOBAL_VIDEO_EVENTS,\n  EVENT_NAMESPACE_DIVIDER,\n  LOCAL_EVENT_PREFIX,\n  SYNTHETIC_EVENT_PREFIX,\n} from './constants'\nexport { setLogger, getLogger, setDebugOptions } from './logger'\n\nexport { v4 as uuid } from 'uuid'\nexport * from './parseRPCResponse'\nexport * from './toExternalJSON'\nexport * from './toInternalEventName'\nexport * from './toInternalAction'\nexport * from './toSnakeCaseKeys'\nexport * from './extendComponent'\nexport * from './eventTransformUtils'\nexport * from './proxyUtils'\nexport * from './debounce'\n\nexport const mutateStorageKey = (key: string) => `${STORAGE_PREFIX}${key}`\n\nexport const safeParseJson = <T>(value: T): T | Object => {\n  if (typeof value !== 'string') {\n    return value\n  }\n  try {\n    return JSON.parse(value)\n  } catch (error) {\n    return value\n  }\n}\n\nconst PROTOCOL_PATTERN = /^(ws|wss):\\/\\//\nexport const checkWebSocketHost = (host: string): string => {\n  const protocol = PROTOCOL_PATTERN.test(host) ? '' : 'wss://'\n  return `${protocol}${host}`\n}\n\nexport const timeoutPromise = <T = unknown>(\n  promise: Promise<T>,\n  time: number,\n  exception: any\n) => {\n  let timer: any = null\n  return Promise.race<T>([\n    promise,\n    new Promise(\n      (_resolve, reject) => (timer = setTimeout(reject, time, exception))\n    ),\n  ]).finally(() => clearTimeout(timer))\n}\n\n/** @internal */\nexport const isGlobalEvent = (event: string) => {\n  // @ts-ignore\n  return GLOBAL_VIDEO_EVENTS.includes(event)\n}\n\n/** @internal */\nexport const isInternalGlobalEvent = (event: string) => {\n  // @ts-ignore\n  return INTERNAL_GLOBAL_VIDEO_EVENTS.includes(event)\n}\n\nexport const isSyntheticEvent = (event: string) => {\n  return event.includes(SYNTHETIC_EVENT_PREFIX)\n}\n\nexport const isSessionEvent = (event: string) => {\n  return event.includes('session.')\n}\n\nexport const getGlobalEvents = (kind: 'all' | 'video' = 'all') => {\n  switch (kind) {\n    case 'video':\n      return GLOBAL_VIDEO_EVENTS\n    default:\n      // prettier-ignore\n      return [\n        ...GLOBAL_VIDEO_EVENTS,\n      ]\n  }\n}\n\nconst cleanupEventNamespace = (event: string) => {\n  const eventParts = event.split(EVENT_NAMESPACE_DIVIDER)\n  return eventParts[eventParts.length - 1]\n}\n\n/**\n * These events have derived events generated by the SDK\n * i.e. member.updated.audioMuted or member.talking.started\n */\nconst WITH_CUSTOM_EVENT_NAMES = [\n  'video.member.updated',\n  'video.member.talking',\n] as const\n\n/**\n * These events are generated by the SDK to make them\n * more \"user-friendly\" while others are client-side only\n * like the WebRTC ones: `track`/`active`/`destroy` for Call objects.\n */\nconst CLIENT_SIDE_EVENT_NAMES = [\n  'video.room.joined', // generated client-side\n  'video.track',\n  'video.active',\n  'video.answering',\n  'video.destroy',\n  'video.early',\n  'video.hangup',\n  'video.held',\n  'video.new',\n  'video.purge',\n  'video.recovering',\n  'video.requesting',\n  'video.ringing',\n  'video.trying',\n]\n/**\n * Check and filter the events the user attached returning only the valid ones\n * for the server.\n * IE: `member.updated.audioMuted` means `member.updated` for the server.\n * @internal\n */\nexport const validateEventsToSubscribe = <T = string>(events: T[]): T[] => {\n  const valid = events.map((internalEvent) => {\n    if (typeof internalEvent === 'string') {\n      const event = cleanupEventNamespace(internalEvent)\n      if (\n        CLIENT_SIDE_EVENT_NAMES.includes(event) ||\n        isSyntheticEvent(event) ||\n        isLocalEvent(event) ||\n        isSessionEvent(event)\n      ) {\n        return null\n      }\n      const found = WITH_CUSTOM_EVENT_NAMES.find((withCustomName) => {\n        return event.startsWith(withCustomName)\n      })\n      return found || event\n    }\n\n    return internalEvent\n  })\n\n  return Array.from(new Set(valid)).filter(Boolean) as T[]\n}\n\n/**\n * \"Local\" events are events controlled by the SDK and the\n * server has no knowledge about them.\n */\nexport const isLocalEvent = (event: string) => {\n  return event.includes(LOCAL_EVENT_PREFIX)\n}\n\nexport const toLocalEvent = <T extends string>(event: string): T => {\n  const eventParts = event.split('.')\n  const prefix = eventParts[0]\n\n  return event\n    .split('.')\n    .reduce((reducer, item) => {\n      reducer.push(item)\n\n      if (item === prefix) {\n        reducer.push(LOCAL_EVENT_PREFIX)\n      }\n\n      return reducer\n    }, [] as string[])\n    .join('.') as T\n}\n\nexport const toSyntheticEvent = <T extends string>(event: string): T => {\n  const eventParts = event.split('.')\n  const prefix = eventParts[0]\n\n  return event\n    .split('.')\n    .reduce((reducer, item) => {\n      reducer.push(item)\n\n      if (item === prefix) {\n        reducer.push(SYNTHETIC_EVENT_PREFIX)\n      }\n\n      return reducer\n    }, [] as string[])\n    .join('.') as T\n}\n\nexport const isJSONRPCRequest = (\n  e: JSONRPCRequest | JSONRPCResponse\n): e is JSONRPCRequest => {\n  return Boolean((e as JSONRPCRequest).method)\n}\n\nexport const isJSONRPCResponse = (\n  e: JSONRPCRequest | JSONRPCResponse\n): e is JSONRPCResponse => {\n  return !isJSONRPCRequest(e)\n}\n", "import { JSONRPCRequest, JSONRPCResponse } from './interfaces'\n\ntype parseRPCResponseParams = {\n  response: JSONRPCResponse\n  request: JSONRPCRequest\n}\nexport const parseRPCResponse = ({\n  response,\n  request,\n}: parseRPCResponseParams) => {\n  const { result = {}, error } = response\n  if (error) {\n    return {\n      error,\n    }\n  }\n\n  switch (request.method) {\n    case 'signalwire.connect':\n      return { result }\n    default:\n      return parseResponse(response)\n  }\n}\n\n/**\n * From the socket we can get:\n * - JSON-RPC msg with 1 level of 'result' or 'error'\n * - JSON-RPC msg with 2 nested 'result' and 'code' property to identify error\n * - JSON-RPC msg with 3 nested 'result' where the third level is the Verto JSON-RPC flat msg.\n *\n * @returns Object with error | result key to identify success or fail\n */\nconst parseResponse = (\n  response: JSONRPCResponse,\n  nodeId?: string\n): { [key: string]: any } => {\n  const { result = {}, error } = response\n  if (error) {\n    return { error }\n  }\n  const { code, node_id, result: nestedResult = null } = result\n  if (code && code !== '200') {\n    return { error: result }\n  }\n  if (nestedResult === null) {\n    if (nodeId) {\n      // Attach node_id to the nestedResult\n      result.node_id = nodeId\n    }\n    return { result }\n  }\n  if (nestedResult) {\n    if (nestedResult.jsonrpc) {\n      // This is a verto message\n      return parseResponse(nestedResult, node_id)\n    }\n    return { result: nestedResult }\n  }\n  return { result }\n}\n", "import { SnakeToCamelCase, ConverToExternalTypes } from '../types/utils'\n\nconst toDateObject = (timestamp?: number) => {\n  if (typeof timestamp === 'undefined') {\n    return timestamp\n  }\n\n  const date = new Date(timestamp * 1000)\n\n  /**\n   * If for some reason we can't convert to a valid date\n   * we'll return the original value\n   */\n  if (isNaN(date.getTime())) {\n    return timestamp\n  }\n\n  return date\n}\n\nconst DEFAULT_OPTIONS = {\n  /**\n   * Properties coming from the server where their value will be\n   * converted to camelCase\n   */\n  propsToUpdateValue: [\n    'updated',\n    'layers',\n    'members',\n    'recordings',\n    'playbacks',\n  ],\n}\n\n/**\n * Follows the same convention as `src/types/utils/IsTimestamp`\n */\nconst isTimestampProperty = (prop: string) => {\n  return prop.endsWith('At')\n}\n\nexport type ToExternalJSONResult<T> = {\n  [Property in NonNullable<keyof T> as SnakeToCamelCase<\n    Extract<Property, string>\n  >]: ConverToExternalTypes<Extract<Property, string>, T[Property]>\n}\n\n/**\n * Converts a record (a JSON coming from the server) to a JSON meant\n * to be consumed by our users. This mostly mean converting properties\n * from snake_case to camelCase along with some other minor case\n * convertions to guarantee that our JS users will always interact\n * with camelCase properties.\n *\n * It's worth noting that this util is suited exactly to meet our\n * needs and won't (propertly) handle cases where the input record\n * doesn't have all its properties with casing other than snake_case.\n * This is on purpose to keep this util as light and fast as possible\n * since we have the guarantee that the server will always send their\n * payloads formatted this way.\n * @internal\n */\nexport const toExternalJSON = <T>(\n  input: T,\n  options: typeof DEFAULT_OPTIONS = DEFAULT_OPTIONS\n) => {\n  // @ts-expect-error\n  if (input?.__sw_symbol || input?.__sw_proxy) {\n    // Return if the input is a BaseComponent or a Proxy\n    return input as unknown as ToExternalJSONResult<T>\n  }\n\n  return Object.entries(input).reduce((reducer, [key, value]) => {\n    const prop = fromSnakeToCamelCase(key) as any\n    const propType = typeof value\n\n    /**\n     * While this check won't be enough to detect all possible objects\n     * it would cover our needs here since we just need to detect that\n     * it's not a primitive value\n     */\n    if (propType === 'object' && value) {\n      if (Array.isArray(value)) {\n        if (options.propsToUpdateValue.includes(key)) {\n          reducer[prop] = value.map((v) => {\n            if (typeof v === 'string') {\n              return fromSnakeToCamelCase(v)\n            }\n            return toExternalJSON(v)\n          })\n        } else {\n          reducer[prop] = value\n        }\n      } else {\n        reducer[prop] = toExternalJSON(value as T)\n      }\n    } else {\n      if (isTimestampProperty(prop)) {\n        reducer[prop] = toDateObject(value)\n      } else {\n        reducer[prop] = value\n      }\n    }\n\n    return reducer\n  }, {} as Record<string, unknown>) as ToExternalJSONResult<T>\n}\n\n/**\n * Converts values from snake_case to camelCase\n * @internal\n */\nconst fromSnakeToCamelCase = (input: string) => {\n  if (!input.includes('_')) {\n    return input\n  }\n  return input.split('_').reduce((reducer, part, index) => {\n    const fc = part.trim().charAt(0)\n    const remainingChars = part.substr(1).toLowerCase()\n\n    return `${reducer}${\n      index === 0 ? fc.toLowerCase() : fc.toUpperCase()\n    }${remainingChars}`\n  }, '')\n}\n", "const UPPERCASE_REGEX = /[A-Z]/g\n/**\n * Converts values from camelCase to snake_case\n * @internal\n */\nexport const fromCamelToSnakeCase = <T>(event: T): T => {\n  // @ts-ignore\n  return event.replace(UPPERCASE_REGEX, (letter) => {\n    return `_${letter.toLowerCase()}`\n  }) as T\n}\n", "import { fromCamelToSnakeCase } from './common'\nimport { EVENT_NAMESPACE_DIVIDER } from './constants'\nimport { EventEmitter } from './EventEmitter'\n\ntype ToInternalEventNameParams<\n  EventTypes extends EventEmitter.ValidEventTypes\n> = {\n  event: EventEmitter.EventNames<EventTypes>\n  namespace?: string\n}\n\nexport const toInternalEventName = <\n  EventTypes extends EventEmitter.ValidEventTypes\n>({\n  event,\n  namespace,\n}: ToInternalEventNameParams<EventTypes>) => {\n  // TODO: improve types of getNamespacedEvent and fromCamelToSnakeCase\n  if (typeof event === 'string') {\n    // other transforms here..\n    event = getNamespacedEvent({\n      event,\n      namespace,\n    }) as EventEmitter.EventNames<EventTypes>\n    event = fromCamelToSnakeCase<EventEmitter.EventNames<EventTypes>>(event)\n  }\n\n  return event\n}\n\nconst getNamespacedEvent = ({\n  namespace,\n  event,\n}: {\n  event: string\n  namespace?: string\n}) => {\n  /**\n   * If getNamespacedEvent is called with the `namespace` already\n   * present in the `event` or with a falsy namespace we'll return it\n   * as is\n   */\n  if (!namespace || event.startsWith(namespace)) {\n    return event\n  }\n\n  return `${namespace}${EVENT_NAMESPACE_DIVIDER}${event}`\n}\n", "import { JSONRPCRequest } from '..'\nimport { MapToPubSubShape } from '../redux/interfaces'\n\nexport const toInternalAction = <\n  T extends { event_type: unknown; params?: unknown; node_id?: string }\n>(\n  event: T\n) => {\n  const { event_type, params, node_id } = event\n\n  /**\n   * queuing.relay.tasks has a slightly different shape:\n   * no nested \"params\" so we return the whole event.\n   */\n  if (event_type === 'queuing.relay.tasks') {\n    return {\n      type: event_type,\n      payload: event,\n    } as MapToPubSubShape<T>\n  }\n\n  /**\n   * webrtc.message needs to carry with him the node_id\n   */\n  if (event_type === 'webrtc.message' && (params as JSONRPCRequest)?.jsonrpc) {\n    const vertoRPC = params as JSONRPCRequest\n    if (vertoRPC.params) {\n      vertoRPC.params.nodeId = node_id\n    }\n    return {\n      type: event_type,\n      payload: vertoRPC,\n    } as MapToPubSubShape<T>\n  }\n\n  return {\n    type: event_type,\n    payload: params,\n  } as MapToPubSubShape<T>\n}\n", "import { CamelToSnakeCase } from '../types/utils'\nimport { fromCamelToSnakeCase } from './common'\n\ntype ToSnakeCaseKeys<T> = {\n  [Property in NonNullable<keyof T> as CamelToSnakeCase<\n    Extract<Property, string>\n  >]: T[Property]\n}\n\nexport const toSnakeCaseKeys = <T extends Record<string, any>>(\n  obj: T,\n  transform: (value: string) => any = (value: string) => value,\n  result: Record<string, any> = {}\n) => {\n  if (Array.isArray(obj)) {\n    result = obj.map((item: any, index: number) => {\n      if (typeof item === 'object') {\n        return toSnakeCaseKeys(item, transform, result[index])\n      }\n      return item\n    })\n  } else {\n    Object.keys(obj).forEach((key) => {\n      const newKey = fromCamelToSnakeCase(key)\n      // Both 'object's and arrays will enter this branch\n      if (obj[key] && typeof obj[key] === 'object') {\n        result[newKey] = toSnakeCaseKeys(obj[key], transform, result[newKey])\n      } else {\n        result[newKey] = transform(obj[key])\n      }\n    })\n  }\n\n  return result as ToSnakeCaseKeys<T>\n}\n", "import type { APIMethodsMap } from './interfaces'\nimport type { ConstructableType } from '../types/utils'\n\nexport const extendComponent = <T, M>(\n  klass: any,\n  methods: APIMethodsMap<M>\n) => {\n  Object.keys(methods).forEach((methodName) => {\n    if (klass.prototype.hasOwnProperty(methodName)) {\n      throw new Error(`[extendComponent] Duplicated method name: ${methodName}`)\n    }\n  })\n\n  Object.defineProperties(klass.prototype, methods)\n\n  return klass as ConstructableType<T>\n}\n", "import { EventTransform } from '..'\n\n/**\n * Used for serializing Proxies when calling\n * Proxy.toString()\n */\nconst proxyToString = <T>({\n  property,\n  payload,\n}: {\n  property: Function | T\n  payload: unknown\n}) => {\n  return typeof property === 'function'\n    ? () => JSON.stringify(payload)\n    : property\n}\n\nconst getAllMethods = (objTarget: any): Record<string, Function> => {\n  let methods: Record<string, Function> = {}\n  let obj = objTarget\n  let shouldContinue = true\n  while (shouldContinue) {\n    Object.getOwnPropertyNames(obj).forEach((k) => {\n      if (\n        typeof objTarget[k] === 'function' &&\n        typeof k === 'string' &&\n        // If the method was already defined it means we can\n        // safely skip it since it was overwritten\n        !(k in methods)\n      ) {\n        methods[k] = objTarget[k]\n      }\n    })\n\n    if (!obj || !obj.__sw_symbol) {\n      shouldContinue = false\n    } else {\n      obj = Object.getPrototypeOf(obj)\n    }\n  }\n\n  return methods\n}\n\nexport const serializeableProxy = ({\n  instance,\n  proxiedObj,\n  payload,\n  transformedPayload,\n  transform,\n}: {\n  instance: any\n  proxiedObj: any\n  payload: any\n  transformedPayload: any\n  transform: any\n}) => {\n  const data = {\n    ...transformedPayload,\n    /**\n     * We manually add `_eventsNamespace` and `eventChannel`\n     * as an attempt to make this object as close as Proxy,\n     * but `_eventsNamespace` is actually required when\n     * using `instance` inside of workers. Without this the\n     * events will be queued because `_eventsNamespace` is\n     * undefined.\n     */\n    _eventsNamespace: transform.getInstanceEventNamespace\n      ? transform.getInstanceEventNamespace(payload)\n      : undefined,\n    eventChannel: transform.getInstanceEventChannel\n      ? transform.getInstanceEventChannel(payload)\n      : undefined,\n    ...getAllMethods(instance),\n  }\n\n  return Object.defineProperties(\n    proxiedObj,\n    Object.entries(data).reduce((reducer, [key, value]) => {\n      if (value === undefined) {\n        return reducer\n      }\n\n      reducer[key] = {\n        value,\n        enumerable: true,\n        configurable: true,\n        /**\n         * We mostly need this for our tests where we're\n         * overwritting things like `execute`.\n         */\n        writable: true,\n      }\n\n      return reducer\n    }, {} as Record<string, PropertyDescriptor>)\n  )\n}\n\ninterface ProxyFactoryOptions {\n  instance: any\n  transform: EventTransform\n  payload: unknown\n  transformedPayload: any\n}\n\nexport const proxyFactory = ({\n  instance,\n  transform,\n  payload,\n  transformedPayload,\n}: ProxyFactoryOptions) => {\n  const proxiedObj = new Proxy(instance, {\n    get(target: any, prop: any, receiver: any) {\n      if (prop === '__sw_proxy') {\n        return true\n      }\n\n      if (prop === 'toString') {\n        return proxyToString({\n          property: target[prop],\n          payload: transformedPayload,\n        })\n\n        /**\n         * Having `_eventsNamespace` defined will make\n         * BaseComponent.shouldAddToQueue === false, which\n         * will allow us to attach events right away\n         * (otherwise the events will be queued until the\n         * `namespace` is ready)\n         */\n      } else if (\n        prop === '_eventsNamespace' &&\n        transform.getInstanceEventNamespace\n      ) {\n        return transform.getInstanceEventNamespace(payload)\n      } else if (prop === 'eventChannel' && transform.getInstanceEventChannel) {\n        return transform.getInstanceEventChannel(payload)\n      } else if (prop in transformedPayload) {\n        return transformedPayload[prop]\n      }\n\n      return Reflect.get(target, prop, receiver)\n    },\n  })\n\n  /**\n   * This is just for helping users have a better experience\n   * when using console.log to debug the Proxy.\n   */\n  return serializeableProxy({\n    instance,\n    proxiedObj,\n    payload,\n    transformedPayload,\n    transform,\n  })\n}\n", "import { EventTransform } from './interfaces'\nimport { proxyFactory } from './proxyUtils'\n\ninterface InstanceProxyFactoryParams {\n  transform: EventTransform\n  payload: Record<any, unknown>\n}\n\n/**\n * Note: the cached instances within `_instanceByTransformType` will never be\n * cleaned since we're caching by `transform.type` so we will always have one\n * instance per type regardless of the Room/Member/Recording we're working on.\n * This is something we can improve in the future, but not an issue right now.\n * Exported for test purposes\n */\nexport const _instanceByTransformType = new Map<string, EventTransform>()\n\nconst _getOrCreateInstance = ({\n  transform,\n  payload,\n}: InstanceProxyFactoryParams) => {\n  if (!_instanceByTransformType.has(transform.type)) {\n    const instance = transform.instanceFactory(payload)\n    _instanceByTransformType.set(transform.type, instance)\n\n    return instance\n  }\n\n  return _instanceByTransformType.get(transform.type)\n}\n\nexport const instanceProxyFactory = ({\n  transform,\n  payload,\n}: InstanceProxyFactoryParams) => {\n  /** Create the instance or pick from cache */\n  const cachedInstance = _getOrCreateInstance({\n    transform,\n    payload,\n  })\n\n  const transformedPayload = transform.payloadTransform(payload)\n  const proxiedObj = proxyFactory({\n    transform,\n    payload,\n    instance: cachedInstance,\n    transformedPayload,\n  })\n\n  return proxiedObj\n}\n", "type ArgumentTypes<F extends Function> = F extends (...args: infer A) => any\n  ? A\n  : never\n\ntype MethodTypes = {\n  cancel: () => void\n  flush: () => void\n}\n\nexport function debounce<T extends Function>(\n  fn: T,\n  wait?: number,\n  callFirst?: false\n): ((...args: ArgumentTypes<T>) => void) & MethodTypes\n\nexport function debounce<T extends Function>(\n  fn: T,\n  wait: number = 0,\n  callFirst?: false\n) {\n  let timeout: NodeJS.Timeout | null = null\n  let debouncedFn: T | null = null\n\n  const clear = function () {\n    if (timeout) {\n      clearTimeout(timeout)\n\n      debouncedFn = null\n      timeout = null\n    }\n  }\n\n  const flush = function () {\n    const call = debouncedFn\n    clear()\n\n    if (call) {\n      call()\n    }\n  }\n\n  const debounceWrapper = function () {\n    if (!wait) {\n      // @ts-expect-error\n      return fn.apply(this, arguments)\n    }\n\n    // @ts-expect-error\n    const context = this\n    const args = arguments\n    const callNow = callFirst && !timeout\n    clear()\n\n    // @ts-expect-error\n    debouncedFn = function () {\n      fn.apply(context, args)\n    }\n\n    timeout = setTimeout(function () {\n      timeout = null\n\n      if (!callNow) {\n        const call = debouncedFn\n        debouncedFn = null\n\n        return call?.()\n      }\n    }, wait)\n\n    if (callNow && debouncedFn) {\n      return debouncedFn()\n    }\n  }\n\n  debounceWrapper.cancel = clear\n  debounceWrapper.flush = flush\n\n  return debounceWrapper\n}\n", "import { uuid } from '../utils'\nimport { JSONRPCMethod } from '../utils/interfaces'\n\ninterface MakeRPCRequestParams {\n  id?: string\n  method: JSONRPCMethod\n  params: {\n    // TODO: use list of types?\n    [key: string]: any\n  }\n}\nexport const makeRPCRequest = (params: MakeRPCRequestParams) => {\n  return {\n    jsonrpc: '2.0' as const,\n    id: params.id ?? uuid(),\n    ...params,\n  }\n}\n\ninterface MakeRPCResponseParams {\n  id: string\n  result: {\n    // TODO: use list of types?\n    [key: string]: any\n  }\n}\nexport const makeRPCResponse = (params: MakeRPCResponseParams) => {\n  return {\n    jsonrpc: '2.0' as const,\n    ...params,\n  }\n}\n", "import { makeRPCRequest } from './helpers'\n\ntype WithToken = { token: string; jwt_token?: never }\ntype WithJWT = { token?: never; jwt_token: string }\ntype RPCConnectAuthentication = { project?: string } & (WithToken | WithJWT)\nexport type RPCConnectParams = {\n  authentication: RPCConnectAuthentication\n  version?: typeof DEFAULT_CONNECT_VERSION\n  agent?: string\n  protocol?: string\n  contexts?: string[]\n}\n\nexport const DEFAULT_CONNECT_VERSION = {\n  major: 3,\n  minor: 0,\n  revision: 0,\n}\n\nexport const RPCConnect = (params: RPCConnectParams) => {\n  return makeRPCRequest({\n    method: 'signalwire.connect',\n    params: {\n      version: DEFAULT_CONNECT_VERSION,\n      ...params,\n    },\n  })\n}\n", "import { makeRPCRequest } from './helpers'\n\nexport type RPCReauthenticateParams = { project: string; jwt_token: string }\n\nexport const RPCReauthenticate = (authentication: RPCReauthenticateParams) => {\n  return makeRPCRequest({\n    method: 'signalwire.reauthenticate',\n    params: {\n      authentication,\n    },\n  })\n}\n", "import { makeRPCRequest, makeRPCResponse } from './helpers'\n\nexport const RPCPing = () => {\n  return makeRPCRequest({\n    method: 'signalwire.ping',\n    params: {\n      timestamp: Date.now() / 1000,\n    },\n  })\n}\n\nexport const RPCPingResponse = (id: string, timestamp?: number) => {\n  return makeRPCResponse({\n    id,\n    result: {\n      timestamp: timestamp || Date.now() / 1000,\n    },\n  })\n}\n", "import { makeRPCRequest } from './helpers'\nimport { JSONRPCMethod } from '../utils/interfaces'\n\ntype RPCExecuteParams = {\n  id?: string\n  method: JSONRPCMethod\n  params: Record<string, unknown>\n}\n\nexport const RPCExecute = ({ method, params }: RPCExecuteParams) => {\n  return makeRPCRequest({\n    method,\n    params,\n  })\n}\n", "import { makeRPCResponse } from './helpers'\n\nexport const RPCDisconnectResponse = (id: string) => {\n  return makeRPCResponse({\n    id,\n    result: {},\n  })\n}\n", "import { makeRPCRequest, makeRPCResponse } from './helpers'\nimport { VertoMethod } from '../utils/interfaces'\n\ntype VertoParams = { [key: string]: any }\n\nconst tmpMap: VertoParams = {\n  id: 'callID',\n  destinationNumber: 'destination_number',\n  remoteCallerName: 'remote_caller_id_name',\n  remoteCallerNumber: 'remote_caller_id_number',\n  callerName: 'caller_id_name',\n  callerNumber: 'caller_id_number',\n}\n\n/**\n * Translate SDK fields into verto variables\n */\nconst filterVertoParams = (params: VertoParams) => {\n  if (params.hasOwnProperty('dialogParams')) {\n    // prettier-ignore\n    const {\n      remoteSdp,\n      localStream,\n      remoteStream,\n      ...dialogParams\n    } = params.dialogParams\n    for (const key in tmpMap) {\n      if (key && dialogParams.hasOwnProperty(key)) {\n        // @ts-ignore\n        dialogParams[tmpMap[key]] = dialogParams[key]\n        delete dialogParams[key]\n      }\n    }\n    params.dialogParams = dialogParams\n  }\n\n  return params\n}\n\nconst buildVertoRPCMessage = (method: VertoMethod) => {\n  return (params: VertoParams = {}) => {\n    return makeRPCRequest({\n      method,\n      params: filterVertoParams(params),\n    })\n  }\n}\n\nexport const VertoInvite = buildVertoRPCMessage('verto.invite')\nexport const VertoBye = buildVertoRPCMessage('verto.bye')\nexport const VertoAttach = buildVertoRPCMessage('verto.attach')\nexport const VertoModify = buildVertoRPCMessage('verto.modify')\nexport const VertoInfo = buildVertoRPCMessage('verto.info')\nexport const VertoAnswer = buildVertoRPCMessage('verto.answer')\nexport const VertoPong = buildVertoRPCMessage('verto.pong')\nexport const VertoResult = (id: string, method: VertoMethod) => {\n  return makeRPCResponse({\n    id,\n    result: {\n      method,\n    },\n  })\n}\n", "import { createAction, Action } from './toolkit'\nimport {\n  JSONRPCRequest,\n  SessionAuthError,\n  SessionEvents,\n  CompoundEvents,\n} from '../utils/interfaces'\nimport { ExecuteActionParams } from './interfaces'\nimport { EventEmitter } from '..'\n\nexport const initAction = createAction('swSdk/init')\nexport const destroyAction = createAction('swSdk/destroy')\n/**\n * Used to trigger a `signalwire.reauthenticate`\n */\nexport const reauthAction = createAction<{ token: string }>('swSdk/reauth')\n\n/**\n * Trigger saga to send a JSONRPC over the wire\n */\nexport const executeAction = createAction<ExecuteActionParams>(\n  'swSdk/executeRequest'\n)\n\nexport const authErrorAction = createAction<{ error: SessionAuthError }>(\n  'auth/error'\n)\nexport const authSuccessAction = createAction('auth/success')\nexport const authExpiringAction = createAction('auth/expiring')\n\nexport const socketMessageAction = createAction<JSONRPCRequest, string>(\n  'socket/message'\n)\n\n// TODO: define if we need/want to send a payload with these events.\nexport const sessionConnectedAction = createAction<void, SessionEvents>(\n  'session.connected'\n)\nexport const sessionDisconnectedAction = createAction<void, SessionEvents>(\n  'session.disconnected'\n)\nexport const sessionReconnectingAction = createAction<void, SessionEvents>(\n  'session.reconnecting'\n)\nexport const sessionAuthErrorAction = createAction<Error, SessionEvents>(\n  'session.auth_error'\n)\nexport const sessionExpiringAction = createAction<void, SessionEvents>(\n  'session.expiring'\n)\nconst formatCustomSagaAction = (id: string, action: Action) => {\n  return `${action.type}/${id}`\n}\n\nexport const makeCustomSagaAction = (id: string, action: Action) => {\n  return {\n    ...action,\n    type: formatCustomSagaAction(id, action),\n  }\n}\n\nexport const getCustomSagaActionType = (id: string, action: Action) => {\n  return formatCustomSagaAction(id, action)\n}\n\nexport const compoundEventAttachAction = createAction<\n  {\n    compoundEvents: EventEmitter.EventNames<EventEmitter.ValidEventTypes>[]\n    event: EventEmitter.EventNames<EventEmitter.ValidEventTypes>\n    namespace?: string\n  },\n  CompoundEvents\n>('compound_event:attach')\n\nexport { createAction }\n", "/**\n * Cherry-picked (and adapted) version of Redux Toolkit. API\n * wise it remains fully compatible but we changed a couple\n * of things to reduce the overall bundle size. Most\n * important is that our version doesn't depend on Immer and\n * we don't include any of the default middleares included\n * by RTK like thunks or inmutable state (we do this through\n * TS).\n */\nexport * from 'redux'\nexport * from './createAction'\nexport * from './configureStore'\n", "import type { Action } from 'redux'\nimport type {\n  IsUnknownOrNonInferrable,\n  IfMaybeUndefined,\n  IfVoid,\n  IsAny,\n} from './tsHelpers'\n\n\n/**\n * An action with a string type and an associated payload. This is the\n * type of action returned by `createAction()` action creators.\n *\n * @template P The type of the action's payload.\n * @template T the type used for the action type.\n * @template M The type of the action's meta (optional)\n * @template E The type of the action's error (optional)\n *\n * @public\n */\nexport type PayloadAction<\n  P = void,\n  T extends string = string,\n  M = never,\n  E = never\n> = {\n  payload: P\n  type: T\n} & ([M] extends [never]\n  ? {}\n  : {\n      meta: M\n    }) &\n  ([E] extends [never]\n    ? {}\n    : {\n        error: E\n      })\n\n/**\n * A \"prepare\" method to be used as the second parameter of `createAction`.\n * Takes any number of arguments and returns a Flux Standard Action without\n * type (will be added later) that *must* contain a payload (might be undefined).\n *\n * @public\n */\nexport type PrepareAction<P> =\n  | ((...args: any[]) => { payload: P })\n  | ((...args: any[]) => { payload: P; meta: any })\n  | ((...args: any[]) => { payload: P; error: any })\n  | ((...args: any[]) => { payload: P; meta: any; error: any })\n\n/**\n * Internal version of `ActionCreatorWithPreparedPayload`. Not to be used externally.\n *\n * @internal\n */\nexport type _ActionCreatorWithPreparedPayload<\n  PA extends PrepareAction<any> | void,\n  T extends string = string\n> = PA extends PrepareAction<infer P>\n  ? ActionCreatorWithPreparedPayload<\n      Parameters<PA>,\n      P,\n      T,\n      ReturnType<PA> extends {\n        error: infer E\n      }\n        ? E\n        : never,\n      ReturnType<PA> extends {\n        meta: infer M\n      }\n        ? M\n        : never\n    >\n  : void\n\n/**\n * Basic type for all action creators.\n *\n * @inheritdoc {redux#ActionCreator}\n */\ninterface BaseActionCreator<P, T extends string, M = never, E = never> {\n  type: T\n  match: (action: Action<unknown>) => action is PayloadAction<P, T, M, E>\n}\n\n/**\n * An action creator that takes multiple arguments that are passed\n * to a `PrepareAction` method to create the final Action.\n * @typeParam Args arguments for the action creator function\n * @typeParam P `payload` type\n * @typeParam T `type` name\n * @typeParam E optional `error` type\n * @typeParam M optional `meta` type\n *\n * @inheritdoc {redux#ActionCreator}\n *\n * @public\n */\nexport interface ActionCreatorWithPreparedPayload<\n  Args extends unknown[],\n  P,\n  T extends string = string,\n  E = never,\n  M = never\n> extends BaseActionCreator<P, T, M, E> {\n  /**\n   * Calling this {@link redux#ActionCreator} with `Args` will return\n   * an Action with a payload of type `P` and (depending on the `PrepareAction`\n   * method used) a `meta`- and `error` property of types `M` and `E` respectively.\n   */\n  (...args: Args): PayloadAction<P, T, M, E>\n}\n\n/**\n * An action creator of type `T` that takes an optional payload of type `P`.\n *\n * @inheritdoc {redux#ActionCreator}\n *\n * @public\n */\nexport interface ActionCreatorWithOptionalPayload<P, T extends string = string>\n  extends BaseActionCreator<P, T> {\n  /**\n   * Calling this {@link redux#ActionCreator} with an argument will\n   * return a {@link PayloadAction} of type `T` with a payload of `P`.\n   * Calling it without an argument will return a PayloadAction with a payload of `undefined`.\n   */\n  (payload?: P): PayloadAction<P, T>\n}\n\n/**\n * An action creator of type `T` that takes no payload.\n *\n * @inheritdoc {redux#ActionCreator}\n *\n * @public\n */\nexport interface ActionCreatorWithoutPayload<T extends string = string>\n  extends BaseActionCreator<undefined, T> {\n  /**\n   * Calling this {@link redux#ActionCreator} will\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\n   */\n  (): PayloadAction<undefined, T>\n}\n\n/**\n * An action creator of type `T` that requires a payload of type P.\n *\n * @inheritdoc {redux#ActionCreator}\n *\n * @public\n */\nexport interface ActionCreatorWithPayload<P, T extends string = string>\n  extends BaseActionCreator<P, T> {\n  /**\n   * Calling this {@link redux#ActionCreator} with an argument will\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\n   */\n  (payload: P): PayloadAction<P, T>\n}\n\n/**\n * An action creator of type `T` whose `payload` type could not be inferred. Accepts everything as `payload`.\n *\n * @inheritdoc {redux#ActionCreator}\n *\n * @public\n */\nexport interface ActionCreatorWithNonInferrablePayload<\n  T extends string = string\n> extends BaseActionCreator<unknown, T> {\n  /**\n   * Calling this {@link redux#ActionCreator} with an argument will\n   * return a {@link PayloadAction} of type `T` with a payload\n   * of exactly the type of the argument.\n   */\n  <PT extends unknown>(payload: PT): PayloadAction<PT, T>\n}\n\n/**\n * An action creator that produces actions with a `payload` attribute.\n *\n * @typeParam P the `payload` type\n * @typeParam T the `type` of the resulting action\n * @typeParam PA if the resulting action is preprocessed by a `prepare` method, the signature of said method.\n *\n * @public\n */\nexport type PayloadActionCreator<\n  P = void,\n  T extends string = string,\n  PA extends PrepareAction<P> | void = void\n> = IfPrepareActionMethodProvided<\n  PA,\n  _ActionCreatorWithPreparedPayload<PA, T>,\n  // else\n  IsAny<\n    P,\n    ActionCreatorWithPayload<any, T>,\n    IsUnknownOrNonInferrable<\n      P,\n      ActionCreatorWithNonInferrablePayload<T>,\n      // else\n      IfVoid<\n        P,\n        ActionCreatorWithoutPayload<T>,\n        // else\n        IfMaybeUndefined<\n          P,\n          ActionCreatorWithOptionalPayload<P, T>,\n          // else\n          ActionCreatorWithPayload<P, T>\n        >\n      >\n    >\n  >\n>\n\n/**\n * A utility function to create an action creator for the given action type\n * string. The action creator accepts a single argument, which will be included\n * in the action object as a field called payload. The action creator function\n * will also have its toString() overriden so that it returns the action type,\n * allowing it to be used in reducer logic that is looking for that action type.\n *\n * @param type The action type to use for created actions.\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\n *                If this is given, the resulting action creator will pass its arguments to this method to calculate payload & meta.\n *\n * @public\n */\nexport function createAction<P = void, T extends string = string>(\n  type: T\n): PayloadActionCreator<P, T>\n\n/**\n * A utility function to create an action creator for the given action type\n * string. The action creator accepts a single argument, which will be included\n * in the action object as a field called payload. The action creator function\n * will also have its toString() overriden so that it returns the action type,\n * allowing it to be used in reducer logic that is looking for that action type.\n *\n * @param type The action type to use for created actions.\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\n *                If this is given, the resulting action creator will pass its arguments to this method to calculate payload & meta.\n *\n * @public\n */\nexport function createAction<\n  PA extends PrepareAction<any>,\n  T extends string = string\n>(\n  type: T,\n  prepareAction: PA\n): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>\n\nexport function createAction(type: string, prepareAction?: Function): any {\n  function actionCreator(...args: any[]) {\n    if (prepareAction) {\n      let prepared = prepareAction(...args)\n      if (!prepared) {\n        throw new Error('prepareAction did not return an object')\n      }\n\n      return {\n        type,\n        payload: prepared.payload,\n        ...('meta' in prepared && { meta: prepared.meta }),\n        ...('error' in prepared && { error: prepared.error }),\n      }\n    }\n    return { type, payload: args[0] }\n  }\n\n  actionCreator.toString = () => `${type}`\n\n  actionCreator.type = type\n\n  actionCreator.match = (action: Action<unknown>): action is PayloadAction =>\n    action.type === type\n\n  return actionCreator\n}\n\n// helper types for more readable typings\n\ntype IfPrepareActionMethodProvided<\n  PA extends PrepareAction<any> | void,\n  True,\n  False\n> = PA extends (...args: any[]) => any ? True : False\n", "import type {\n  Reducer,\n  ReducersMapObject,\n  Middleware,\n  Action,\n  AnyAction,\n  StoreEnhancer,\n  Store,\n  Dispatch,\n  PreloadedState,\n  CombinedState,\n} from 'redux'\nimport { createStore, compose, applyMiddleware, combineReducers } from 'redux'\nimport type { EnhancerOptions as DevToolsOptions } from './devtoolsExtension'\nimport { composeWithDevTools } from './devtoolsExtension'\n\nimport isPlainObject from './isPlainObject'\nimport {\n  CurriedGetDefaultMiddleware,\n  curryGetDefaultMiddleware,\n} from './getDefaultMiddleware'\nimport type { DispatchForMiddlewares, NoInfer } from './tsHelpers'\n\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production'\n\n/**\n * Callback function type, to be used in `ConfigureStoreOptions.enhancers`\n *\n * @public\n */\nexport type ConfigureEnhancersCallback = (\n  defaultEnhancers: readonly StoreEnhancer[]\n) => StoreEnhancer[]\n\n/**\n * Options for `configureStore()`.\n *\n * @public\n */\nexport interface ConfigureStoreOptions<\n  S = any,\n  A extends Action = AnyAction,\n  M extends Middlewares<S> = Middlewares<S>\n> {\n  /**\n   * A single reducer function that will be used as the root reducer, or an\n   * object of slice reducers that will be passed to `combineReducers()`.\n   */\n  reducer: Reducer<S, A> | ReducersMapObject<S, A>\n\n  /**\n   * An array of Redux middleware to install. If not supplied, defaults to\n   * the set of middleware returned by `getDefaultMiddleware()`.\n   */\n  middleware?: ((getDefaultMiddleware: CurriedGetDefaultMiddleware<S>) => M) | M\n\n  /**\n   * Whether to enable Redux DevTools integration. Defaults to `true`.\n   *\n   * Additional configuration can be done by passing Redux DevTools options\n   */\n  devTools?: boolean | DevToolsOptions\n\n  /**\n   * The initial state, same as Redux's createStore.\n   * You may optionally specify it to hydrate the state\n   * from the server in universal apps, or to restore a previously serialized\n   * user session. If you use `combineReducers()` to produce the root reducer\n   * function (either directly or indirectly by passing an object as `reducer`),\n   * this must be an object with the same shape as the reducer map keys.\n   */\n  /*\n  Not 100% correct but the best approximation we can get:\n  - if S is a `CombinedState` applying a second `CombinedState` on it does not change anything.\n  - if it is not, there could be two cases:\n    - `ReducersMapObject<S, A>` is being passed in. In this case, we will call `combineReducers` on it and `CombinedState<S>` is correct\n    - `Reducer<S, A>` is being passed in. In this case, actually `CombinedState<S>` is wrong and `S` would be correct.\n    As we cannot distinguish between those two cases without adding another generic paramter,\n    we just make the pragmatic assumption that the latter almost never happens.\n  */\n  preloadedState?: PreloadedState<CombinedState<NoInfer<S>>>\n\n  /**\n   * The store enhancers to apply. See Redux's `createStore()`.\n   * All enhancers will be included before the DevTools Extension enhancer.\n   * If you need to customize the order of enhancers, supply a callback\n   * function that will receive the original array (ie, `[applyMiddleware]`),\n   * and should return a new array (such as `[applyMiddleware, offline]`).\n   * If you only need to add middleware, you can use the `middleware` parameter instead.\n   */\n  enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback\n}\n\ntype Middlewares<S> = ReadonlyArray<Middleware<{}, S>>\n\n/**\n * A Redux store returned by `configureStore()`. Supports dispatching\n * side-effectful _thunks_ in addition to plain actions.\n *\n * @public\n */\nexport interface EnhancedStore<\n  S = any,\n  A extends Action = AnyAction,\n  M extends Middlewares<S> = Middlewares<S>\n> extends Store<S, A> {\n  /**\n   * The `dispatch` method of your store, enhanced by all its middlewares.\n   *\n   * @inheritdoc\n   */\n  dispatch: Dispatch<A> & DispatchForMiddlewares<M>\n}\n\n/**\n * A friendly abstraction over the standard Redux `createStore()` function.\n *\n * @param config The store configuration.\n * @returns A configured Redux store.\n *\n * @public\n */\nexport function configureStore<\n  S = any,\n  A extends Action = AnyAction,\n  M extends Middlewares<S> = []\n>(options: ConfigureStoreOptions<S, A, M>): EnhancedStore<S, A, M> {\n  const curriedGetDefaultMiddleware = curryGetDefaultMiddleware<S>()\n\n  const {\n    reducer = undefined,\n    middleware = curriedGetDefaultMiddleware(),\n    devTools = true,\n    preloadedState = undefined,\n    enhancers = undefined,\n  } = options || {}\n\n  let rootReducer: Reducer<S, A>\n\n  if (typeof reducer === 'function') {\n    rootReducer = reducer\n  } else if (isPlainObject(reducer)) {\n    rootReducer = combineReducers(reducer)\n  } else {\n    throw new Error(\n      '\"reducer\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'\n    )\n  }\n\n  let finalMiddleware = middleware\n  if (typeof finalMiddleware === 'function') {\n    finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware)\n\n    if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) {\n      throw new Error(\n        'when using a middleware builder function, an array of middleware must be returned'\n      )\n    }\n  }\n  if (\n    !IS_PRODUCTION &&\n    finalMiddleware.some((item) => typeof item !== 'function')\n  ) {\n    throw new Error(\n      'each middleware provided to configureStore must be a function'\n    )\n  }\n\n  const middlewareEnhancer = applyMiddleware(...finalMiddleware)\n\n  let finalCompose = compose\n\n  if (devTools) {\n    finalCompose = composeWithDevTools({\n      // Enable capture of stack traces for dispatched Redux actions\n      trace: !IS_PRODUCTION,\n      ...(typeof devTools === 'object' && devTools),\n    })\n  }\n\n  let storeEnhancers: StoreEnhancer[] = [middlewareEnhancer]\n\n  if (Array.isArray(enhancers)) {\n    storeEnhancers = [middlewareEnhancer, ...enhancers]\n  } else if (typeof enhancers === 'function') {\n    storeEnhancers = enhancers(storeEnhancers)\n  }\n\n  const composedEnhancer = finalCompose(...storeEnhancers) as any\n\n  return createStore(rootReducer, preloadedState, composedEnhancer)\n}\n", "import type { Action, ActionCreator, StoreEnhancer } from 'redux'\nimport { compose } from 'redux'\n\n/**\n * @public\n */\nexport interface EnhancerOptions {\n  /**\n   * the instance name to be showed on the monitor page. Default value is `document.title`.\n   * If not specified and there's no document title, it will consist of `tabId` and `instanceId`.\n   */\n  name?: string\n  /**\n   * action creators functions to be available in the Dispatcher.\n   */\n  actionCreators?: ActionCreator<any>[] | { [key: string]: ActionCreator<any> }\n  /**\n   * if more than one action is dispatched in the indicated interval, all new actions will be collected and sent at once.\n   * It is the joint between performance and speed. When set to `0`, all actions will be sent instantly.\n   * Set it to a higher value when experiencing perf issues (also `maxAge` to a lower value).\n   *\n   * @default 500 ms.\n   */\n  latency?: number\n  /**\n   * (> 1) - maximum allowed actions to be stored in the history tree. The oldest actions are removed once maxAge is reached. It's critical for performance.\n   *\n   * @default 50\n   */\n  maxAge?: number\n  /**\n   * See detailed documentation at http://extension.remotedev.io/docs/API/Arguments.html#serialize\n   */\n  serialize?:\n    | boolean\n    | {\n        options?:\n          | boolean\n          | {\n              date?: boolean\n              regex?: boolean\n              undefined?: boolean\n              error?: boolean\n              symbol?: boolean\n              map?: boolean\n              set?: boolean\n              function?: boolean | Function\n            }\n        replacer?: (key: string, value: unknown) => unknown\n        reviver?: (key: string, value: unknown) => unknown\n        immutable?: unknown\n        refs?: unknown[]\n      }\n  /**\n   * function which takes `action` object and id number as arguments, and should return `action` object back.\n   */\n  actionSanitizer?: <A extends Action>(action: A, id: number) => A\n  /**\n   * function which takes `state` object and index as arguments, and should return `state` object back.\n   */\n  stateSanitizer?: <S>(state: S, index: number) => S\n  /**\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\n   */\n  actionsBlacklist?: string | string[]\n  /**\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\n   */\n  actionsWhitelist?: string | string[]\n  /**\n   * called for every action before sending, takes `state` and `action` object, and returns `true` in case it allows sending the current data to the monitor.\n   * Use it as a more advanced version of `actionsBlacklist`/`actionsWhitelist` parameters.\n   */\n  predicate?: <S, A extends Action>(state: S, action: A) => boolean\n  /**\n   * if specified as `false`, it will not record the changes till clicking on `Start recording` button.\n   * Available only for Redux enhancer, for others use `autoPause`.\n   *\n   * @default true\n   */\n  shouldRecordChanges?: boolean\n  /**\n   * if specified, whenever clicking on `Pause recording` button and there are actions in the history log, will add this action type.\n   * If not specified, will commit when paused. Available only for Redux enhancer.\n   *\n   * @default \"@@PAUSED\"\"\n   */\n  pauseActionType?: string\n  /**\n   * auto pauses when the extension\u2019s window is not opened, and so has zero impact on your app when not in use.\n   * Not available for Redux enhancer (as it already does it but storing the data to be sent).\n   *\n   * @default false\n   */\n  autoPause?: boolean\n  /**\n   * if specified as `true`, it will not allow any non-monitor actions to be dispatched till clicking on `Unlock changes` button.\n   * Available only for Redux enhancer.\n   *\n   * @default false\n   */\n  shouldStartLocked?: boolean\n  /**\n   * if set to `false`, will not recompute the states on hot reloading (or on replacing the reducers). Available only for Redux enhancer.\n   *\n   * @default true\n   */\n  shouldHotReload?: boolean\n  /**\n   * if specified as `true`, whenever there's an exception in reducers, the monitors will show the error message, and next actions will not be dispatched.\n   *\n   * @default false\n   */\n  shouldCatchErrors?: boolean\n  /**\n   * If you want to restrict the extension, specify the features you allow.\n   * If not specified, all of the features are enabled. When set as an object, only those included as `true` will be allowed.\n   * Note that except `true`/`false`, `import` and `export` can be set as `custom` (which is by default for Redux enhancer), meaning that the importing/exporting occurs on the client side.\n   * Otherwise, you'll get/set the data right from the monitor part.\n   */\n  features?: {\n    /**\n     * start/pause recording of dispatched actions\n     */\n    pause?: boolean\n    /**\n     * lock/unlock dispatching actions and side effects\n     */\n    lock?: boolean\n    /**\n     * persist states on page reloading\n     */\n    persist?: boolean\n    /**\n     * export history of actions in a file\n     */\n    export?: boolean | 'custom'\n    /**\n     * import history of actions from a file\n     */\n    import?: boolean | 'custom'\n    /**\n     * jump back and forth (time travelling)\n     */\n    jump?: boolean\n    /**\n     * skip (cancel) actions\n     */\n    skip?: boolean\n    /**\n     * drag and drop actions in the history list\n     */\n    reorder?: boolean\n    /**\n     * dispatch custom actions or action creators\n     */\n    dispatch?: boolean\n    /**\n     * generate tests for the selected actions\n     */\n    test?: boolean\n  }\n  /**\n   * Set to true or a stacktrace-returning function to record call stack traces for dispatched actions.\n   * Defaults to false.\n   */\n  trace?: boolean | (<A extends Action>(action: A) => string)\n  /**\n   * The maximum number of stack trace entries to record per action. Defaults to 10.\n   */\n  traceLimit?: number\n}\n\n/**\n * @public\n */\nexport const composeWithDevTools: {\n  (options: EnhancerOptions): typeof compose\n  <StoreExt>(...funcs: Array<StoreEnhancer<StoreExt>>): StoreEnhancer<StoreExt>\n} =\n  typeof window !== 'undefined' &&\n  (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\n    : function () {\n        if (arguments.length === 0) return undefined\n        if (typeof arguments[0] === 'object') return compose\n        return compose.apply(null, arguments as any as Function[])\n      }\n\n/**\n * @public\n */\nexport const devToolsEnhancer: {\n  (options: EnhancerOptions): StoreEnhancer<any>\n} =\n  typeof window !== 'undefined' && (window as any).__REDUX_DEVTOOLS_EXTENSION__\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION__\n    : function () {\n        return function (noop) {\n          return noop\n        }\n      }\n", "/**\n * Returns true if the passed value is \"plain\" object, i.e. an object whose\n * prototype is the root `Object.prototype`. This includes objects created\n * using object literals, but not for instance for class instances.\n *\n * @param {any} value The value to inspect.\n * @returns {boolean} True if the argument appears to be a plain object.\n *\n * @public\n */\nexport default function isPlainObject(value: unknown): value is object {\n  if (typeof value !== 'object' || value === null) return false\n\n  let proto = Object.getPrototypeOf(value)\n  if (proto === null) return true\n\n  let baseProto = proto\n  while (Object.getPrototypeOf(baseProto) !== null) {\n    baseProto = Object.getPrototypeOf(baseProto)\n  }\n\n  return proto === baseProto\n}\n", "import { Middleware } from 'redux'\nimport { MiddlewareArray } from './utils'\n\ninterface GetDefaultMiddlewareOptions {}\n\nexport type CurriedGetDefaultMiddleware<S = any> = <\n  O extends Partial<GetDefaultMiddlewareOptions> = {\n    thunk: true\n    immutableCheck: true\n    serializableCheck: true\n  }\n>(\n  options?: O\n) => MiddlewareArray<Middleware<{}, S>>\n\nexport function curryGetDefaultMiddleware<\n  S = any\n>(): CurriedGetDefaultMiddleware<S> {\n  return function curriedGetDefaultMiddleware() {\n    return [] as unknown as MiddlewareArray<Middleware<{}, S>>\n  }\n}\n", "import { Action, AnyAction } from \"redux\"\nimport { CaseReducer } from \"./createReducer\"\nimport { ActionMatcher, ActionMatcherDescriptionCollection, CaseReducers } from \"./createReducer\"\n\nexport interface TypedActionCreator<Type extends string> {\n  (...args: any[]): Action<Type>\n  type: Type\n}\n\n/**\n * A builder for an action <-> reducer map.\n *\n * @public\n */\n export interface ActionReducerMapBuilder<State> {\n  /**\n   * Adds a case reducer to handle a single exact action type.\n   * @remarks\n   * All calls to `builder.addCase` must come before any calls to `builder.addMatcher` or `builder.addDefaultCase`.\n   * @param actionCreator - Either a plain action type string, or an action creator generated by [`createAction`](./createAction) that can be used to determine the action type.\n   * @param reducer - The actual case reducer function.\n   */\n  addCase<ActionCreator extends TypedActionCreator<string>>(\n    actionCreator: ActionCreator,\n    reducer: CaseReducer<State, ReturnType<ActionCreator>>\n  ): ActionReducerMapBuilder<State>\n  /**\n   * Adds a case reducer to handle a single exact action type.\n   * @remarks\n   * All calls to `builder.addCase` must come before any calls to `builder.addMatcher` or `builder.addDefaultCase`.\n   * @param actionCreator - Either a plain action type string, or an action creator generated by [`createAction`](./createAction) that can be used to determine the action type.\n   * @param reducer - The actual case reducer function.\n   */\n  addCase<Type extends string, A extends Action<Type>>(\n    type: Type,\n    reducer: CaseReducer<State, A>\n  ): ActionReducerMapBuilder<State>\n\n  addMatcher<A extends AnyAction>(\n    matcher: ActionMatcher<A> | ((action: AnyAction) => boolean),\n    reducer: CaseReducer<State, A>\n  ): Omit<ActionReducerMapBuilder<State>, 'addCase'>\n\n  addDefaultCase(reducer: CaseReducer<State, AnyAction>): {}\n}\n\nexport function executeReducerBuilderCallback<S>(\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\n): [\n  CaseReducers<S, any>,\n  ActionMatcherDescriptionCollection<S>,\n  CaseReducer<S, AnyAction> | undefined\n] {\n  const actionsMap: CaseReducers<S, any> = {}\n  const actionMatchers: ActionMatcherDescriptionCollection<S> = []\n  let defaultCaseReducer: CaseReducer<S, AnyAction> | undefined\n  const builder = {\n    addCase(\n      typeOrActionCreator: string | TypedActionCreator<any>,\n      reducer: CaseReducer<S>\n    ) {\n      if (process.env.NODE_ENV !== 'production') {\n        /*\n         to keep the definition by the user in line with actual behavior,\n         we enforce `addCase` to always be called before calling `addMatcher`\n         as matching cases take precedence over matchers\n         */\n        if (actionMatchers.length > 0) {\n          throw new Error(\n            '`builder.addCase` should only be called before calling `builder.addMatcher`'\n          )\n        }\n        if (defaultCaseReducer) {\n          throw new Error(\n            '`builder.addCase` should only be called before calling `builder.addDefaultCase`'\n          )\n        }\n      }\n      const type =\n        typeof typeOrActionCreator === 'string'\n          ? typeOrActionCreator\n          : typeOrActionCreator.type\n      if (type in actionsMap) {\n        throw new Error(\n          'addCase cannot be called with two reducers for the same action type'\n        )\n      }\n      actionsMap[type] = reducer\n      return builder\n    },\n    addMatcher<A extends AnyAction>(\n      matcher: ActionMatcher<A>,\n      reducer: CaseReducer<S, A>\n    ) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (defaultCaseReducer) {\n          throw new Error(\n            '`builder.addMatcher` should only be called before calling `builder.addDefaultCase`'\n          )\n        }\n      }\n      actionMatchers.push({ matcher, reducer })\n      return builder\n    },\n    addDefaultCase(reducer: CaseReducer<S, AnyAction>) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (defaultCaseReducer) {\n          throw new Error('`builder.addDefaultCase` can only be called once')\n        }\n      }\n      defaultCaseReducer = reducer\n      return builder\n    },\n  }\n  builderCallback(builder)\n  return [actionsMap, actionMatchers, defaultCaseReducer]\n}\n", "import { Action, AnyAction, Reducer } from 'redux'\nimport { DeepReadonly } from '../../types'\nimport { ActionReducerMapBuilder, executeReducerBuilderCallback } from './mapBuilders'\nimport { NoInfer } from './tsHelpers'\n\nexport type CaseReducer<S = any, A extends Action = AnyAction> = (\n  state: S,\n  action: A\n) => S | void\n\nexport interface ActionMatcher<A extends AnyAction> {\n  (action: AnyAction): action is A\n}\n\n/**\n * Defines a mapping from action types to corresponding action object shapes.\n *\n * @deprecated This should not be used manually - it is only used for internal\n *             inference purposes and should not have any further value.\n *             It might be removed in the future.\n * @public\n */\nexport type Actions<T extends keyof any = string> = Record<T, Action>\n\n/**\n * A mapping from action types to case reducers for `createReducer()`.\n *\n * @deprecated This should not be used manually - it is only used\n *             for internal inference purposes and using it manually\n *             would lead to type erasure.\n *             It might be removed in the future.\n * @public\n */\nexport type CaseReducers<S, AS extends Actions> = {\n  [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void\n}\n\nexport type ActionMatcherDescription<S, A extends AnyAction> = {\n  matcher: ActionMatcher<A>\n  reducer: CaseReducer<S, NoInfer<A>>\n}\n\nexport type ActionMatcherDescriptionCollection<S> = Array<\n  ActionMatcherDescription<S, any>\n>\n\n\nexport type NotFunction<T> = T extends Function ? never : T\n\nexport type ReducerWithInitialState<S extends NotFunction<any>> = Reducer<DeepReadonly<S>> & {\n  getInitialState: () => DeepReadonly<S>\n}\n\nexport type ReadonlyActionMatcherDescriptionCollection<S> = ReadonlyArray<\n  ActionMatcherDescription<S, any>\n>\n\nfunction isStateFunction<S>(x: unknown): x is () => S {\n  return typeof x === 'function'\n}\n\nexport function createReducer<S extends NotFunction<any>>(\n  initialState: S | (() => S),\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\n): ReducerWithInitialState<S>\n\nexport function createReducer<\n  S extends NotFunction<any>,\n  CR extends CaseReducers<S, any> = CaseReducers<S, any>\n>(\n  initialState: S | (() => S),\n  actionsMap: CR,\n  actionMatchers?: ActionMatcherDescriptionCollection<S>,\n  defaultCaseReducer?: CaseReducer<S>\n): ReducerWithInitialState<S>\n\nexport function createReducer<S extends NotFunction<any>>(\n  initialState: S | (() => S),\n  mapOrBuilderCallback:\n    | CaseReducers<S, any>\n    | ((builder: ActionReducerMapBuilder<S>) => void),\n  actionMatchers: ReadonlyActionMatcherDescriptionCollection<S> = [],\n  defaultCaseReducer?: CaseReducer<S>\n): ReducerWithInitialState<S> {\n  let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] =\n    typeof mapOrBuilderCallback === 'function'\n      ? executeReducerBuilderCallback(mapOrBuilderCallback)\n      : [mapOrBuilderCallback, actionMatchers, defaultCaseReducer]\n\n  // Ensure the initial state gets frozen either way\n  let getInitialState: () => S\n  if (isStateFunction(initialState)) {\n    getInitialState = () => initialState()\n  } else {\n    getInitialState = () => initialState\n  }\n\n  function reducer(state = getInitialState(), action: any): S {\n    let caseReducers = [\n      actionsMap[action.type],\n      ...finalActionMatchers\n        .filter(({ matcher }) => matcher(action))\n        .map(({ reducer }) => reducer),\n    ]\n    if (caseReducers.filter((cr) => !!cr).length === 0) {\n      caseReducers = [finalDefaultCaseReducer]\n    }\n\n    return caseReducers.reduce((previousState, caseReducer): S => {\n      if (caseReducer) {\n        return caseReducer(previousState, action) as S\n      }\n\n      return previousState\n    }, state)\n  }\n\n  reducer.getInitialState = getInitialState\n\n  return reducer as ReducerWithInitialState<S>\n}\n", "import type { Reducer } from 'redux'\nimport {\n  ActionCreatorWithoutPayload,\n  createAction,\n  PayloadAction,\n  PrepareAction,\n  _ActionCreatorWithPreparedPayload,\n} from '.'\nimport { DeepReadonly } from '../../types'\nimport { PayloadActionCreator } from './createAction'\nimport {\n  CaseReducer,\n  CaseReducers,\n  createReducer,\n  ReducerWithInitialState,\n} from './createReducer'\nimport {\n  ActionReducerMapBuilder,\n  executeReducerBuilderCallback,\n} from './mapBuilders'\nimport { NoInfer } from './tsHelpers'\n\n/**\n * An action creator attached to a slice.\n *\n * @deprecated please use PayloadActionCreator directly\n *\n * @public\n */\nexport type SliceActionCreator<P> = PayloadActionCreator<P>\n\n/**\n * The return value of `createSlice`\n *\n * @public\n */\nexport interface Slice<\n  State = any,\n  CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,\n  Name extends string = string\n> {\n  /**\n   * The slice name.\n   */\n  name: Name\n\n  /**\n   * The slice's reducer.\n   */\n  reducer: Reducer<DeepReadonly<State>>\n\n  /**\n   * Action creators for the types of actions that are handled by the slice\n   * reducer.\n   */\n  actions: CaseReducerActions<CaseReducers>\n\n  /**\n   * The individual case reducer functions that were passed in the `reducers` parameter.\n   * This enables reuse and testing if they were defined inline when calling `createSlice`.\n   */\n  caseReducers: SliceDefinedCaseReducers<CaseReducers>\n\n  /**\n   * Provides access to the initial state value given to the slice.\n   * If a lazy state initializer was provided, it will be called and a fresh value returned.\n   */\n  getInitialState: () => DeepReadonly<State>\n}\n\n/**\n * Options for `createSlice()`.\n *\n * @public\n */\nexport interface CreateSliceOptions<\n  State = any,\n  CR extends SliceCaseReducers<State> = SliceCaseReducers<State>,\n  Name extends string = string\n> {\n  name: Name\n  initialState: State | (() => State)\n  reducers: ValidateSliceCaseReducers<State, CR>\n  extraReducers?:\n    | CaseReducers<NoInfer<State>, any>\n    | ((builder: ActionReducerMapBuilder<NoInfer<State>>) => void)\n}\n\n/**\n * A CaseReducer with a `prepare` method.\n *\n * @public\n */\nexport type CaseReducerWithPrepare<State, Action extends PayloadAction> = {\n  reducer: CaseReducer<State, Action>\n  prepare: PrepareAction<Action['payload']>\n}\n\n/**\n * The type describing a slice's `reducers` option.\n *\n * @public\n */\nexport type SliceCaseReducers<State> = {\n  [K: string]:\n    | CaseReducer<DeepReadonly<State>, PayloadAction<any>>\n    | CaseReducerWithPrepare<DeepReadonly<State>, PayloadAction<any, string, any, any>>\n}\n\n/**\n * Derives the slice's `actions` property from the `reducers` options\n *\n * @public\n */\nexport type CaseReducerActions<CaseReducers extends SliceCaseReducers<any>> = {\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends { prepare: any }\n    ? ActionCreatorForCaseReducerWithPrepare<CaseReducers[Type]>\n    : ActionCreatorForCaseReducer<CaseReducers[Type]>\n}\n\n/**\n * Get a `PayloadActionCreator` type for a passed `CaseReducerWithPrepare`\n *\n * @internal\n */\ntype ActionCreatorForCaseReducerWithPrepare<CR extends { prepare: any }> =\n  _ActionCreatorWithPreparedPayload<CR['prepare'], string>\n\n/**\n * Get a `PayloadActionCreator` type for a passed `CaseReducer`\n *\n * @internal\n */\ntype ActionCreatorForCaseReducer<CR> = CR extends (\n  state: any,\n  action: infer Action\n) => any\n  ? Action extends { payload: infer P }\n    ? PayloadActionCreator<P>\n    : ActionCreatorWithoutPayload\n  : ActionCreatorWithoutPayload\n\n/**\n * Extracts the CaseReducers out of a `reducers` object, even if they are\n * tested into a `CaseReducerWithPrepare`.\n *\n * @internal\n */\ntype SliceDefinedCaseReducers<CaseReducers extends SliceCaseReducers<any>> = {\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends {\n    reducer: infer Reducer\n  }\n    ? Reducer\n    : CaseReducers[Type]\n}\n\n/**\n * Used on a SliceCaseReducers object.\n * Ensures that if a CaseReducer is a `CaseReducerWithPrepare`, that\n * the `reducer` and the `prepare` function use the same type of `payload`.\n *\n * Might do additional such checks in the future.\n *\n * This type is only ever useful if you want to write your own wrapper around\n * `createSlice`. Please don't use it otherwise!\n *\n * @public\n */\nexport type ValidateSliceCaseReducers<\n  S,\n  ACR extends SliceCaseReducers<S>\n> = ACR & {\n  [T in keyof ACR]: ACR[T] extends {\n    reducer(s: S, action?: infer A): any\n  }\n    ? {\n        prepare(...a: never[]): Omit<A, 'type'>\n      }\n    : {}\n}\n\nfunction getType(slice: string, actionKey: string): string {\n  return `${slice}/${actionKey}`\n}\n\n/**\n * A function that accepts an initial state, an object full of reducer\n * functions, and a \"slice name\", and automatically generates\n * action creators and action types that correspond to the\n * reducers and state.\n *\n * The `reducer` argument is passed to `createReducer()`.\n *\n * @public\n */\nexport function createSlice<\n  State,\n  CaseReducers extends SliceCaseReducers<State>,\n  Name extends string = string\n>(\n  options: CreateSliceOptions<State, CaseReducers, Name>\n): Slice<State, CaseReducers, Name> {\n  const { name } = options\n  if (!name) {\n    throw new Error('`name` is a required option for createSlice')\n  }\n\n  // const initialState =\n  //   typeof options.initialState == 'function'\n  //     ? options.initialState\n  //     : createNextState(options.initialState, () => {})\n  const initialState = options.initialState\n\n  const reducers = options.reducers || {}\n\n  const reducerNames = Object.keys(reducers)\n\n  const sliceCaseReducersByName: Record<string, CaseReducer> = {}\n  const sliceCaseReducersByType: Record<string, CaseReducer> = {}\n  const actionCreators: Record<string, Function> = {}\n\n  reducerNames.forEach((reducerName) => {\n    const maybeReducerWithPrepare = reducers[reducerName]\n    const type = getType(name, reducerName)\n\n    let caseReducer: CaseReducer<DeepReadonly<State>, any>\n    let prepareCallback: PrepareAction<any> | undefined\n\n    if ('reducer' in maybeReducerWithPrepare) {\n      caseReducer = maybeReducerWithPrepare.reducer\n      prepareCallback = maybeReducerWithPrepare.prepare\n    } else {\n      caseReducer = maybeReducerWithPrepare\n    }\n\n    sliceCaseReducersByName[reducerName] = caseReducer\n    sliceCaseReducersByType[type] = caseReducer\n    actionCreators[reducerName] = prepareCallback\n      ? createAction(type, prepareCallback)\n      : createAction(type)\n  })\n\n  function buildReducer() {\n    const [\n      extraReducers = {},\n      actionMatchers = [],\n      defaultCaseReducer = undefined,\n    ] =\n      typeof options.extraReducers === 'function'\n        ? executeReducerBuilderCallback(options.extraReducers)\n        : [options.extraReducers]\n\n    const finalCaseReducers = { ...extraReducers, ...sliceCaseReducersByType }\n    return createReducer(\n      initialState,\n      finalCaseReducers as any,\n      actionMatchers,\n      defaultCaseReducer\n    )\n  }\n\n  let _reducer: ReducerWithInitialState<State>\n\n  return {\n    name,\n    reducer(state, action) {\n      if (!_reducer) _reducer = buildReducer()\n\n      return _reducer(state, action)\n    },\n    actions: actionCreators as any,\n    caseReducers: sliceCaseReducersByName as any,\n    getInitialState() {\n      if (!_reducer) _reducer = buildReducer()\n\n      return _reducer.getInitialState()\n    },\n  }\n}\n", "import {\n  SliceCaseReducers,\n  ValidateSliceCaseReducers,\n  createSlice,\n} from '../toolkit/createSlice'\nimport { ActionReducerMapBuilder } from '../toolkit/mapBuilders'\nimport { destroyAction } from '../actions'\n\nexport const createDestroyableSlice = <\n  T,\n  Reducers extends SliceCaseReducers<T>\n>({\n  name = '',\n  initialState,\n  reducers,\n  extraReducers,\n}: {\n  name: string\n  initialState: T\n  reducers: ValidateSliceCaseReducers<T, Reducers>\n  extraReducers?: (builder: ActionReducerMapBuilder<T>) => void\n}) => {\n  return createSlice({\n    name,\n    initialState,\n    reducers,\n    extraReducers: (builder) => {\n      builder.addCase(destroyAction.type, () => {\n        return initialState\n      })\n\n      if (typeof extraReducers === 'function') {\n        extraReducers(builder)\n      }\n    },\n  })\n}\n", "import type { PayloadAction, AnyAction } from '../../toolkit'\nimport type { SessionState } from '../../interfaces'\nimport type {\n  Authorization,\n  RPCConnectResult,\n  SessionAuthError,\n  SessionAuthStatus,\n} from '../../../utils/interfaces'\nimport type { DeepReadonly } from '../../../types'\nimport { createDestroyableSlice } from '../../utils/createDestroyableSlice'\nimport { authErrorAction, initAction, reauthAction } from '../../actions'\n\nexport const initialSessionState: DeepReadonly<SessionState> = {\n  protocol: '',\n  iceServers: [],\n  authStatus: 'unknown',\n  authState: undefined,\n  authError: undefined,\n  authCount: 0,\n}\n\ntype AuthorizingAction = typeof initAction | typeof reauthAction\nfunction authorizingAction(action: AnyAction): action is AuthorizingAction {\n  return [initAction.type, reauthAction.type].includes(action.type)\n}\n\nconst sessionSlice = createDestroyableSlice({\n  name: 'session',\n  initialState: initialSessionState,\n  reducers: {\n    connected: (state, { payload }: PayloadAction<RPCConnectResult>) => {\n      return {\n        ...state,\n        authStatus: 'authorized',\n        authState: payload?.authorization,\n        authCount: state.authCount + 1,\n        protocol: payload?.protocol ?? '',\n        iceServers: payload?.ice_servers ?? [],\n      }\n    },\n    authStatus: (state, { payload }: PayloadAction<SessionAuthStatus>) => {\n      return {\n        ...state,\n        authStatus: payload,\n      }\n    },\n    updateAuthState: (state, { payload }: PayloadAction<Authorization>) => {\n      return {\n        ...state,\n        authState: payload,\n      }\n    },\n  },\n  extraReducers: (builder) => {\n    builder.addCase(\n      authErrorAction.type,\n      (state, { payload }: PayloadAction<{ error: SessionAuthError }>) => {\n        return {\n          ...state,\n          authStatus: 'unauthorized',\n          authError: payload.error,\n        }\n      }\n    )\n    builder.addMatcher(authorizingAction, (state) => {\n      return {\n        ...state,\n        authStatus: 'authorizing',\n      }\n    })\n  },\n})\n\n// prettier-ignore\nexport const {\n  actions: sessionActions,\n  reducer: sessionReducer\n} = sessionSlice\n", "import {\n  uuid,\n  getLogger,\n  checkWebSocketHost,\n  timeoutPromise,\n  parseRPCResponse,\n  safeParseJson,\n  isJSONRPCResponse,\n} from './utils'\nimport { PayloadAction } from './redux'\nimport { DEFAULT_HOST, WebSocketState } from './utils/constants'\nimport {\n  RPCConnect,\n  RPCConnectParams,\n  DEFAULT_CONNECT_VERSION,\n  RPCDisconnectResponse,\n  RPCPingResponse,\n} from './RPCMessages'\nimport {\n  SessionOptions,\n  SessionRequestObject,\n  RPCConnectResult,\n  JSONRPCRequest,\n  JSONRPCResponse,\n  WebSocketAdapter,\n  NodeSocketAdapter,\n  WebSocketClient,\n  SessionStatus,\n  SessionAuthError,\n} from './utils/interfaces'\nimport {\n  authErrorAction,\n  authSuccessAction,\n  socketMessageAction,\n  sessionDisconnectedAction,\n  sessionReconnectingAction,\n} from './redux/actions'\nimport { sessionActions } from './redux/features/session/sessionSlice'\n\nexport const SW_SYMBOL = Symbol('BaseSession')\n\nconst randomInt = (min: number, max: number) => {\n  return Math.floor(Math.random() * (max - min + 1) + min)\n}\nconst reconnectDelay = () => {\n  return randomInt(1, 4) * 1000\n}\n\nexport class BaseSession {\n  /** @internal */\n  public __sw_symbol = SW_SYMBOL\n\n  public uuid = uuid()\n  public WebSocketConstructor: NodeSocketAdapter | WebSocketAdapter\n  public agent: string\n  public connectVersion = DEFAULT_CONNECT_VERSION\n  public reauthenticate?(): Promise<void>\n\n  protected _rpcConnectResult: RPCConnectResult\n\n  private _requests = new Map<string, SessionRequestObject>()\n  private _socket: WebSocketClient | null = null\n  private _host: string = DEFAULT_HOST\n\n  private _executeTimeoutMs = 10 * 1000\n  private _executeTimeoutError = Symbol.for('sw-execute-timeout')\n  private _executeQueue: Set<JSONRPCRequest | JSONRPCResponse> = new Set()\n\n  private _checkPingDelay = 15 * 1000\n  private _checkPingTimer: any = null\n  private _reconnectTimer: ReturnType<typeof setTimeout>\n  private _status: SessionStatus = 'unknown'\n  private wsOpenHandler: (event: Event) => void\n  private wsCloseHandler: (event: CloseEvent) => void\n  private wsErrorHandler: (event: Event) => void\n\n  constructor(public options: SessionOptions) {\n    const { host, logLevel = 'info' } = options\n    if (host) {\n      this._host = checkWebSocketHost(host)\n    }\n\n    if (logLevel) {\n      /**\n       * `setLevel` only makes sense when dealing with our\n       * default logger. The error is expected because we\n       * don't expose `setLevel` as part of our public\n       * SDKLogger since there's no standard API across\n       * loggers to do this.\n       */\n      // @ts-expect-error\n      this.logger.setLevel?.(logLevel)\n    }\n    this._onSocketOpen = this._onSocketOpen.bind(this)\n    this._onSocketError = this._onSocketError.bind(this)\n    this._onSocketClose = this._onSocketClose.bind(this)\n    this._onSocketMessage = this._onSocketMessage.bind(this)\n    this.execute = this.execute.bind(this)\n    this.connect = this.connect.bind(this)\n\n    /** Listen on socket events once */\n    this.wsOpenHandler = (event) => {\n      this._socket?.removeEventListener('open', this.wsOpenHandler)\n      this._onSocketOpen(event)\n    }\n    this.wsCloseHandler = (event) => {\n      this._socket?.removeEventListener('close', this.wsCloseHandler)\n      this._onSocketClose(event)\n    }\n    this.wsErrorHandler = (event) => {\n      this._socket?.removeEventListener('error', this.wsErrorHandler)\n      this._onSocketError(event)\n    }\n  }\n\n  get host() {\n    return this._host\n  }\n\n  get rpcConnectResult() {\n    return this._rpcConnectResult\n  }\n\n  get relayProtocol() {\n    return this._rpcConnectResult?.protocol ?? ''\n  }\n\n  get signature() {\n    return this._rpcConnectResult?.authorization?.signature\n  }\n\n  protected get logger() {\n    return getLogger()\n  }\n\n  get connecting() {\n    return this._socket?.readyState === WebSocketState.CONNECTING\n  }\n\n  get connected() {\n    return this._socket?.readyState === WebSocketState.OPEN\n  }\n\n  get closing() {\n    return this._socket?.readyState === WebSocketState.CLOSING\n  }\n\n  get closed() {\n    return this._socket\n      ? this._socket.readyState === WebSocketState.CLOSED\n      : true\n  }\n\n  get status() {\n    return this._status\n  }\n\n  get idle() {\n    return this._status === 'idle'\n  }\n\n  get ready() {\n    return !Boolean(this.idle || !this.connected)\n  }\n\n  set token(token: string) {\n    this.options.token = token\n  }\n\n  /**\n   * Connect the websocket\n   *\n   * @return void\n   */\n  connect(): void {\n    if (!this?.WebSocketConstructor) {\n      throw new Error('Missing WebSocketConstructor')\n    }\n    this._clearTimers()\n    /**\n     * Return if already connecting or connected\n     * This prevents issues if \"connect()\" is called multiple times.\n     */\n    if (this.connecting || this.connected) {\n      this.logger.warn('Session already connected.')\n      return\n    }\n\n    /** In case of reconnect: remove listeners and then destroy it */\n    this._removeSocketListeners()\n    this.destroySocket()\n    this._clearCheckPingTimer()\n\n    this._socket = this._createSocket()\n    this._addSocketListeners()\n  }\n\n  /**\n   * Allow children classes to override it.\n   * @return WebSocket instance\n   */\n  protected _createSocket() {\n    return new this.WebSocketConstructor(this._host)\n  }\n\n  /** Allow children classes to override it. */\n  protected destroySocket() {\n    if (this._socket) {\n      this._socket.close()\n      this._socket = null\n    }\n  }\n\n  protected _addSocketListeners() {\n    if (!this._socket) {\n      return this.logger.debug('Invalid socket instance to add listeners')\n    }\n    this._removeSocketListeners()\n    this._socket.addEventListener('open', this.wsOpenHandler)\n    this._socket.addEventListener('close', this.wsCloseHandler)\n    this._socket.addEventListener('error', this.wsErrorHandler)\n    this._socket.addEventListener('message', this._onSocketMessage)\n  }\n\n  protected _removeSocketListeners() {\n    if (!this._socket) {\n      return this.logger.debug('Invalid socket instance to remove listeners')\n    }\n    this._socket.removeEventListener('open', this.wsOpenHandler)\n    this._socket.removeEventListener('close', this.wsCloseHandler)\n    this._socket.removeEventListener('error', this.wsErrorHandler)\n    this._socket.removeEventListener('message', this._onSocketMessage)\n  }\n\n  /**\n   * Clear the Session and close the WS connection.\n   * @return void\n   */\n  async disconnect() {\n    /**\n     * Return if there is not a _socket instance or\n     * if it's already in closing state.\n     */\n    if (!this._socket || this.closing) {\n      this.logger.debug('Session not connected or already in closing state.')\n      return\n    }\n\n    this._clearCheckPingTimer()\n    this._requests.clear()\n    this._closeConnection('disconnected')\n\n    /** sessionDisconnectedAction() will destroy the rootSaga too */\n    this.dispatch(sessionDisconnectedAction())\n  }\n\n  /**\n   * Send a JSON object to the server.\n   * @return Promise that will resolve/reject depending on the server response\n   */\n  execute(msg: JSONRPCRequest | JSONRPCResponse): Promise<any> {\n    // In case of a response don't wait for a result\n    let promise: Promise<unknown> = Promise.resolve()\n    if ('params' in msg) {\n      // This is a request so save the \"id\" to resolve the Promise later\n      promise = new Promise((resolve, reject) => {\n        this._requests.set(msg.id, { rpcRequest: msg, resolve, reject })\n      })\n    }\n\n    if (!this.ready) {\n      this._addToExecuteQueue(msg)\n      this.connect()\n\n      return promise\n    }\n\n    this._send(msg)\n\n    return timeoutPromise(\n      promise,\n      this._executeTimeoutMs,\n      this._executeTimeoutError\n    ).catch((error) => {\n      if (error === this._executeTimeoutError) {\n        this.logger.error('Request Timeout', msg)\n        if (this.status === 'disconnected') {\n          return this.logger.debug(\n            'Request failed because the session is disconnected',\n            this.status,\n            this._socket\n          )\n        }\n\n        // Possibly half-open connection so force close our side\n        this._closeConnection('reconnecting')\n      } else {\n        throw error\n      }\n    })\n  }\n\n  /**\n   * Authenticate with the SignalWire Network\n   * @return Promise<void>\n   */\n  async authenticate() {\n    const params: RPCConnectParams = {\n      agent: this.agent,\n      version: this.connectVersion,\n      authentication: {\n        project: this.options.project,\n        token: this.options.token,\n      },\n    }\n    if (this._relayProtocolIsValid()) {\n      params.protocol = this.relayProtocol\n    }\n    if (this.options.contexts?.length) {\n      params.contexts = this.options.contexts\n    }\n    this._rpcConnectResult = await this.execute(RPCConnect(params))\n  }\n\n  authError(error: SessionAuthError) {\n    /** Ignore WS events after the auth error and just disconnect */\n    this._removeSocketListeners()\n\n    this.dispatch(authErrorAction({ error }))\n  }\n\n  protected async _onSocketOpen(event: Event) {\n    this.logger.debug('_onSocketOpen', event.type)\n    try {\n      this._clearTimers()\n      await this.authenticate()\n      this._status = 'connected'\n      this._flushExecuteQueue()\n      this.dispatch(authSuccessAction())\n    } catch (error) {\n      this.logger.error('Auth Error', error)\n      this.authError(error)\n    }\n  }\n\n  protected _onSocketError(event: Event) {\n    this.logger.debug('_onSocketError', event)\n  }\n\n  protected _onSocketClose(event: CloseEvent) {\n    this.logger.debug('_onSocketClose', event.type, event.code, event.reason)\n    if (this._status !== 'disconnected') {\n      this._status = 'reconnecting'\n      this.dispatch(sessionReconnectingAction())\n      // yield put(pubSubChannel, sessionReconnectingAction())\n      this._clearTimers()\n      this._reconnectTimer = setTimeout(() => {\n        this.connect()\n      }, reconnectDelay())\n    }\n    this._socket = null\n  }\n\n  private _clearTimers() {\n    clearTimeout(this._reconnectTimer)\n  }\n\n  protected _onSocketMessage(event: MessageEvent) {\n    const payload = this.decode<JSONRPCRequest | JSONRPCResponse>(event.data)\n    this.logger.wsTraffic({ type: 'recv', payload })\n\n    if (isJSONRPCResponse(payload)) {\n      const request = this._requests.get(payload.id)\n      if (request) {\n        const { rpcRequest, resolve, reject } = request\n        this._requests.delete(payload.id)\n        const { result, error } = parseRPCResponse({\n          response: payload,\n          request: rpcRequest,\n        })\n        return error ? reject(error) : resolve(result)\n      }\n\n      return this.logger.warn('Unknown request for', payload)\n    }\n\n    switch (payload.method) {\n      case 'signalwire.ping':\n        return this._pingHandler(payload)\n      case 'signalwire.disconnect': {\n        /**\n         * Set this._status = 'idle' because the server\n         * will close the connection soon.\n         */\n        this.execute(RPCDisconnectResponse(payload.id))\n          .catch((error) => {\n            this.logger.error('SwDisconnect Error', error)\n          })\n          .finally(() => {\n            this._status = 'idle'\n          })\n        break\n      }\n      default:\n        // If it's not a response, trigger the dispatch.\n        this.dispatch(socketMessageAction(payload))\n        this._handleWebSocketMessage(payload)\n    }\n  }\n\n  protected _handleWebSocketMessage(\n    _payload: JSONRPCRequest | JSONRPCResponse\n  ) {\n    // no-op\n  }\n\n  public dispatch(_payload: PayloadAction<any>) {\n    throw new Error('Method not implemented')\n  }\n\n  /**\n   * Check the current relayProtocol against the signature\n   * to make sure is still valid.\n   * @return boolean\n   */\n  protected _relayProtocolIsValid() {\n    return (\n      this.signature && this?.relayProtocol?.split('_')[1] === this.signature\n    )\n  }\n\n  protected encode<T>(input: T): Parameters<WebSocketClient['send']>[0] {\n    return JSON.stringify(input)\n  }\n\n  protected decode<T>(input: any): T {\n    return safeParseJson(input)\n  }\n\n  private _send(msg: JSONRPCRequest | JSONRPCResponse) {\n    this.logger.wsTraffic({ type: 'send', payload: msg })\n    this._socket!.send(this.encode(msg))\n  }\n\n  private _addToExecuteQueue(msg: JSONRPCRequest | JSONRPCResponse) {\n    this.logger.warn('Request queued waiting for session to reconnect', msg)\n    this._executeQueue.add(msg)\n  }\n\n  private _flushExecuteQueue() {\n    if (!this._executeQueue.size) {\n      return\n    }\n    if (!this.ready) {\n      this.logger.warn(`Session not ready to flush the queue.`)\n      this._closeConnection('reconnecting')\n      return\n    }\n    this.logger.debug(`${this._executeQueue.size} messages to flush`)\n    this._executeQueue.forEach((msg) => {\n      this._send(msg)\n      this._executeQueue.delete(msg)\n    })\n    this._executeQueue.clear()\n  }\n\n  private _clearCheckPingTimer() {\n    clearTimeout(this._checkPingTimer)\n  }\n\n  private async _pingHandler(payload: JSONRPCRequest) {\n    this._clearCheckPingTimer()\n    this._checkPingTimer = setTimeout(() => {\n      // Possibly half-open connection so force close our side\n      this.logger.debug('Timeout waiting for ping')\n      this._closeConnection('reconnecting')\n    }, this._checkPingDelay)\n\n    await this.execute(RPCPingResponse(payload.id, payload?.params?.timestamp))\n  }\n\n  private _closeConnection(\n    status: Extract<SessionStatus, 'reconnecting' | 'disconnected'>\n  ) {\n    this._clearCheckPingTimer()\n    this.logger.debug('Close Connection')\n    this._status = status\n    this.dispatch(\n      sessionActions.authStatus(\n        status === 'disconnected' ? 'unauthorized' : 'unknown'\n      )\n    )\n    this.destroySocket()\n  }\n}\n", "import {\n  RPCConnect,\n  RPCConnectParams,\n  RPCReauthenticate,\n  RPCReauthenticateParams,\n} from './RPCMessages'\nimport { SessionOptions } from './utils/interfaces'\nimport { BaseSession } from './BaseSession'\nimport { authExpiringAction } from './redux/actions'\n\nexport class BaseJWTSession extends BaseSession {\n  /**\n   * Can be set a value different then zero\n   * to force the JWT as expired within X seconds.\n   * TODO: Remove this workaround.\n   */\n  private _expiredDiffSeconds = 0\n  private _refreshTokenNotificationDiff = 120\n  /**\n   * Check the JWT expiration every 20seconds\n   */\n  private _checkTokenExpirationDelay = 20 * 1000\n  private _checkTokenExpirationTimer: any = null\n\n  constructor(public options: SessionOptions) {\n    super(options)\n\n    this._checkTokenExpiration = this._checkTokenExpiration.bind(this)\n    this.reauthenticate = this.reauthenticate.bind(this)\n  }\n\n  get expiresAt() {\n    const expiresAt = this?._rpcConnectResult?.authorization?.expires_at ?? 0\n    if (typeof expiresAt === 'string') {\n      const parsed = Date.parse(expiresAt)\n      if (!isNaN(parsed)) {\n        return Math.floor(parsed / 1000)\n      }\n    }\n    return expiresAt\n  }\n\n  get expiresIn() {\n    const now = Math.floor(Date.now() / 1000)\n    return this.expiresAt - now\n  }\n\n  get expired() {\n    return this.expiresAt > 0 && this.expiresIn <= this._expiredDiffSeconds\n  }\n\n  /**\n   * Authenticate with the SignalWire Network\n   * using JWT\n   * @return Promise<void>\n   */\n  async authenticate() {\n    const params: RPCConnectParams = {\n      agent: this.agent,\n      version: this.connectVersion,\n      authentication: {\n        jwt_token: this.options.token,\n      },\n    }\n\n    if (this._relayProtocolIsValid()) {\n      params.protocol = this.relayProtocol\n    } else {\n      /**\n       * TODO: Find out a better way to get the prevProtocol\n       */\n      const prevProtocol = await this.retrieveRelayProtocol()\n      if (prevProtocol) {\n        params.protocol = prevProtocol\n      }\n    }\n\n    this._rpcConnectResult = await this.execute(RPCConnect(params))\n    await this.persistRelayProtocol()\n    this._checkTokenExpiration()\n  }\n\n  async retrieveRelayProtocol() {\n    // no-op\n    return ''\n  }\n\n  async persistRelayProtocol() {\n    // no-op\n  }\n\n  /**\n   * Reauthenticate with the SignalWire Network\n   * using a newer JWT. If the session has expired\n   * will reconnect it.\n   * @return Promise<void>\n   */\n  async reauthenticate() {\n    this.logger.debug('Session Reauthenticate', {\n      ready: this.ready,\n      expired: this.expired,\n    })\n    if (!this.ready || this.expired) {\n      return this.connect()\n    }\n\n    const params: RPCReauthenticateParams = {\n      project: this._rpcConnectResult.authorization.project,\n      jwt_token: this.options.token,\n    }\n\n    try {\n      this._rpcConnectResult = await this.execute(RPCReauthenticate(params))\n    } catch (error) {\n      clearTimeout(this._checkTokenExpirationTimer)\n      throw error\n    }\n  }\n\n  protected override _onSocketClose(event: CloseEvent) {\n    clearTimeout(this._checkTokenExpirationTimer)\n    super._onSocketClose(event)\n  }\n\n  /**\n   * Set a timer to dispatch a notification when the JWT is going to expire.\n   * @return void\n   */\n  protected _checkTokenExpiration() {\n    if (!this.expiresAt) {\n      return\n    }\n    if (this.expiresIn <= this._refreshTokenNotificationDiff) {\n      this.dispatch(authExpiringAction())\n\n      if (this.options._onRefreshToken) {\n        this.options._onRefreshToken()\n      } else {\n        this.logger.warn('The token is going to expire!')\n      }\n    }\n    clearTimeout(this._checkTokenExpirationTimer)\n    if (!this.expired) {\n      this._checkTokenExpirationTimer = setTimeout(\n        this._checkTokenExpiration,\n        this._checkTokenExpirationDelay\n      )\n    }\n  }\n}\n", "import { Store } from 'redux'\nimport createSagaMiddleware, {\n  multicastChannel,\n  Saga,\n  Task,\n} from '@redux-saga/core'\nimport { configureStore as rtConfigureStore } from './toolkit'\nimport { rootReducer } from './rootReducer'\nimport rootSaga from './rootSaga'\nimport { PubSubChannel, SDKState, SwEventChannel } from './interfaces'\nimport { connect } from './connect'\nimport {\n  InternalUserOptions,\n  SessionConstructor,\n  InternalChannels,\n} from '../utils/interfaces'\n\nexport interface ConfigureStoreOptions {\n  userOptions: InternalUserOptions\n  SessionConstructor: SessionConstructor\n  runSagaMiddleware?: boolean\n  preloadedState?: Partial<SDKState>\n}\n\nexport type SDKStore = ReturnType<typeof configureStore>\nexport type SDKRunSaga = <S extends Saga>(\n  saga: S,\n  params?: Parameters<S>[0]\n) => Task\n\nconst configureStore = (options: ConfigureStoreOptions) => {\n  const {\n    userOptions,\n    SessionConstructor,\n    preloadedState = {},\n    runSagaMiddleware = true,\n  } = options\n  const sagaMiddleware = createSagaMiddleware()\n  const pubSubChannel: PubSubChannel = multicastChannel()\n  const swEventChannel: SwEventChannel = multicastChannel()\n  /**\n   * List of channels that are gonna be shared across all\n   * sagas.\n   */\n  const channels: InternalChannels = {\n    pubSubChannel,\n    swEventChannel,\n  }\n  const store = rtConfigureStore({\n    devTools: userOptions?.devTools ?? true,\n    reducer: rootReducer,\n    preloadedState,\n    middleware: (getDefaultMiddleware) =>\n      // It is preferrable to use the chainable .concat(...) and\n      // .prepend(...) methods of the returned MiddlewareArray instead\n      // of the array spread operator, as the latter can lose valuable\n      // type information under some circumstances.\n      // @see https://redux-toolkit.js.org/api/getDefaultMiddleware#intended-usage\n      getDefaultMiddleware().concat(sagaMiddleware),\n  }) as Store\n  const runSaga = <T>(\n    saga: Saga,\n    args: {\n      instance: T\n      runSaga: any\n    }\n  ) => {\n    return sagaMiddleware.run(saga, {\n      ...args,\n      channels,\n    })\n  }\n\n  if (runSagaMiddleware) {\n    const saga = rootSaga({\n      SessionConstructor,\n    })\n    sagaMiddleware.run(saga, { userOptions, channels })\n  }\n\n  return {\n    ...store,\n    runSaga,\n  }\n}\n\nexport { connect, configureStore }\nexport * from './actions'\nexport * from './utils/sagaHelpers'\nexport * from './toolkit'\n", "import { createDestroyableSlice } from '../../utils/createDestroyableSlice'\nimport type { PayloadAction } from '../../toolkit'\nimport type { JSONRPCResponse } from '../../../utils/interfaces'\nimport type { ComponentState, ReduxComponent } from '../../interfaces'\nimport type { DeepReadonly } from '../../../types'\n\nexport const initialComponentState: DeepReadonly<ComponentState> = {\n  byId: {},\n}\n\ntype UpdateComponent = Partial<ReduxComponent> & Pick<ReduxComponent, 'id'>\ntype CleanupComponentParams = {\n  ids: Array<ReduxComponent['id']>\n}\n\ntype SuccessParams = {\n  componentId: string\n  requestId: string\n  response: JSONRPCResponse\n}\ntype FailureParams = {\n  componentId: string\n  requestId: string\n  error: JSONRPCResponse\n  action: any\n}\n\nconst requestUpdater = <T>({\n  state,\n  payload,\n  componentId,\n  key,\n  requestId,\n}: {\n  state: DeepReadonly<ComponentState>\n  payload: T\n  componentId: string\n  key: 'responses' | 'errors'\n  requestId: string\n}): DeepReadonly<ComponentState> => {\n  if (componentId in state.byId) {\n    return {\n      ...state,\n      byId: {\n        ...state.byId,\n        [componentId]: {\n          ...state.byId[componentId],\n          [key]: {\n            ...state.byId[componentId][key],\n            [requestId]: payload,\n          },\n        },\n      },\n    }\n  } else {\n    return {\n      ...state,\n      byId: {\n        ...state.byId,\n        [componentId]: {\n          id: componentId,\n          [key]: {\n            [requestId]: payload,\n          },\n        },\n      },\n    }\n  }\n}\n\nconst componentSlice = createDestroyableSlice({\n  name: 'components',\n  initialState: initialComponentState,\n  reducers: {\n    upsert: (state, { payload }: PayloadAction<UpdateComponent>) => {\n      if (payload.id in state.byId) {\n        return {\n          ...state,\n          byId: {\n            ...state.byId,\n            [payload.id]: {\n              ...state.byId[payload.id],\n              ...payload,\n            },\n          },\n        }\n      } else {\n        return {\n          ...state,\n          byId: {\n            ...state.byId,\n            [payload.id]: payload,\n          },\n        }\n      }\n    },\n    executeSuccess: (state, { payload }: PayloadAction<SuccessParams>) => {\n      const { componentId, requestId, response } = payload\n      return requestUpdater({\n        componentId,\n        requestId,\n        state,\n        key: 'responses',\n        payload: response,\n      })\n    },\n    executeFailure: (state, { payload }: PayloadAction<FailureParams>) => {\n      const { componentId, requestId, error, action } = payload\n      return requestUpdater({\n        componentId,\n        requestId,\n        state,\n        key: 'errors',\n        payload: {\n          action,\n          jsonrpc: error,\n        },\n      })\n    },\n    cleanup: (state, { payload }: PayloadAction<CleanupComponentParams>) => {\n      return {\n        ...state,\n        byId: Object.entries(state.byId).reduce(\n          (reducer, [componentId, value]) => {\n            if (!payload.ids.includes(componentId)) {\n              reducer[componentId] = value\n            }\n\n            return reducer\n          },\n          {} as ComponentState['byId']\n        ),\n      }\n    },\n  },\n})\n\n// prettier-ignore\nexport const {\n  actions: componentActions,\n  reducer: componentReducer\n} = componentSlice\n", "import { createDestroyableSlice } from '../../utils/createDestroyableSlice'\nimport type { PayloadAction } from '../../toolkit'\nimport type { ExecuteQueueState, ExecuteActionParams } from '../../interfaces'\nimport type { DeepReadonly } from '../../../types'\n\nexport const initialExecuteQueueState: DeepReadonly<ExecuteQueueState> = {\n  queue: [],\n}\n\nconst executeQueueSlice = createDestroyableSlice({\n  name: 'executeQueue',\n  initialState: initialExecuteQueueState,\n  reducers: {\n    add: (state, { payload }: PayloadAction<ExecuteActionParams>) => {\n      // TODO: Do we have to check for something (like an item in\n      // queue with the same `payload.method`?) before adding the\n      // payload to the queue?\n      return {\n        ...state,\n        queue: state.queue.concat(payload)\n      }\n    },\n    clean: () => {\n      return initialExecuteQueueState\n    },\n  },\n})\n\n// prettier-ignore\nexport const {\n  actions: executeQueueActions,\n  reducer: executeQueueReducer\n} = executeQueueSlice\n", "import { combineReducers } from './toolkit'\nimport {\n  componentReducer,\n  sessionReducer,\n  executeQueueReducer,\n} from './features'\n\nexport const rootReducer = combineReducers({\n  components: componentReducer,\n  session: sessionReducer,\n  executeQueue: executeQueueReducer,\n})\n", "import type { Task, SagaIterator } from '@redux-saga/types'\nimport { EventChannel } from '@redux-saga/core'\nimport { fork, call, take, put, all, cancelled } from '@redux-saga/core/effects'\nimport {\n  SessionConstructor,\n  InternalUserOptions,\n  InternalChannels,\n} from '../utils/interfaces'\nimport { getLogger, setDebugOptions, setLogger } from '../utils'\nimport { BaseSession } from '../BaseSession'\nimport {\n  executeActionWatcher,\n  sessionChannelWatcher,\n  createSessionChannel,\n} from './features/session/sessionSaga'\nimport { pubSubSaga } from './features/pubSub/pubSubSaga'\nimport {\n  initAction,\n  destroyAction,\n  sessionReconnectingAction,\n  sessionDisconnectedAction,\n  sessionConnectedAction,\n  sessionAuthErrorAction,\n  sessionExpiringAction,\n  reauthAction,\n} from './actions'\nimport { sessionActions } from './features'\nimport {\n  authErrorAction,\n  authSuccessAction,\n  authExpiringAction,\n} from './actions'\nimport { AuthError } from '../CustomErrors'\nimport { PubSubChannel } from './interfaces'\nimport { createRestartableSaga } from './utils/sagaHelpers'\n// import { componentCleanupSaga } from './features/component/componentSaga'\n\ninterface StartSagaOptions {\n  session: BaseSession\n  sessionChannel: EventChannel<unknown>\n  pubSubChannel: PubSubChannel\n  userOptions: InternalUserOptions\n}\n\nexport function* initSessionSaga({\n  SessionConstructor,\n  userOptions,\n  channels,\n}: {\n  SessionConstructor: SessionConstructor\n  userOptions: InternalUserOptions\n  channels: InternalChannels\n}): SagaIterator {\n  const session = new SessionConstructor(userOptions)\n\n  const sessionChannel: EventChannel<unknown> = yield call(\n    createSessionChannel,\n    session\n  )\n\n  /**\n   * Channel to communicate between sagas and emit events to\n   * the public\n   */\n  const pubSubChannel = channels.pubSubChannel\n  /**\n   * Channel to broadcast all the events sent by the server\n   */\n  const swEventChannel = channels.swEventChannel\n\n  /**\n   * Start all the custom workers on startup\n   */\n  let customTasks: Task[] = []\n  if (userOptions.workers?.length) {\n    try {\n      const effects = userOptions.workers.map((saga) => {\n        return call(createRestartableSaga(saga))\n      })\n      customTasks = yield all(effects)\n    } catch (error) {\n      getLogger().error('Error running custom workers', error)\n    }\n  }\n\n  yield fork(sessionChannelWatcher, {\n    sessionChannel,\n    pubSubChannel,\n    swEventChannel,\n  })\n\n  /**\n   * Fork the watcher for the pubSubChannel\n   */\n  const pubSubTask: Task = yield fork(pubSubSaga, {\n    pubSubChannel,\n    emitter: userOptions.emitter!,\n  })\n\n  /**\n   * Fork the watcher for the session status\n   */\n  const sessionStatusTask: Task = yield fork(sessionStatusWatcher, {\n    session,\n    sessionChannel,\n    pubSubChannel,\n    userOptions,\n  })\n\n  /**\n   * Fork the watcher for all the execute requests\n   */\n  const executeActionTask: Task = yield fork(executeActionWatcher, session)\n\n  // const compCleanupTask = yield fork(componentCleanupSaga)\n\n  session.connect()\n\n  yield take(destroyAction.type)\n\n  /**\n   * We have to manually cancel the fork because it is not\n   * being automatically cleaned up when the session is\n   * destroyed, most likely because it's using a timer.\n   */\n  // compCleanupTask?.cancel()\n  pubSubTask.cancel()\n  sessionStatusTask.cancel()\n  executeActionTask.cancel()\n  sessionChannel.close()\n  customTasks.forEach((task) => task.cancel())\n  /**\n   * Do not close pubSubChannel and swEventChannel\n   * since we may need them again in case of reauth/reconnect\n   * // pubSubChannel.close()\n   * // swEventChannel.close()\n   */\n}\n\nexport function* reauthenticateWorker({\n  session,\n  token,\n  pubSubChannel,\n}: {\n  session: BaseSession\n  token: string\n  pubSubChannel: PubSubChannel\n}) {\n  try {\n    if (session.reauthenticate) {\n      session.token = token\n      yield call(session.reauthenticate)\n      // Update the store with the new \"connect result\"\n      yield put(sessionActions.connected(session.rpcConnectResult))\n      yield put(pubSubChannel, sessionConnectedAction())\n    }\n  } catch (error) {\n    getLogger().error('Reauthenticate Error', error)\n    session.authError(error)\n  }\n}\n\nexport function* sessionStatusWatcher(options: StartSagaOptions): SagaIterator {\n  getLogger().debug('sessionStatusWatcher [started]')\n\n  try {\n    while (true) {\n      const action = yield take([\n        authSuccessAction.type,\n        authErrorAction.type,\n        authExpiringAction.type,\n        reauthAction.type,\n        sessionReconnectingAction.type,\n        sessionDisconnectedAction.type,\n      ])\n\n      getLogger().debug('sessionStatusWatcher', action.type, action.payload)\n      switch (action.type) {\n        case authSuccessAction.type: {\n          const { session, pubSubChannel } = options\n          yield put(sessionActions.connected(session.rpcConnectResult))\n          yield put(pubSubChannel, sessionConnectedAction())\n          break\n        }\n        case authErrorAction.type: {\n          yield fork(sessionAuthErrorSaga, {\n            ...options,\n            action,\n          })\n          break\n        }\n        case authExpiringAction.type: {\n          yield put(options.pubSubChannel, sessionExpiringAction())\n          break\n        }\n        case reauthAction.type: {\n          yield fork(reauthenticateWorker, {\n            session: options.session,\n            token: action.payload.token,\n            pubSubChannel: options.pubSubChannel,\n          })\n          break\n        }\n        case sessionReconnectingAction.type: {\n          yield put(options.pubSubChannel, sessionReconnectingAction())\n          break\n        }\n        case sessionDisconnectedAction.type: {\n          yield put(options.pubSubChannel, sessionDisconnectedAction())\n          yield put(destroyAction())\n          break\n        }\n      }\n    }\n  } finally {\n    if (yield cancelled()) {\n      getLogger().debug('sessionStatusWatcher [cancelled]')\n    }\n  }\n}\n\ninterface SessionAuthErrorOptions extends StartSagaOptions {\n  action: any\n}\nexport function* sessionAuthErrorSaga(\n  options: SessionAuthErrorOptions\n): SagaIterator {\n  getLogger().debug('sessionAuthErrorSaga [started]')\n\n  try {\n    const { pubSubChannel, action } = options\n    const { error: authError } = action.payload\n    const error = authError\n      ? new AuthError(authError.code, authError.message)\n      : new Error('Unauthorized')\n\n    yield put(pubSubChannel, sessionAuthErrorAction(error))\n  } finally {\n    if (yield cancelled()) {\n      getLogger().debug('sessionAuthErrorSaga [cancelled]')\n    }\n  }\n}\n\ninterface RootSagaOptions {\n  SessionConstructor: SessionConstructor\n}\n\nexport default (options: RootSagaOptions) => {\n  return function* root({\n    userOptions,\n    channels,\n  }: {\n    userOptions: InternalUserOptions\n    channels: InternalChannels\n  }): SagaIterator {\n    if (userOptions.logger) {\n      setLogger(userOptions.logger)\n    }\n    if (userOptions.debug) {\n      setDebugOptions(userOptions.debug)\n    }\n\n    while (true) {\n      /**\n       * Wait for an initAction to start\n       */\n      const action = yield take([initAction.type, reauthAction.type])\n\n      /**\n       * Update token only if the action contains a `token`\n       * (case of reauthAction with a new token)\n       */\n      if (action?.payload?.token) {\n        userOptions.token = action.payload.token\n      }\n\n      /**\n       * Create Session and related sessionChannel to\n       * send/receive websocket messages\n       */\n      try {\n        yield call(initSessionSaga, {\n          ...options,\n          userOptions,\n          channels,\n        })\n      } catch (error) {\n        getLogger().error('RootSaga Error:', error)\n      } finally {\n        if (yield cancelled()) {\n          getLogger().debug('rootSaga [cancelled]')\n        }\n        getLogger().debug('Reboot rootSaga')\n      }\n    }\n  }\n}\n", "import { SagaIterator, eventChannel, EventChannel } from '@redux-saga/core'\nimport { call, put, take, fork, cancelled } from '@redux-saga/core/effects'\nimport type { PayloadAction } from '../../toolkit'\nimport { BaseSession } from '../../../BaseSession'\nimport { JSONRPCRequest, JSONRPCResponse } from '../../../utils/interfaces'\nimport type {\n  VideoAPIEventParams,\n  SwEventParams,\n  WebRTCMessageParams,\n  MemberTalkingEventNames,\n} from '../../../types'\nimport type {\n  ExecuteActionParams,\n  PubSubChannel,\n  SwEventChannel,\n} from '../../interfaces'\nimport { createCatchableSaga } from '../../utils/sagaHelpers'\nimport { executeAction, socketMessageAction } from '../../actions'\nimport { componentActions } from '../'\nimport { RPCExecute } from '../../../RPCMessages'\nimport { getLogger, toInternalAction } from '../../../utils'\n\ntype SessionSagaParams = {\n  sessionChannel: EventChannel<unknown>\n  pubSubChannel: PubSubChannel\n  swEventChannel: SwEventChannel\n}\n\n// TODO: Move TypeGuards to its own module\nconst isWebrtcEvent = (e: SwEventParams): e is WebRTCMessageParams => {\n  return e?.event_type === 'webrtc.message'\n}\nconst isVideoEvent = (e: SwEventParams): e is VideoAPIEventParams => {\n  return !!e?.event_type?.startsWith('video.')\n}\n\n/**\n * Watch every \"executeAction\" and fork the worker to send\n * a JSONRPC over the wire and then update the state\n * with \"componentActions.executeSuccess\" or \"componentActions.executeFailure\"\n * actions if a componentId is provided.\n */\nexport function* executeActionWatcher(session: BaseSession): SagaIterator {\n  function* worker(action: PayloadAction<ExecuteActionParams>): SagaIterator {\n    const { componentId, requestId, method, params } = action.payload\n    try {\n      const message = RPCExecute({\n        id: requestId,\n        method,\n        params,\n      })\n      const response = yield call(session.execute, message)\n      if (componentId && requestId) {\n        yield put(\n          componentActions.executeSuccess({\n            componentId,\n            requestId,\n            response,\n          })\n        )\n      }\n    } catch (error) {\n      getLogger().warn('Execute error:', error)\n      if (componentId && requestId) {\n        yield put(\n          componentActions.executeFailure({\n            componentId,\n            requestId,\n            action,\n            error,\n          })\n        )\n      }\n    } finally {\n      const isCancelled = yield cancelled()\n\n      if (isCancelled && componentId && requestId) {\n        const error: JSONRPCResponse = {\n          jsonrpc: '2.0',\n          id: requestId,\n          error: {\n            // Invalid Request\n            code: -32600,\n            message: 'Cancelled task',\n          },\n        }\n        getLogger().debug('executeActionWorker cancelled', {\n          requestId,\n          componentId,\n          error,\n        })\n        yield put(\n          componentActions.executeFailure({\n            componentId,\n            requestId,\n            action,\n            error,\n          })\n        )\n      }\n    }\n  }\n\n  while (true) {\n    const action = yield take(executeAction.type)\n    yield fork(worker, action)\n  }\n}\n\nexport function* sessionChannelWatcher({\n  sessionChannel,\n  pubSubChannel,\n  swEventChannel,\n}: SessionSagaParams): SagaIterator {\n  function* videoAPIWorker(params: VideoAPIEventParams): SagaIterator {\n    switch (params.event_type) {\n      case 'video.room.audience_count': {\n        /** Rename event to be camelCase */\n        yield put(pubSubChannel, {\n          type: 'video.room.audienceCount',\n          payload: params.params,\n        })\n        return\n      }\n      case 'video.member.updated': {\n        /**\n         * @see memberUpdatedWorker in packages/core/src/memberPosition/workers.ts\n         * `video.member.updated` is handled by the\n         * layoutWorker so to avoid dispatching the event\n         * twice (or with incomplete data) we'll early\n         * return.\n         */\n        return\n      }\n      case 'video.member.talking': {\n        const { member } = params.params\n        if ('talking' in member) {\n          const suffix = member.talking ? 'started' : 'ended'\n          yield put(pubSubChannel, {\n            type: `video.member.talking.${suffix}` as MemberTalkingEventNames,\n            payload: params.params,\n          })\n          // Keep for backwards compat.\n          const deprecatedSuffix = member.talking ? 'start' : 'stop'\n          yield put(pubSubChannel, {\n            type: `video.member.talking.${deprecatedSuffix}` as MemberTalkingEventNames,\n            payload: params.params,\n          })\n        }\n        break\n      }\n    }\n\n    // Emit on the pubSubChannel this \"event_type\"\n    yield put(pubSubChannel, {\n      type: params.event_type,\n      // @ts-expect-error\n      payload: params.params,\n    })\n  }\n\n  function* swEventWorker(broadcastParams: SwEventParams) {\n    yield put(swEventChannel, toInternalAction(broadcastParams))\n\n    if (isWebrtcEvent(broadcastParams)) {\n      /**\n       * Skip `webrtc.message` events.\n       * There are custom workers handling them through `swEventChannel`\n       */\n      return\n    }\n    if (isVideoEvent(broadcastParams)) {\n      yield fork(videoAPIWorker, broadcastParams)\n      return\n    }\n\n    /**\n     * Put actions with `event_type` to trigger all the children sagas\n     * This should replace all the isWebrtcEvent/isVideoEvent guards below\n     * since we'll move that logic on a separate package.\n     */\n    yield put({ type: broadcastParams.event_type, payload: broadcastParams })\n  }\n\n  function* sessionChannelWorker(\n    action: PayloadAction<JSONRPCRequest>\n  ): SagaIterator {\n    if (action.type !== socketMessageAction.type) {\n      yield put(action)\n      return\n    }\n    const { method, params } = action.payload\n\n    switch (method) {\n      case 'signalwire.event':\n        yield fork(swEventWorker, params as SwEventParams)\n        break\n      default:\n        return getLogger().debug(`Unknown message: ${method}`, action)\n    }\n  }\n  const sessionChannelWorkerCatchable = createCatchableSaga<\n    PayloadAction<JSONRPCRequest>\n  >(sessionChannelWorker, (error) => {\n    getLogger().error('Channel Error', error)\n  })\n\n  /**\n   * Make the watcher restartable\n   */\n  while (true) {\n    try {\n      while (true) {\n        const action = yield take(sessionChannel)\n        yield fork(sessionChannelWorkerCatchable, action)\n      }\n    } catch (error) {\n      getLogger().error('sessionChannelWorker error:', error)\n    } finally {\n      getLogger().debug('sessionChannelWorker finally')\n    }\n  }\n}\n\nexport function createSessionChannel(session: BaseSession) {\n  return eventChannel((emit) => {\n    session.dispatch = (payload: PayloadAction<any>) => {\n      emit(payload)\n    }\n\n    // this will be invoked when the saga calls `channel.close()` method\n    const unsubscribe = () => {\n      getLogger().debug('sessionChannel unsubscribe')\n      session.disconnect()\n    }\n\n    return unsubscribe\n  })\n}\n", "import { Saga } from '@redux-saga/core'\nimport { call, spawn } from '@redux-saga/core/effects'\nimport { getLogger } from '../../utils'\n\nexport const createRestartableSaga = (saga: Saga) => {\n  return function* () {\n    spawn(function* () {\n      while (true) {\n        try {\n          getLogger().debug('Run a restartable saga')\n          yield call(saga)\n          getLogger().debug(\n            'One of the restartable saga has ended. Restarting..'\n          )\n        } catch (error) {\n          getLogger().error('Restartable Saga Error', error)\n        }\n      }\n    })\n  }\n}\n\nconst defaultCatchHandler = (error: any) =>\n  getLogger().error('Catchable Saga Error', error)\n\nexport const createCatchableSaga = <Args = any>(\n  saga: Saga,\n  errorHandler = defaultCatchHandler\n) => {\n  return function* (...params: Args[]) {\n    try {\n      yield call(saga, ...params)\n    } catch (error) {\n      errorHandler(error)\n    }\n  }\n}\n\nexport { eventChannel } from '@redux-saga/core'\n", "import { SagaIterator } from '@redux-saga/core'\nimport { take, cancelled } from '@redux-saga/core/effects'\nimport {\n  isInternalGlobalEvent,\n  toInternalEventName,\n  getLogger,\n} from '../../../utils'\nimport type { EventEmitter } from '../../../utils/EventEmitter'\nimport type { PubSubChannel, PubSubAction } from '../../interfaces'\nimport { findNamespaceInPayload } from '../shared/namespace'\n\ntype PubSubSagaParams = {\n  pubSubChannel: PubSubChannel\n  emitter: EventEmitter<string>\n}\n\nexport function* pubSubSaga({\n  pubSubChannel,\n  emitter,\n}: PubSubSagaParams): SagaIterator<any> {\n  getLogger().debug('pubSubSaga [started]')\n\n  try {\n    while (true) {\n      const pubSubAction: PubSubAction = yield take(pubSubChannel, '*')\n      const { type, payload } = pubSubAction\n      try {\n        const namespace = findNamespaceInPayload(pubSubAction)\n        /**\n         * There are events (like `video.room.started`/`video.room.ended`) that can\n         * be consumed from different places, like from a `roomObj`\n         * (namespaced Event Emitter) or from a `client`\n         * (non-namespaced/global Event Emitter) so we must trigger the\n         * event twice to reach everyone.\n         */\n        if (isInternalGlobalEvent(type)) {\n          emitter.emit(type, payload)\n        }\n\n        getLogger().trace(\n          'Emit:',\n          toInternalEventName<string>({ namespace, event: type })\n        )\n        emitter.emit(\n          toInternalEventName<string>({ namespace, event: type }),\n          payload\n        )\n      } catch (error) {\n        getLogger().error(error)\n      }\n    }\n  } finally {\n    if (yield cancelled()) {\n      getLogger().debug('pubSubSaga [cancelled]')\n    }\n  }\n}\n", "import type {\n  ChatEvent,\n  InternalVideoMemberEvent,\n  InternalVideoRoomEvent,\n  VideoLayoutEvent,\n  VideoMemberEvent,\n  VideoPlaybackEvent,\n  VideoRecordingEvent,\n  VideoRoomEvent,\n  VideoRoomAudienceCountEvent,\n  VoiceCallEvent,\n  InternalVideoRoomAudienceCountEvent,\n  VideoStreamEvent,\n} from '../../../types'\nimport { getLogger } from '../../../utils'\nimport type { MapToPubSubShape, PubSubAction } from '../../interfaces'\n\nconst isVideoMemberEvent = (\n  action: PubSubAction\n): action is MapToPubSubShape<VideoMemberEvent | InternalVideoMemberEvent> => {\n  return (\n    action.type.startsWith('video.member.') ||\n    // TODO: find a better way to do this check.\n    action.type.startsWith('video.__synthetic__.member')\n  )\n}\n\nconst isVideoRoomEvent = (\n  action: PubSubAction\n): action is MapToPubSubShape<VideoRoomEvent | InternalVideoRoomEvent> => {\n  return action.type.startsWith('video.room.')\n}\n\nconst isVideoRoomAudienceCountEvent = (\n  action: PubSubAction\n): action is MapToPubSubShape<\n  VideoRoomAudienceCountEvent | InternalVideoRoomAudienceCountEvent\n> => {\n  return (\n    action.type === 'video.room.audience_count' ||\n    action.type === 'video.room.audienceCount'\n  )\n}\n\nconst isVideoLayoutEvent = (\n  action: PubSubAction\n): action is MapToPubSubShape<VideoLayoutEvent> => {\n  return action.type.startsWith('video.layout.')\n}\n\nconst isVideoRecordingEvent = (\n  action: PubSubAction\n): action is MapToPubSubShape<VideoRecordingEvent> => {\n  return action.type.startsWith('video.recording.')\n}\n\nconst isVideoPlaybackEvent = (\n  action: PubSubAction\n): action is MapToPubSubShape<VideoPlaybackEvent> => {\n  return action.type.startsWith('video.playback.')\n}\n\nconst isVideoStreamEvent = (\n  action: PubSubAction\n): action is MapToPubSubShape<VideoStreamEvent> => {\n  return action.type.startsWith('video.stream.')\n}\n\nconst isChatEvent = (\n  action: PubSubAction\n): action is MapToPubSubShape<ChatEvent> => {\n  return action.type.startsWith('chat.')\n}\n\nconst isVoiceCallEvent = (\n  action: PubSubAction\n): action is MapToPubSubShape<VoiceCallEvent> => {\n  return action.type.startsWith('calling.')\n}\n\nexport const findNamespaceInPayload = (action: PubSubAction): string => {\n  if (action.payload === undefined) {\n    return ''\n  } else if (\n    isVideoMemberEvent(action) ||\n    isVideoLayoutEvent(action) ||\n    isVideoRecordingEvent(action) ||\n    isVideoPlaybackEvent(action) ||\n    isVideoStreamEvent(action) ||\n    isVideoRoomAudienceCountEvent(action)\n  ) {\n    return action.payload.room_session_id\n  } else if (isVideoRoomEvent(action)) {\n    return action.payload.room_session.id\n  } else if (isChatEvent(action)) {\n    return ''\n  } else if (isVoiceCallEvent(action)) {\n    /**\n     * Some calling events (ie: `calling.call.receive`) have no \"tag\"\n     * but we inject it within the workers before put the action.\n     * See voiceCallPlayWorker as an example.\n     */\n    // @ts-expect-error\n    return action.payload.tag ?? ''\n  }\n\n  if ('development' === process.env.NODE_ENV) {\n    getLogger().info(\n      'Namespace not found for action.type: ',\n      (action as any)?.type\n    )\n  }\n\n  return ''\n}\n", "export class AuthError extends Error {\n  name = 'AuthError'\n\n  constructor(public code: number, public message: string) {\n    super(message)\n    Object.setPrototypeOf(this, AuthError.prototype)\n  }\n}\n\nexport class HttpError extends Error {\n  name = 'HttpError'\n\n  constructor(\n    public code: number,\n    public message: string,\n    public response?: Record<string, any>\n  ) {\n    super(message)\n    Object.setPrototypeOf(this, HttpError.prototype)\n  }\n}\n", "import { ReduxComponent, SDKState } from '../../interfaces'\n\nexport const getComponent = ({ components }: SDKState, id: string) => {\n  return components.byId?.[id]\n}\n\nexport const getComponentsById = ({ components }: SDKState) => {\n  return components.byId\n}\n\nexport const getComponentsToCleanup = (state: SDKState) => {\n  const components = getComponentsById(state)\n\n  let toCleanup: Array<ReduxComponent['id']> = []\n  Object.keys(components).forEach((id) => {\n    if (components[id].responses || components[id].errors) {\n      toCleanup.push(id)\n    }\n  })\n\n  return toCleanup\n}\n", "import { SDKState } from '../../interfaces'\n\nexport const getIceServers = ({ session }: SDKState) => {\n  return session?.iceServers ?? []\n}\n\nexport const getSession = (store: SDKState) => {\n  return store.session\n}\n\nexport const getAuthStatus = ({ session }: SDKState) => {\n  return session.authStatus\n}\n\nexport const getAuthError = ({ session }: SDKState) => {\n  return session.authError\n}\n\nexport const getAuthState = ({ session }: SDKState) => {\n  return session.authState\n}\n", "import { ReduxComponent, SessionState, CustomSaga } from './interfaces'\nimport { SDKStore } from './'\nimport { getComponent } from './features/component/componentSelectors'\nimport { getSession } from './features/session/sessionSelectors'\nimport type { BaseComponent } from '../BaseComponent'\nimport { EventEmitter } from '../utils/EventEmitter'\n\ntype ComponentEventHandler = (component: ReduxComponent) => unknown\ntype SessionEventHandler = (session: SessionState) => unknown\ninterface Connect<T> {\n  componentListeners: Record<string, string | ComponentEventHandler>\n  sessionListeners?: Partial<\n    Record<ReduxSessionKeys, string | SessionEventHandler>\n  >\n  store: SDKStore\n  Component: new (o: any) => T\n  customSagas?: Array<CustomSaga<T>>\n}\ntype ReduxComponentKeys = keyof ReduxComponent\ntype ReduxSessionKeys = keyof SessionState\n\nexport const connect = <\n  EventTypes extends EventEmitter.ValidEventTypes,\n  /**\n   * Class extending BaseComponent.\n   */\n  T extends BaseComponent<EventTypes>,\n  /**\n   * The type the end user will be interacting with.\n   */\n  TargetType\n>(\n  options: Connect<T>\n) => {\n  const {\n    componentListeners = {},\n    sessionListeners = {},\n    store,\n    Component,\n    customSagas = [],\n  } = options\n  const componentKeys = Object.keys(componentListeners) as ReduxComponentKeys[]\n  const sessionKeys = Object.keys(sessionListeners) as ReduxSessionKeys[]\n\n  return (userOptions: any): TargetType => {\n    const instance = new Component({ ...userOptions, store })\n    const cacheMap = new Map<string, any>()\n    /**\n     * Stop the execution of the redux listeners if `destroyer`\n     * below was called in the meantime.\n     */\n    let run = true\n\n    const storeUnsubscribe = store.subscribe(() => {\n      const state = store.getState()\n      const component = getComponent(state, instance.__uuid) || {}\n      for (const reduxKey of componentKeys) {\n        if (run === false) {\n          return\n        }\n\n        const cacheKey = `${instance.__uuid}.${reduxKey}`\n        const current = cacheMap.get(cacheKey)\n        const updatedValue = component[reduxKey]\n        if (updatedValue !== undefined && current !== updatedValue) {\n          cacheMap.set(cacheKey, updatedValue)\n          const fnName = componentListeners[reduxKey]\n\n          if (typeof fnName === 'string') {\n            // FIXME: proper types for fnName\n            // @ts-ignore\n            instance[fnName](component)\n          } else {\n            fnName(component)\n          }\n        }\n      }\n\n      const session = getSession(state)\n      for (const reduxKey of sessionKeys) {\n        if (run === false) {\n          return\n        }\n        const cacheKey = `session.${reduxKey}`\n        const current = cacheMap.get(cacheKey)\n        const updatedValue = session[reduxKey]\n\n        if (updatedValue !== undefined && current !== updatedValue) {\n          cacheMap.set(cacheKey, updatedValue)\n          const fnName = sessionListeners[reduxKey]\n\n          if (typeof fnName === 'string') {\n            // FIXME: proper types for fnName\n            // @ts-ignore\n            instance[fnName](session)\n          } else if (typeof fnName === 'function') {\n            fnName(session)\n          }\n        }\n      }\n    })\n\n    // Run all the custom sagas\n    const taskList = customSagas?.map((saga) => {\n      return store.runSaga(saga, { instance, runSaga: store.runSaga })\n    })\n\n    instance.destroyer = () => {\n      run = false\n      storeUnsubscribe()\n      cacheMap.clear()\n\n      // Cancel all the custom sagas\n      if (taskList?.length) {\n        taskList.forEach((task) => task.cancel())\n      }\n    }\n\n    return instance as any as TargetType\n  }\n}\n", "import type { Task } from '@redux-saga/types'\nimport {\n  uuid,\n  toInternalEventName,\n  isLocalEvent,\n  validateEventsToSubscribe,\n  instanceProxyFactory,\n  getLogger,\n  isSessionEvent,\n} from './utils'\nimport { executeAction, Action } from './redux'\nimport {\n  ExecuteParams,\n  ExecuteTransform,\n  BaseComponentOptions,\n  ExecuteExtendedOptions,\n  EventsPrefix,\n  EventTransformType,\n  EventTransform,\n  SDKWorker,\n  SDKWorkerDefinition,\n  SessionAuthStatus,\n  SDKWorkerHooks,\n  Authorization,\n} from './utils/interfaces'\nimport { EventEmitter } from './utils/EventEmitter'\nimport { SDKState } from './redux/interfaces'\nimport { makeCustomSagaAction } from './redux/actions'\nimport {\n  OnlyStateProperties,\n  EmitterContract,\n  BaseComponentContract,\n} from './types'\nimport {\n  getAuthError,\n  getAuthState,\n  getAuthStatus,\n} from './redux/features/session/sessionSelectors'\nimport { compoundEventAttachAction } from './redux/actions'\nimport { AuthError } from './CustomErrors'\nimport { proxyFactory } from './utils/proxyUtils'\n\ntype EventRegisterHandlers<EventTypes extends EventEmitter.ValidEventTypes> =\n  | {\n      type: 'on'\n      params: Parameters<EmitterContract<EventTypes>['on']>\n    }\n  | {\n      type: 'off'\n      params: Parameters<EmitterContract<EventTypes>['off']>\n    }\n  | {\n      type: 'once'\n      params: Parameters<EmitterContract<EventTypes>['once']>\n    }\n  | {\n      type: 'removeAllListeners'\n      params: [event: EventEmitter.EventNames<EventTypes>]\n    }\n\nconst identity: ExecuteTransform<any, any> = (payload) => payload\n\nexport const SW_SYMBOL = Symbol('BaseComponent')\n\nexport class BaseComponent<\n  EventTypes extends EventEmitter.ValidEventTypes,\n  StateProperties = Record<string, unknown>\n> implements EmitterContract<EventTypes>, BaseComponentContract\n{\n  /** @internal */\n  public __sw_symbol = SW_SYMBOL\n\n  /** @internal */\n  private readonly uuid = uuid()\n\n  /** @internal */\n  // private _proxyFactoryCache = new WeakMap<any, any>()\n\n  /** @internal */\n  get __uuid() {\n    return this.uuid\n  }\n\n  /** @internal */\n  protected _eventsPrefix: EventsPrefix = ''\n  private _eventsRegisterQueue = new Set<EventRegisterHandlers<EventTypes>>()\n  private _eventsEmitQueue = new Set<any>()\n  private _eventsNamespace?: string\n  private _eventsTransformsCache = new Map<\n    EventEmitter.EventNames<EventTypes>,\n    BaseComponent<EventTypes>\n  >()\n  private _requests = new Map()\n  private _customSagaTriggers = new Map()\n  private _destroyer?: () => void\n\n  private _handleCompoundEvents(event: EventEmitter.EventNames<EventTypes>) {\n    const internalEvent = this._getInternalEvent(event)\n    let compoundEvents\n    for (const evt of this.getCompoundEvents().keys()) {\n      if (this._getInternalEvent(evt) === internalEvent) {\n        compoundEvents = this.getCompoundEvents().get(evt)\n        break\n      }\n    }\n\n    if (!compoundEvents || compoundEvents.length === 0) {\n      return\n    }\n\n    this.store.dispatch(\n      compoundEventAttachAction({\n        compoundEvents,\n        event: internalEvent,\n        namespace: this._eventsNamespace,\n      })\n    )\n\n    compoundEvents.forEach((compoundEvent) => {\n      /**\n       * In the future we might want to support defining\n       * custom compound event handlers by specifying not\n       * only the event but its event handler as well. For\n       * now we don't have a need for that so we'll keep it\n       * simple and just track the event without going\n       * through the emitter (since we don't need the\n       * handler).\n       */\n      if (typeof compoundEvent === 'string') {\n        this._trackEvent(compoundEvent)\n      }\n    })\n  }\n\n  /**\n   * A Namespace let us scope specific instances inside of a\n   * particular product (like 'video.', 'chat.', etc.). For instance,\n   * when working with a room, the namespace will let us send messages\n   * to that specific room.\n   */\n  private _getNamespacedEvent(event: EventEmitter.EventNames<EventTypes>) {\n    /**\n     * \"Remote\" events are the events controlled by the\n     * server. In order to be able to attach them we have to\n     * wait for the server to respond.\n     * `this._eventsNamespace` is usually set with some\n     * piece of data coming from the server.\n     */\n    let namespace = this._eventsNamespace\n\n    /**\n     * \"Local\" events are attached synchronously so in order\n     * to be able to namespaced them properly we must make\n     * use of our locally generated __uuid.\n     */\n    if (typeof event === 'string' && isLocalEvent(event)) {\n      namespace = this.__uuid\n    }\n\n    return toInternalEventName({\n      event,\n      namespace,\n    })\n  }\n\n  /**\n   * A prefix is a product, like `video` or `chat`.\n   */\n  private _getPrefixedEvent(event: EventEmitter.EventNames<EventTypes>) {\n    if (\n      this._eventsPrefix &&\n      typeof event === 'string' &&\n      !event.includes(`${this._eventsPrefix}.`) &&\n      !isSessionEvent(event)\n    ) {\n      return `${this._eventsPrefix}.${event}` as EventEmitter.EventNames<EventTypes>\n    }\n\n    return event\n  }\n\n  private _getInternalEvent(event: EventEmitter.EventNames<EventTypes>) {\n    return this._getNamespacedEvent(this._getPrefixedEvent(event))\n  }\n\n  /**\n   * Collection of functions that will be executed before calling the\n   * event handlers registered by the end user (when using the Emitter\n   * interface).\n   */\n  private _emitterTransforms: Map<\n    EventEmitter.EventNames<EventTypes> | EventTransformType,\n    EventTransform\n  > = new Map()\n\n  /**\n   * Keeps track of the stable references used for registering events.\n   */\n  private _emitterListenersCache = new Map<\n    EventEmitter.EventNames<EventTypes>,\n    Map<\n      EventEmitter.EventListener<\n        EventTypes,\n        EventEmitter.EventNames<EventTypes>\n      >,\n      EventEmitter.EventListener<\n        EventTypes,\n        EventEmitter.EventNames<EventTypes>\n      >\n    >\n  >()\n  /**\n   * List of events being registered through the EventEmitter\n   * instance. These events include the `_eventsPrefix` but not the\n   * `_eventsNamespace`\n   */\n  private _trackedEvents: Array<EventEmitter.EventNames<EventTypes>> = []\n\n  /**\n   * List of running Tasks to be cancelled on `destroy`.\n   */\n  private _runningWorkers: Task[] = []\n\n  protected get logger() {\n    return getLogger()\n  }\n\n  /**\n   * Map of Sagas that will be attached to the Store to\n   * handle events or perform side-effects. This Map will\n   * behave as a queue and will be emptied once the workers\n   * have been attached. See `this.attachWorkers` for\n   * details.\n   */\n  protected _workers: Map<string, { worker: SDKWorker<any> }> = new Map()\n\n  constructor(public options: BaseComponentOptions<EventTypes>) {}\n\n  /** @internal */\n  set destroyer(d: () => void) {\n    this._destroyer = d\n  }\n\n  /** @internal */\n  get store() {\n    return this.options.store\n  }\n\n  /** @internal */\n  get emitter() {\n    return this.options.emitter\n  }\n\n  /** @internal */\n  private addEventToRegisterQueue(options: EventRegisterHandlers<EventTypes>) {\n    const [event, fn] = options.params\n    this.logger.trace('Adding event to the register queue', { event, fn })\n    // @ts-ignore\n    this._eventsRegisterQueue.add({\n      type: options.type,\n      params: options.params,\n    })\n    return this.emitter as EventEmitter<EventTypes>\n  }\n\n  /** @internal */\n  private _addEventToEmitQueue(\n    event: EventEmitter.EventNames<EventTypes>,\n    args: any[]\n  ) {\n    this.logger.trace('Adding to the emit queue', event)\n    this._eventsEmitQueue.add({ event, args })\n  }\n\n  /**\n   * Take into account that `this._eventsNamespace` can be\n   * intercepted by a wrapping Proxy object. We use this\n   * extensibily for wrapping instances of the BaseConsumer\n   * and event handlers instances.\n   * @internal\n   **/\n  private shouldAddToQueue() {\n    return this._eventsNamespace === undefined\n  }\n\n  /** @internal */\n  private runAndCacheEventHandlerTransform({\n    internalEvent,\n    transform,\n    payload,\n  }: {\n    internalEvent: EventEmitter.EventNames<EventTypes>\n    transform: EventTransform\n    payload: unknown\n  }): BaseComponent<EventTypes> {\n    if (transform.mode === 'no-cache') {\n      const instance = transform.instanceFactory(payload)\n\n      return instance\n    } else if (!this._eventsTransformsCache.has(internalEvent)) {\n      const instance = transform.instanceFactory(payload)\n      this._eventsTransformsCache.set(internalEvent, instance)\n\n      return instance\n    }\n\n    // @ts-expect-error\n    return this._eventsTransformsCache.get(internalEvent)\n  }\n\n  /** @internal */\n  private cleanupEventHandlerTransformCache({\n    internalEvent,\n    force,\n  }: {\n    internalEvent: EventEmitter.EventNames<EventTypes>\n    force: boolean\n  }) {\n    const instance = this._eventsTransformsCache.get(internalEvent)\n    const eventCount = this.listenerCount(internalEvent)\n\n    if (instance && (force || eventCount <= 1)) {\n      /**\n       * Make sure to not invoke destroy on \"self\"\n       * and that `instance.destroy` is defined.\n       */\n      if (\n        instance.__uuid !== this.__uuid &&\n        typeof instance.destroy === 'function'\n      ) {\n        instance.destroy()\n      }\n      return this._eventsTransformsCache.delete(internalEvent)\n    }\n\n    this.logger.trace(\n      `[cleanupEventHandlerTransformCache] Key wasn't cached`,\n      internalEvent\n    )\n    return false\n  }\n\n  /**\n   * Transforms are mapped using the \"prefixed\" event name (i.e\n   * non-namespaced sent by the server with the _eventPrefix) and\n   * then mapped again using the end-user `fn` reference.\n   * @internal\n   */\n  private getEmitterListenersMapByInternalEventName(\n    internalEvent: EventEmitter.EventNames<EventTypes>\n  ) {\n    return (\n      this._emitterListenersCache.get(internalEvent) ??\n      new Map<\n        EventEmitter.EventListener<\n          EventTypes,\n          EventEmitter.EventNames<EventTypes>\n        >,\n        EventEmitter.EventListener<\n          EventTypes,\n          EventEmitter.EventNames<EventTypes>\n        >\n      >()\n    )\n  }\n\n  private getAndRemoveStableEventHandler(\n    internalEvent: EventEmitter.EventNames<EventTypes>,\n    fn?: EventEmitter.EventListener<\n      EventTypes,\n      EventEmitter.EventNames<EventTypes>\n    >\n  ) {\n    const cacheByEventName =\n      this.getEmitterListenersMapByInternalEventName(internalEvent)\n    if (fn && cacheByEventName.has(fn)) {\n      const handler = cacheByEventName.get(fn)\n      cacheByEventName.delete(fn)\n      this._emitterListenersCache.set(internalEvent, cacheByEventName)\n      return handler\n    }\n\n    return fn\n  }\n\n  /**\n   * Creates the event handler to be attached to the `EventEmitter`.\n   * It contains the logic for applying any custom transforms for\n   * specific events along with the logic for caching the calls to\n   * `transform.instanceFactory`\n   **/\n  private _createStableEventHandler(\n    internalEvent: EventEmitter.EventNames<EventTypes>,\n    fn: EventEmitter.EventListener<\n      EventTypes,\n      EventEmitter.EventNames<EventTypes>\n    >\n  ) {\n    const wrapperHandler = (payload: unknown) => {\n      const transform = this._emitterTransforms.get(internalEvent)\n      this.logger.trace('Got emitterTransform for', internalEvent, transform)\n      if (!transform) {\n        // @ts-expect-error\n        return fn(payload)\n      }\n\n      const cachedInstance = this.runAndCacheEventHandlerTransform({\n        internalEvent,\n        transform,\n        payload,\n      })\n\n      let proxiedObj\n      // A single event can have multiple event handlers\n      // attached. Given that the payload should be the same\n      // for all of them, to avoid re-applying the same\n      // transforms and creating a brand new Proxy for each\n      // handler we'll cache the computed value and pass\n      // that computed value instead to each handler.\n      // if (this._proxyFactoryCache.has(payload)) {\n      //   proxiedObj = this._proxyFactoryCache.get(payload)\n      // } else {\n      const transformedPayload = this._parseNestedFields(payload, transform)\n\n      proxiedObj = proxyFactory({\n        instance: cachedInstance,\n        payload,\n        transformedPayload,\n        transform,\n      })\n\n      // this._proxyFactoryCache.set(payload, proxiedObj)\n      // }\n\n      // @ts-expect-error\n      return fn(proxiedObj)\n    }\n    return wrapperHandler as EventEmitter.EventListener<\n      EventTypes,\n      EventEmitter.EventNames<EventTypes>\n    >\n  }\n\n  private _parseNestedFields(\n    obj: unknown,\n    transform: EventTransform,\n    process = (p: any) => p,\n    result: any = undefined\n  ): any {\n    if (!transform.nestedFieldsToProcess) {\n      return transform.payloadTransform(obj)\n    }\n\n    // @ts-expect-error\n    if (obj.__sw_proxy) {\n      return obj\n    }\n\n    // First time we ran this util we'll apply the top level\n    // transform\n    if (!result) {\n      const r = transform.payloadTransform(obj)\n      return this._parseNestedFields(r, transform, process, r)\n    }\n\n    if (Array.isArray(obj)) {\n      result = obj.map((item: any, index: number) => {\n        return this._parseNestedFields(\n          process(item),\n          transform,\n          process,\n          // At this point we don't have a key so we can't\n          // reference a transform. This process comes from\n          // a previous iteration (since we don't support\n          // top level arrays)\n          obj[index]\n        )\n      })\n    } else if (obj && typeof obj === 'object') {\n      Object.entries(obj).forEach(([key, value]) => {\n        const nestedTransform = transform.nestedFieldsToProcess?.[key]\n        const transformToUse = nestedTransform\n          ? this._emitterTransforms.get(nestedTransform.eventTransformType)\n          : undefined\n\n        if (value && typeof value === 'object') {\n          result[key] = this._parseNestedFields(\n            value,\n            transform,\n            (p) => {\n              if (\n                nestedTransform &&\n                transformToUse &&\n                p &&\n                typeof p === 'object'\n              ) {\n                return instanceProxyFactory({\n                  transform: transformToUse,\n                  payload: process(nestedTransform.processInstancePayload(p)),\n                })\n              }\n\n              return p\n            },\n            result[key]\n          )\n        } else {\n          result[key] = process(value)\n        }\n      })\n    }\n\n    return result\n  }\n\n  private getOrCreateStableEventHandler(\n    internalEvent: EventEmitter.EventNames<EventTypes>,\n    fn: EventEmitter.EventListener<\n      EventTypes,\n      EventEmitter.EventNames<EventTypes>\n    >\n  ) {\n    const cacheByEventName =\n      this.getEmitterListenersMapByInternalEventName(internalEvent)\n    let handler = cacheByEventName.get(fn)\n\n    if (!handler) {\n      handler = this._createStableEventHandler(internalEvent, fn)\n      cacheByEventName.set(fn, handler)\n      this._emitterListenersCache.set(internalEvent, cacheByEventName)\n    }\n\n    return handler\n  }\n\n  /**\n   * Since the EventEmitter instance (this.emitter) is\n   * shared across the whole app each BaseComponent instance\n   * will have to keep track of their own events so if/when\n   * the user calls `removeAllListeners` we only clean the\n   * events this instance cares/controls.\n   */\n  private _trackEvent(internalEvent: EventEmitter.EventNames<EventTypes>) {\n    this._trackedEvents = Array.from(\n      new Set(this._trackedEvents.concat(internalEvent))\n    )\n  }\n\n  private _untrackEvent(internalEvent: EventEmitter.EventNames<EventTypes>) {\n    this._trackedEvents = this._trackedEvents.filter(\n      (evt) => evt !== internalEvent\n    )\n  }\n\n  private _addListener<T extends EventEmitter.EventNames<EventTypes>>(\n    event: T,\n    fn: EventEmitter.EventListener<EventTypes, T>,\n    once?: boolean\n  ) {\n    this._handleCompoundEvents(event)\n\n    const internalEvent = this._getInternalEvent(event)\n    this._trackEvent(internalEvent)\n\n    const type: EventRegisterHandlers<EventTypes>['type'] = once ? 'once' : 'on'\n    if (this.shouldAddToQueue()) {\n      this.addEventToRegisterQueue({\n        type,\n        params: [event, fn] as any,\n      })\n      return this.emitter as EventEmitter<EventTypes>\n    }\n    const wrappedHandler = this.getOrCreateStableEventHandler(\n      internalEvent,\n      fn as any\n    )\n    this.logger.trace('Registering event', internalEvent)\n    return this.emitter[type](internalEvent, wrappedHandler)\n  }\n\n  on<T extends EventEmitter.EventNames<EventTypes>>(\n    event: T,\n    fn: EventEmitter.EventListener<EventTypes, T>\n  ) {\n    return this._addListener(event, fn)\n  }\n\n  once<T extends EventEmitter.EventNames<EventTypes>>(\n    event: T,\n    fn: EventEmitter.EventListener<EventTypes, T>\n  ) {\n    return this._addListener(event, fn, true)\n  }\n\n  off<T extends EventEmitter.EventNames<EventTypes>>(\n    event: T,\n    fn?: EventEmitter.EventListener<EventTypes, T>\n  ) {\n    if (this.shouldAddToQueue()) {\n      this.addEventToRegisterQueue({\n        type: 'off',\n        params: [event, fn] as any,\n      })\n      return this.emitter as EventEmitter<EventTypes>\n    }\n\n    const internalEvent = this._getInternalEvent(event)\n    const handler = this.getAndRemoveStableEventHandler(\n      internalEvent,\n      fn as any\n    )\n    this.cleanupEventHandlerTransformCache({\n      internalEvent,\n      /**\n       * If handler is not defined we'll force the cleanup\n       * since the `emitter` will remove all the handlers\n       * for the specified event\n       */\n      force: !handler,\n    })\n    this.logger.trace('Removing event listener', internalEvent)\n    this._untrackEvent(internalEvent)\n    return this.emitter.off(internalEvent, handler)\n  }\n\n  removeAllListeners<T extends EventEmitter.EventNames<EventTypes>>(event?: T) {\n    if (this.shouldAddToQueue()) {\n      this.addEventToRegisterQueue({\n        type: 'removeAllListeners',\n        params: [event] as any,\n      })\n      return this.emitter as EventEmitter<EventTypes>\n    }\n\n    if (event) {\n      return this.off(event)\n    }\n\n    this.eventNames().forEach((eventName) => {\n      this.off(eventName)\n    })\n\n    return this.emitter as EventEmitter<EventTypes>\n  }\n\n  /** @internal */\n  eventNames() {\n    return this._trackedEvents\n  }\n\n  protected getSubscriptions() {\n    return validateEventsToSubscribe(this.eventNames())\n  }\n\n  /** @internal */\n  emit(event: EventEmitter.EventNames<EventTypes>, ...args: any[]) {\n    if (this.shouldAddToQueue()) {\n      this._addEventToEmitQueue(event, args)\n      return false\n    }\n\n    const internalEvent = this._getInternalEvent(event)\n    this.logger.trace('Emit on event:', internalEvent)\n    // @ts-ignore\n    return this.emitter.emit(internalEvent, ...args)\n  }\n\n  /** @internal */\n  listenerCount<T extends EventEmitter.EventNames<EventTypes>>(event: T) {\n    return this.emitter.listenerCount(event)\n  }\n\n  destroy() {\n    this._destroyer?.()\n    this.removeAllListeners()\n    this.detachWorkers()\n  }\n\n  /** @internal */\n  execute<\n    InputType = unknown,\n    OutputType = unknown,\n    ParamsType = Record<string, any>\n  >(\n    { method, params }: ExecuteParams,\n    {\n      transformParams = identity,\n      transformResolve = identity,\n      transformReject = identity,\n    }: ExecuteExtendedOptions<InputType, OutputType, ParamsType> = {\n      transformParams: identity,\n      transformResolve: identity,\n      transformReject: identity,\n    }\n  ) {\n    return new Promise<OutputType>((resolve, reject) => {\n      const requestId = uuid()\n      this._requests.set(requestId, {\n        resolve,\n        reject,\n        transformResolve,\n        transformReject,\n      })\n\n      this.store.dispatch(\n        executeAction({\n          requestId,\n          componentId: this.__uuid,\n          method,\n          params: transformParams(params as ParamsType),\n        })\n      )\n    })\n  }\n\n  /** @internal */\n  triggerCustomSaga<T>(action: Action): Promise<T> {\n    return new Promise((resolve, reject) => {\n      const dispatchId = uuid()\n      this._customSagaTriggers.set(dispatchId, { resolve, reject })\n\n      this.store.dispatch({\n        dispatchId,\n        ...makeCustomSagaAction(this.__uuid, action),\n      })\n    })\n  }\n\n  /** @internal */\n  settleCustomSagaTrigger<T>({\n    dispatchId,\n    payload,\n    kind,\n  }: {\n    dispatchId: string\n    payload?: T\n    kind: 'resolve' | 'reject'\n  }) {\n    const actions = this._customSagaTriggers.get(dispatchId)\n    if (actions) {\n      actions[kind](payload)\n      this._customSagaTriggers.delete(dispatchId)\n    }\n  }\n\n  /** @internal */\n  select<T>(selectorFn: (state: SDKState) => T) {\n    return selectorFn(this.store.getState())\n  }\n\n  /** @internal */\n  onError(component: any) {\n    this._requests.forEach((value, key) => {\n      /**\n       * If component.errors[key] is undefined it means that the\n       * request hasn't failed\n       */\n      if (component?.errors[key] !== undefined) {\n        value.reject(value.transformReject(component.errors[key]))\n        this._requests.delete(key)\n      }\n    })\n  }\n\n  /** @internal */\n  onSuccess(component: any) {\n    this._requests.forEach((value, key) => {\n      /**\n       * If component.responses[key] is undefined it means that the\n       * request is not ready yet.\n       */\n      if (component?.responses[key] !== undefined) {\n        value.resolve(value.transformResolve(component.responses[key]))\n        this._requests.delete(key)\n      }\n    })\n  }\n\n  /** @internal */\n  getStateProperty(param: keyof OnlyStateProperties<StateProperties>) {\n    // @ts-expect-error\n    return this[param]\n  }\n\n  /** @internal */\n  private flushEventsRegisterQueue() {\n    this._eventsRegisterQueue.forEach((item) => {\n      // @ts-ignore\n      this[item.type](...item.params)\n      this._eventsRegisterQueue.delete(item)\n    })\n  }\n\n  /** @internal */\n  private flushEventsEmitQueue() {\n    this._eventsEmitQueue.forEach((item) => {\n      const { event, args } = item\n      this.emit(event, ...args)\n      this._eventsEmitQueue.delete(item)\n    })\n  }\n\n  /** @internal */\n  private flushEventsQueue() {\n    this.flushEventsRegisterQueue()\n    this.flushEventsEmitQueue()\n  }\n\n  /** @internal */\n  protected _attachListeners(namespace?: string) {\n    if (typeof namespace === 'string') {\n      this._eventsNamespace = namespace\n    }\n    this.flushEventsQueue()\n  }\n\n  /** @internal */\n  protected getCompoundEvents(): Map<\n    EventEmitter.EventNames<EventTypes>,\n    EventEmitter.EventNames<EventTypes>[]\n  > {\n    return new Map()\n  }\n\n  /**\n   * Returns a structure with the emitter transforms that we want to `apply`\n   * for each BaseConsumer. This allow us to define a static structure for\n   * each class and later consume it within `applyEmitterTransforms`.\n   * @internal\n   */\n  protected getEmitterTransforms(): Map<string | string[], EventTransform> {\n    return new Map()\n  }\n\n  /** @internal */\n  protected get _sessionAuthStatus(): SessionAuthStatus {\n    return getAuthStatus(this.store.getState())\n  }\n\n  /** @internal */\n  protected get _sessionAuthState(): Authorization | undefined {\n    return getAuthState(this.store.getState())\n  }\n\n  /** @internal */\n  protected _waitUntilSessionAuthorized(): Promise<this> {\n    const authStatus = getAuthStatus(this.store.getState())\n\n    switch (authStatus) {\n      case 'authorized':\n        return Promise.resolve(this)\n\n      /**\n       * `unknown` is the initial state of the auth reducer\n       * so if we've got this far it means it's the first\n       * time the user is calling `connect`.\n       */\n      case 'unknown':\n      /**\n       * `authorizing` means that the user is calling\n       * `connect` again while we're in the process of\n       * authorizing the session.\n       */\n      case 'authorizing':\n        return new Promise((resolve, reject) => {\n          const unsubscribe = this.store.subscribe(() => {\n            const authStatus = getAuthStatus(this.store.getState())\n            const authError = getAuthError(this.store.getState())\n\n            if (authStatus === 'authorized') {\n              resolve(this)\n              unsubscribe()\n            } else if (authStatus === 'unauthorized') {\n              const error = authError\n                ? new AuthError(authError.code, authError.message)\n                : new Error('Unauthorized')\n              reject(error)\n              unsubscribe()\n            }\n          })\n        })\n\n      case 'unauthorized':\n        return Promise.reject(new Error('Unauthorized'))\n    }\n  }\n\n  private _setEmitterTransform({\n    event,\n    handler,\n    local,\n  }: {\n    event: string\n    handler: EventTransform\n    local: boolean\n  }) {\n    const internalEvent = this._getInternalEvent(\n      event as EventEmitter.EventNames<EventTypes>\n    )\n\n    if (\n      local\n        ? /**\n           * When `local === true` we filter out `Remote Events`\n           */\n          !isLocalEvent(event)\n        : /**\n           * When `local !== true` we filter out `Local Events` AND\n           * events the user hasn't subscribed to.\n           */\n          isLocalEvent(event) || !this.eventNames().includes(internalEvent)\n    ) {\n      return\n    }\n\n    this._emitterTransforms.set(internalEvent, handler)\n  }\n\n  /**\n   * Loop through the `getEmitterTransforms` Map and translate those into the\n   * internal `_emitterTransforms` Map to quickly select & use the transform starting\n   * from the server-side event.\n   * @internal\n   */\n  protected applyEmitterTransforms(\n    { local = false }: { local: boolean } = { local: false }\n  ) {\n    this.getEmitterTransforms().forEach((handlersObj, key) => {\n      if (Array.isArray(key)) {\n        key.forEach((k) => {\n          this._setEmitterTransform({\n            event: k,\n            handler: handlersObj,\n            local,\n          })\n        })\n      } else {\n        this._setEmitterTransform({\n          event: key,\n          handler: handlersObj,\n          local,\n        })\n      }\n\n      /**\n       * Set a transform using the `key` to select it easily when\n       * creating Proxy objects.\n       * The transform by `type` will be used by nested fields while the top-level\n       * by `internalEvent` for each single event transform.\n       */\n      this._emitterTransforms.set(handlersObj.type, handlersObj)\n    })\n  }\n\n  /** @internal */\n  protected runWorker<Hooks extends SDKWorkerHooks = SDKWorkerHooks>(\n    name: string,\n    def: SDKWorkerDefinition<Hooks>\n  ) {\n    if (this._workers.has(name)) {\n      getLogger().warn(\n        `[runWorker] Worker with name ${name} has already been registerd.`\n      )\n    } else {\n      this._setWorker(name, def)\n    }\n\n    this._attachWorker(name, def)\n  }\n\n  private _setWorker<Hooks extends SDKWorkerHooks = SDKWorkerHooks>(\n    name: string,\n    def: SDKWorkerDefinition<Hooks>\n  ) {\n    this._workers.set(name, def)\n  }\n\n  private _attachWorker<Hooks extends SDKWorkerHooks = SDKWorkerHooks>(\n    name: string,\n    { worker, ...params }: SDKWorkerDefinition<Hooks>\n  ) {\n    const task = this.store.runSaga(worker, {\n      instance: this,\n      runSaga: this.store.runSaga,\n      ...params,\n    })\n    this._runningWorkers.push(task)\n    /**\n     * Attaching workers is a one-time op for instances so\n     * the moment we attach one we'll remove it from the\n     * queue.\n     */\n    this._workers.delete(name)\n  }\n\n  private detachWorkers() {\n    this._runningWorkers.forEach((task) => {\n      task.cancel()\n    })\n    this._runningWorkers = []\n  }\n}\n", "import { destroyAction, initAction } from './redux'\nimport { BaseClientOptions } from './utils/interfaces'\nimport { BaseComponent } from './BaseComponent'\nimport { EventEmitter } from './utils/EventEmitter'\nimport { getAuthStatus } from './redux/features/session/sessionSelectors'\n\nexport class BaseClient<\n  EventTypes extends EventEmitter.ValidEventTypes\n> extends BaseComponent<EventTypes> {\n  constructor(public options: BaseClientOptions<EventTypes>) {\n    super(options)\n    /**\n     * Since we don't need a namespace for these events\n     * we'll attach them as soon as the Client has been\n     * registered in the Redux store.\n     */\n    this._attachListeners('')\n  }\n\n  /**\n   * Connect the underlay WebSocket connection to the SignalWire network.\n   *\n   * @returns Promise that will resolve with the Client object.\n   */\n  connect(): Promise<this> {\n    const authStatus = getAuthStatus(this.store.getState())\n\n    if (authStatus === 'unknown' || authStatus === 'unauthorized') {\n      this.store.dispatch(initAction())\n    }\n\n    return this._waitUntilSessionAuthorized()\n  }\n\n  /**\n   * Disconnect the Client from the SignalWire network.\n   */\n  disconnect() {\n    this.store.dispatch(destroyAction())\n  }\n}\n", "import {\n  BaseComponent,\n  ExecuteParams,\n  EventEmitter,\n  BaseComponentOptions,\n  JSONRPCSubscribeMethod,\n} from '.'\n\n/**\n * Instances of this class are meant to be wrapped by a\n * Proxy that intercepts the `_eventsNamespace` (to tell the\n * BaseComponent it's fine to attach the event listeners)\n * and the `eventChannel`\n * @internal\n */\nexport class BaseConsumer<\n  EventTypes extends EventEmitter.ValidEventTypes\n> extends BaseComponent<EventTypes> {\n  protected subscribeMethod: JSONRPCSubscribeMethod = 'signalwire.subscribe'\n  protected subscribeParams?: Record<string, any> = {}\n  private _latestExecuteParams?: ExecuteParams\n\n  constructor(public options: BaseComponentOptions<EventTypes>) {\n    super(options)\n\n    /**\n     * Local events can be attached right away because we\n     * have enough information during build time on how to\n     * namespace them. Other events depend on info coming\n     * from the server and for those we have to wait until\n     * the `subscribe()` happen.\n     */\n    this.applyEmitterTransforms({ local: true })\n\n    /**\n     * TODO: To Review\n     * Reset _latestExecuteParams when on session connect/disconnet\n     * so a reconnected client can send subscribe again.\n     */\n    const resetLatestExecuteParams = () => {\n      this._latestExecuteParams = undefined\n    }\n    // @ts-expect-error\n    super.on('session.connected', resetLatestExecuteParams)\n    // @ts-expect-error\n    super.on('session.disconnected', resetLatestExecuteParams)\n    // @ts-expect-error\n    super.on('session.reconnecting', resetLatestExecuteParams)\n  }\n\n  private shouldExecuteSubscribe(execParams: ExecuteParams) {\n    return (\n      !this._latestExecuteParams ||\n      JSON.stringify(execParams) !== JSON.stringify(this._latestExecuteParams)\n    )\n  }\n\n  async subscribe() {\n    await this._waitUntilSessionAuthorized()\n\n    const subscriptions = this.getSubscriptions()\n\n    if (subscriptions.length === 0) {\n      this.logger.debug(\n        '`subscribe()` was called without any listeners attached.'\n      )\n      return\n    }\n\n    const execParams: ExecuteParams = {\n      method: this.subscribeMethod,\n      params: {\n        ...this.subscribeParams,\n        event_channel: this.getStateProperty('eventChannel'),\n        events: subscriptions,\n      },\n    }\n\n    if (!this.shouldExecuteSubscribe(execParams)) {\n      this.logger.debug(\n        'BaseConsumer.subscribe() - Skipped .execute() since the execParams are exactly the same as last time'\n      )\n      return\n    }\n\n    this._latestExecuteParams = execParams\n    return new Promise(async (resolve, reject) => {\n      try {\n        this.applyEmitterTransforms()\n        await this.execute(execParams)\n        return resolve(undefined)\n      } catch (error) {\n        return reject(error)\n      }\n    })\n  }\n}\n", "import EventEmitter from 'eventemitter3'\n\nconst REQUIRED_EMITTER_METHODS = [\n  'on',\n  'off',\n  'once',\n  'removeAllListeners',\n  'emit',\n]\n\n/**\n * Checks the shape of the emitter at runtime. This is useful for when\n * the user is using the SDK without TS\n */\nconst assertEventEmitter = (emitter: unknown): emitter is EventEmitter => {\n  if (\n    emitter &&\n    typeof emitter === 'object' &&\n    REQUIRED_EMITTER_METHODS.every((name) => name in emitter)\n  ) {\n    return true\n  }\n\n  return false\n}\n\nconst getEventEmitter = <T extends EventEmitter.ValidEventTypes>() => {\n  return new EventEmitter<T>()\n}\n\nexport { assertEventEmitter, EventEmitter, getEventEmitter }\n", "import { PRODUCT_PREFIX_VIDEO } from '../utils/constants'\nimport { toExternalJSON } from '../utils'\nimport type { SwEvent, VideoPosition } from '.'\nimport type {\n  CamelToSnakeCase,\n  SnakeToCamelCase,\n  EntityUpdated,\n  ToInternalVideoEvent,\n  OnlyStateProperties,\n  OnlyFunctionProperties,\n} from './utils'\nimport * as Rooms from '../rooms'\nimport { Authorization } from '..'\n\n/**\n * Used to not duplicate member fields across constants and types\n * and generate `MEMBER_UPDATED_EVENTS` below.\n * `key`: `type`\n */\nexport const INTERNAL_MEMBER_UPDATABLE_PROPS = {\n  audio_muted: true,\n  video_muted: true,\n  deaf: true,\n  visible: true,\n  input_volume: 1,\n  output_volume: 1,\n  input_sensitivity: 1,\n}\nexport type InternalVideoMemberUpdatableProps =\n  typeof INTERNAL_MEMBER_UPDATABLE_PROPS\n\nexport const INTERNAL_MEMBER_UPDATED_EVENTS = Object.keys(\n  INTERNAL_MEMBER_UPDATABLE_PROPS\n).map((key) => {\n  return `${PRODUCT_PREFIX_VIDEO}.member.updated.${\n    key as keyof InternalVideoMemberUpdatableProps\n  }` as const\n})\n\ntype VideoMemberUpdatableProps = {\n  [K in keyof InternalVideoMemberUpdatableProps as SnakeToCamelCase<K>]: InternalVideoMemberUpdatableProps[K]\n}\n\nexport const MEMBER_UPDATABLE_PROPS: VideoMemberUpdatableProps = toExternalJSON(\n  INTERNAL_MEMBER_UPDATABLE_PROPS\n)\n\nexport const MEMBER_UPDATED_EVENTS = Object.keys(MEMBER_UPDATABLE_PROPS).map(\n  (key) => {\n    return `member.updated.${key as keyof VideoMemberUpdatableProps}` as const\n  }\n)\n\n/**\n * Public event types\n */\nexport type MemberJoined = 'member.joined'\nexport type MemberLeft = 'member.left'\nexport type MemberUpdated = 'member.updated'\nexport type MemberTalking = 'member.talking'\nexport type MemberPromoted = 'member.promoted'\nexport type MemberDemoted = 'member.demoted'\n\n// Generated by the SDK\n\n/**\n * @privateRemarks\n *\n * This event will take care of handling multiple events at\n * once with the purpose of providing a nicer API for\n * keeping an up-to-date list of members within a certain\n * room.\n */\nexport type MemberListUpdated = 'memberList.updated'\n\n/**\n * See {@link MEMBER_UPDATED_EVENTS} for the full list of events.\n */\nexport type MemberUpdatedEventNames = typeof MEMBER_UPDATED_EVENTS[number]\nexport type MemberTalkingStarted = 'member.talking.started'\nexport type MemberTalkingEnded = 'member.talking.ended'\n/**\n * Use `member.talking.started` instead\n * @deprecated\n */\nexport type MemberTalkingStart = 'member.talking.start'\n/**\n * Use `member.talking.ended` instead\n * @deprecated\n */\nexport type MemberTalkingStop = 'member.talking.stop'\n\nexport type MemberTalkingEventNames =\n  | MemberTalking\n  | MemberTalkingStarted\n  | MemberTalkingEnded\n  | MemberTalkingStart\n  | MemberTalkingStop\n\n/**\n * List of public events\n */\nexport type VideoMemberEventNames =\n  | MemberJoined\n  | MemberLeft\n  | MemberUpdated\n  | MemberUpdatedEventNames\n  | MemberTalkingEventNames\n  | MemberListUpdated\n\nexport type InternalMemberUpdatedEventNames =\n  typeof INTERNAL_MEMBER_UPDATED_EVENTS[number]\n\n/**\n * List of internal events\n * @internal\n */\nexport type InternalVideoMemberEventNames =\n  | ToInternalVideoEvent<\n      MemberJoined | MemberLeft | MemberUpdated | MemberTalkingEventNames\n    >\n  | InternalMemberUpdatedEventNames\n\nexport type VideoMemberType = 'member' | 'screen' | 'device'\n\n/**\n * Public Contract for a VideoMember\n */\nexport interface VideoMemberContract extends VideoMemberUpdatableProps {\n  /** Unique id of this member. */\n  id: string\n  /** Id of the room associated to this member. */\n  roomId: string\n  /** Id of the room session associated to this member. */\n  roomSessionId: string\n  /** Name of this member. */\n  name: string\n  /** Id of the parent video member, if it exists. */\n  parentId?: string\n  /** Type of this video member. Can be `'member'`, `'screen'`, or `'device'`. */\n  type: VideoMemberType\n  /**\n   * Position requested for this member in the layout. This may differ from\n   * `currentPosition` if the requested position is not currently available.\n   */\n  requestedPosition: VideoPosition\n  /** Current position of this member in the layout. */\n  currentPosition?: VideoPosition\n  /** Metadata associated to this member. */\n  meta?: Record<string, unknown>\n\n  /**\n   * Mutes the outbound audio for this member (e.g., the one coming from a\n   * microphone). The other participants will not hear audio from the muted\n   * participant anymore.\n   *\n   * @example\n   * ```typescript\n   * await member.audioMute()\n   * ```\n   */\n  audioMute(): Rooms.AudioMuteMember\n\n  /**\n   * Unmutes the outbound audio for this member (e.g., the one coming from a\n   * microphone) if it had been previously muted.\n   *\n   * @example\n   * ```typescript\n   * await member.audioUnmute()\n   * ```\n   */\n  audioUnmute(): Rooms.AudioUnmuteMember\n\n  /**\n   * Mutes the outbound video for this member (e.g., the one coming from a\n   * webcam). Participants will see a mute image instead of the video stream.\n   *\n   * @example\n   * ```typescript\n   * await member.videoMute()\n   * ```\n   */\n  videoMute(): Rooms.VideoMuteMember\n\n  /**\n   * Unmutes the outbound video for this member (e.g., the one coming from a\n   * webcam) if it had been previously muted. Participants will start seeing the\n   * video stream again.\n   *\n   * @example\n   * ```typescript\n   * await member.videoUnmute()\n   * ```\n   */\n  videoUnmute(): Rooms.VideoUnmuteMember\n\n  /**\n   * Mutes or unmutes the inbound audio for the member (e.g., the one that get\n   * played through this member's speakers). When the inbound audio is muted,\n   * the affected participant will not hear audio from the other participants\n   * anymore.\n   *\n   * @param value whether to mute the audio\n   *\n   * @example\n   * ```typescript\n   * await member.setDeaf(true)\n   * ```\n   */\n  setDeaf(value: boolean): Rooms.SetDeaf\n\n  /**\n   * @deprecated Use {@link setInputVolume} instead.\n   * `setMicrophoneVolume` will be removed in v4.0.0\n   */\n  setMicrophoneVolume(params: { volume: number }): Rooms.SetInputVolumeMember\n\n  /**\n   * Sets the input volume for the member (e.g., the microphone input level).\n   *\n   * @param params\n   * @param params.volume desired volume. Values range from -50 to 50, with a\n   * default of 0.\n   *\n   * @example\n   * ```typescript\n   * await member.setInputVolume({volume: -10})\n   * ```\n   */\n  setInputVolume(params: { volume: number }): Rooms.SetInputVolumeMember\n\n  /**\n   * @deprecated Use {@link setOutputVolume} instead.\n   * `setSpeakerVolume` will be removed in v4.0.0\n   */\n  setSpeakerVolume(params: { volume: number }): Rooms.SetOutputVolumeMember\n\n  /**\n   * Sets the output volume for the member (e.g., the speaker output level).\n   *\n   * @param params\n   * @param params.volume desired volume. Values range from -50 to 50, with a\n   * default of 0.\n   *\n   * @example\n   * ```typescript\n   * await member.setOutputVolume({volume: -10})\n   * ```\n   */\n  setOutputVolume(params: { volume: number }): Rooms.SetOutputVolumeMember\n\n  /**\n   * Sets the input level at which the participant is identified as currently\n   * speaking.\n   *\n   * @param params\n   * @param params.value desired sensitivity. The default value is 30 and the\n   * scale goes from 0 (lowest sensitivity, essentially muted) to 100 (highest\n   * sensitivity).\n   *\n   * @example\n   * ```typescript\n   * await member.setInputSensitivity({value: 80})\n   * ```\n   */\n  setInputSensitivity(params: {\n    value: number\n  }): Rooms.SetInputSensitivityMember\n\n  /**\n   * Removes this member from the room.\n   *\n   * @example\n   * ```typescript\n   * await member.remove()\n   * ```\n   */\n  remove(): Rooms.RemoveMember\n}\n\n/**\n * VideoMember properties\n */\nexport type VideoMemberEntity = OnlyStateProperties<VideoMemberContract>\n/**\n * VideoMember methods\n */\nexport type VideoMemberMethods = OnlyFunctionProperties<VideoMemberContract>\n\n/**\n * VideoMemberEntity entity plus `updated` field\n */\nexport type VideoMemberEntityUpdated = EntityUpdated<VideoMemberEntity>\n\n/**\n * VideoMemberEntity entity for internal usage (converted to snake_case)\n * @internal\n */\nexport type InternalVideoMemberEntity = {\n  [K in NonNullable<\n    keyof VideoMemberEntity\n  > as CamelToSnakeCase<K>]: VideoMemberEntity[K]\n}\n\n/**\n * VideoMember entity plus `updated` field\n * for internal usage (converted to snake_case)\n * @internal\n */\nexport type InternalVideoMemberEntityUpdated =\n  EntityUpdated<InternalVideoMemberEntity>\n\nexport interface InternalVideoMemberUpdatedEvent extends SwEvent {\n  event_type: InternalMemberUpdatedEventNames\n  params: VideoMemberUpdatedEventParams\n}\n\nexport interface InternalVideoMemberTalkingEvent extends SwEvent {\n  event_type: MemberTalkingEventNames\n  params: VideoMemberTalkingEventParams\n}\n\nexport type InternalVideoMemberEvent =\n  | InternalVideoMemberUpdatedEvent\n  | InternalVideoMemberTalkingEvent\n\n/**\n * ==========\n * ==========\n * Server-Side Events\n * ==========\n * ==========\n */\n\n/**\n * 'video.member.joined'\n */\nexport interface VideoMemberJoinedEventParams {\n  room_session_id: string\n  room_id: string\n  member: InternalVideoMemberEntity\n}\n\nexport interface VideoMemberJoinedEvent extends SwEvent {\n  event_type: ToInternalVideoEvent<MemberJoined>\n  params: VideoMemberJoinedEventParams\n}\n\n/**\n * 'video.member.updated'\n */\nexport interface VideoMemberUpdatedEventParams {\n  room_session_id: string\n  room_id: string\n  member: InternalVideoMemberEntityUpdated\n}\n\nexport interface VideoMemberUpdatedEvent extends SwEvent {\n  event_type: ToInternalVideoEvent<MemberUpdated>\n  params: VideoMemberUpdatedEventParams\n}\n\n/**\n * 'video.member.left'\n */\nexport interface VideoMemberLeftEventParams {\n  room_session_id: string\n  room_id: string\n  member: InternalVideoMemberEntity\n}\n\nexport interface VideoMemberLeftEvent extends SwEvent {\n  event_type: ToInternalVideoEvent<MemberLeft>\n  params: VideoMemberLeftEventParams\n}\n\n/**\n * 'video.member.talking'\n */\nexport interface VideoMemberTalkingEventParams {\n  room_session_id: string\n  room_id: string\n  member: {\n    id: string\n    talking: boolean\n  }\n}\n\nexport interface VideoMemberTalkingEvent extends SwEvent {\n  event_type: ToInternalVideoEvent<MemberTalking>\n  params: VideoMemberTalkingEventParams\n}\n\n/**\n * 'video.member.promoted'\n */\nexport interface VideoMemberPromotedEventParams {\n  room_session_id: string\n  room_id: string\n  member_id: string\n  authorization: Authorization\n}\n\nexport interface VideoMemberPromotedEvent extends SwEvent {\n  event_type: ToInternalVideoEvent<MemberPromoted>\n  params: VideoMemberPromotedEventParams\n}\n\n/**\n * 'video.member.demoted'\n */\nexport interface VideoMemberDemotedEventParams {\n  room_session_id: string\n  room_id: string\n  member_id: string\n  authorization: Authorization\n}\n\nexport interface VideoMemberDemotedEvent extends SwEvent {\n  event_type: ToInternalVideoEvent<MemberDemoted>\n  params: VideoMemberDemotedEventParams\n}\n\nexport type VideoMemberEvent =\n  | VideoMemberJoinedEvent\n  | VideoMemberLeftEvent\n  | VideoMemberUpdatedEvent\n  | VideoMemberTalkingEvent\n  | VideoMemberPromotedEvent\n  | VideoMemberDemotedEvent\n\n/**\n * VideoMemberPromotedEventParams and VideoMemberDemotedEventParams\n * are special events without the full `member` object so we avoid\n * them in VideoMemberEventParams\n */\nexport type VideoMemberEventParams =\n  | VideoMemberJoinedEventParams\n  | VideoMemberLeftEventParams\n  | VideoMemberUpdatedEventParams\n  | VideoMemberTalkingEventParams\n", "import {\n  uuid,\n  setLogger,\n  getLogger,\n  isGlobalEvent,\n  toExternalJSON,\n  toSnakeCaseKeys,\n  toLocalEvent,\n  toSyntheticEvent,\n  extendComponent,\n  validateEventsToSubscribe,\n  toInternalEventName,\n  toInternalAction,\n  serializeableProxy,\n  timeoutPromise,\n  debounce,\n} from './utils'\nimport { BaseSession } from './BaseSession'\nimport { BaseJWTSession } from './BaseJWTSession'\nimport { configureStore, connect } from './redux'\nimport { BaseClient } from './BaseClient'\nimport { BaseComponent } from './BaseComponent'\nimport { BaseConsumer } from './BaseConsumer'\nimport { EventEmitter, getEventEmitter } from './utils/EventEmitter'\nimport * as sessionSelectors from './redux/features/session/sessionSelectors'\nimport { findNamespaceInPayload } from './redux/features/shared/namespace'\nimport { GLOBAL_VIDEO_EVENTS } from './utils/constants'\nimport {\n  MEMBER_UPDATED_EVENTS,\n  INTERNAL_MEMBER_UPDATED_EVENTS,\n} from './types/videoMember'\n\nexport {\n  uuid,\n  setLogger,\n  getLogger,\n  BaseSession,\n  BaseJWTSession,\n  BaseComponent,\n  BaseConsumer,\n  BaseClient,\n  connect,\n  configureStore,\n  EventEmitter,\n  extendComponent,\n  validateEventsToSubscribe,\n  getEventEmitter,\n  isGlobalEvent,\n  toExternalJSON,\n  toSnakeCaseKeys,\n  toLocalEvent,\n  toInternalEventName,\n  toInternalAction,\n  serializeableProxy,\n  toSyntheticEvent,\n  GLOBAL_VIDEO_EVENTS,\n  MEMBER_UPDATED_EVENTS,\n  INTERNAL_MEMBER_UPDATED_EVENTS,\n  findNamespaceInPayload,\n  timeoutPromise,\n  debounce,\n}\n\nexport * from './redux/features/component/componentSlice'\nexport * from './redux/features/session/sessionSlice'\nexport * as componentSelectors from './redux/features/component/componentSelectors'\nexport * from './RPCMessages'\nexport * from './utils/interfaces'\nexport * from './types'\nexport * from './CustomErrors'\nexport type {\n  SessionState,\n  CustomSagaParams,\n  CustomSaga,\n  PubSubChannel,\n  PubSubAction,\n  MapToPubSubShape,\n  SDKActions,\n  ReduxComponent,\n} from './redux/interfaces'\nexport type { ToExternalJSONResult } from './utils'\nexport * as actions from './redux/actions'\nexport * as sagaHelpers from './redux/utils/sagaHelpers'\nexport * as sagaEffects from '@redux-saga/core/effects'\nexport type { SagaIterator, Task, Saga } from '@redux-saga/types'\nexport * as Rooms from './rooms'\nexport * as Chat from './chat'\nexport * as PubSub from './pubSub'\nexport * as MemberPosition from './memberPosition'\nexport type {\n  RoomSessionRecording,\n  RoomSessionPlayback,\n  RoomSessionStream,\n} from './rooms'\nexport const selectors = {\n  ...sessionSelectors,\n}\nexport { ChatMember, ChatMessage } from './chat'\nexport { PubSubMessage } from './pubSub'\nexport * as testUtils from './testUtils'\n", "import { BaseComponent, EventEmitter } from '..'\n\nexport interface BaseRoomInterface<\n  EventTypes extends EventEmitter.ValidEventTypes\n> extends BaseComponent<EventTypes> {\n  roomId: string\n  roomSessionId: string\n  memberId: string\n}\n\nexport * from './methods'\nexport * from './RoomSessionRecording'\nexport * from './RoomSessionPlayback'\nexport * from './RoomSessionStream'\n", "import type {\n  BaseRoomInterface,\n  RoomSessionRecording,\n  RoomSessionPlayback,\n  RoomSessionStream,\n} from '.'\nimport type {\n  VideoMemberEntity,\n  MemberCommandParams,\n  VideoPosition,\n} from '../types'\nimport { toLocalEvent } from '../utils'\nimport type {\n  ExecuteExtendedOptions,\n  RoomMethod,\n  BaseRPCResult,\n  MediaAllowed,\n  VideoMeta,\n} from '../utils/interfaces'\n\ntype RoomMethodParams = Record<string, unknown>\n\ninterface RoomMethodPropertyDescriptor<OutputType, ParamsType>\n  extends PropertyDescriptor {\n  value: (params: ParamsType) => Promise<OutputType>\n}\n\ntype RoomMethodDescriptor<\n  OutputType = unknown,\n  ParamsType = RoomMethodParams\n> = RoomMethodPropertyDescriptor<OutputType, ParamsType> &\n  // TODO: Replace string with a tighter type\n  ThisType<BaseRoomInterface<string>>\n\n/**\n * Transform for returning `undefined` for `execute`s that were\n * successully resolved. If the `execute` failed for some reason, then\n * the promise will be rejected and this transform will never be\n * executed.\n */\nconst baseCodeTransform = () => {}\n\nconst createRoomMethod = <\n  InputType,\n  OutputType = InputType,\n  ParamsType extends RoomMethodParams = RoomMethodParams\n>(\n  method: RoomMethod,\n  options: ExecuteExtendedOptions<InputType, OutputType, ParamsType> = {}\n): RoomMethodDescriptor<OutputType, ParamsType> => ({\n  value: function (params = {} as ParamsType): Promise<OutputType> {\n    return this.execute(\n      {\n        method,\n        params: {\n          room_session_id: this.roomSessionId,\n          ...params,\n        },\n      },\n      options\n    )\n  },\n})\n\n/**\n * Type the params for each room member method that uses the provided\n * memberId or fallback to the instance memberId. Additional params\n * can be passed as `value` or `volume`.\n */\ninterface RoomMemberMethodParams extends Record<string, unknown> {\n  memberId?: string\n}\n\nconst createRoomMemberMethod = <\n  InputType,\n  OutputType,\n  ParamsType extends RoomMemberMethodParams = RoomMemberMethodParams\n>(\n  method: RoomMethod,\n  options: ExecuteExtendedOptions<InputType, OutputType, ParamsType> = {}\n): RoomMethodDescriptor<OutputType, ParamsType> => ({\n  value: function ({ memberId, ...rest } = {} as ParamsType) {\n    return this.execute(\n      {\n        method,\n        params: {\n          room_session_id: this.roomSessionId,\n          member_id: memberId || this.memberId,\n          ...rest,\n        },\n      },\n      options\n    )\n  },\n})\n\n/**\n * Room Methods\n */\nexport const getLayouts = createRoomMethod<{ layouts: string[] }>(\n  'video.list_available_layouts',\n  {\n    transformResolve: (payload) => ({ layouts: payload.layouts }),\n  }\n)\nexport const getMembers = createRoomMethod<{ members: VideoMemberEntity[] }>(\n  'video.members.get',\n  {\n    transformResolve: (payload) => ({ members: payload.members }),\n  }\n)\nexport interface SetLayoutParams {\n  name: string\n  positions?: Record<string, VideoPosition>\n}\nexport const setLayout = createRoomMethod<BaseRPCResult, void>(\n  'video.set_layout',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport interface SetPositionsParams {\n  positions: Record<string, VideoPosition>\n}\nexport const setPositions = createRoomMethod<BaseRPCResult, void>(\n  'video.set_position',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport const hideVideoMuted = createRoomMethod<BaseRPCResult, void>(\n  'video.hide_video_muted',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport const showVideoMuted = createRoomMethod<BaseRPCResult, void>(\n  'video.show_video_muted',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\n\nexport const setHideVideoMuted: RoomMethodDescriptor<void, boolean> = {\n  value: function (value) {\n    return this.execute(\n      {\n        method: value ? 'video.hide_video_muted' : 'video.show_video_muted',\n        params: {\n          room_session_id: this.roomSessionId,\n        },\n      },\n      {\n        transformResolve: baseCodeTransform,\n      }\n    )\n  },\n}\n\nexport interface GetRecordingsOutput {\n  recordings: RoomSessionRecording[]\n}\n\nexport const getRecordings: RoomMethodDescriptor<GetRecordingsOutput> = {\n  value: function () {\n    return new Promise(async (resolve) => {\n      const handler = (instance: any) => {\n        resolve(instance)\n      }\n      this.on(toLocalEvent('video.recording.list'), handler)\n\n      try {\n        const payload = await this.execute({\n          method: 'video.recording.list',\n          params: {\n            room_session_id: this.roomSessionId,\n          },\n        })\n        this.emit(toLocalEvent('video.recording.list'), {\n          ...(payload as object),\n          room_session_id: this.roomSessionId,\n        })\n      } catch (error) {\n        this.off(toLocalEvent('video.recording.list'), handler)\n        throw error\n      }\n    })\n  },\n}\n\nexport const startRecording: RoomMethodDescriptor<void> = {\n  value: function () {\n    return new Promise(async (resolve) => {\n      const handler = (instance: any) => {\n        resolve(instance)\n      }\n      this.on(toLocalEvent('video.recording.start'), handler)\n\n      try {\n        const payload = await this.execute({\n          method: 'video.recording.start',\n          params: {\n            room_session_id: this.roomSessionId,\n          },\n        })\n        this.emit(toLocalEvent('video.recording.start'), {\n          ...(payload as object),\n          room_session_id: this.roomSessionId,\n        })\n      } catch (error) {\n        this.off(toLocalEvent('video.recording.start'), handler)\n        throw error\n      }\n    })\n  },\n}\n\nexport interface GetPlaybacksOutput {\n  playbacks: RoomSessionPlayback[]\n}\n\nexport const getPlaybacks: RoomMethodDescriptor<GetPlaybacksOutput> = {\n  value: function () {\n    return new Promise(async (resolve) => {\n      const handler = (instance: any) => {\n        resolve(instance)\n      }\n      this.on(toLocalEvent('video.playback.list'), handler)\n\n      try {\n        const payload = await this.execute({\n          method: 'video.playback.list',\n          params: {\n            room_session_id: this.roomSessionId,\n          },\n        })\n        this.emit(toLocalEvent('video.playback.list'), {\n          ...(payload as object),\n          room_session_id: this.roomSessionId,\n        })\n      } catch (error) {\n        this.off(toLocalEvent('video.playback.list'), handler)\n        throw error\n      }\n    })\n  },\n}\n\nexport type PlayParams = {\n  url: string\n  volume?: number\n  positions?: Record<string, VideoPosition>\n  layout?: string\n  currentTimecode?: number\n}\nexport const play: RoomMethodDescriptor<any, PlayParams> = {\n  value: function (params) {\n    return new Promise(async (resolve) => {\n      const handler = (instance: any) => {\n        resolve(instance)\n      }\n      this.on(toLocalEvent('video.playback.start'), handler)\n\n      try {\n        const payload = await this.execute({\n          method: 'video.playback.start',\n          params: {\n            room_session_id: this.roomSessionId,\n            ...params,\n          },\n        })\n        this.emit(toLocalEvent('video.playback.start'), {\n          ...(payload as object),\n          room_session_id: this.roomSessionId,\n        })\n      } catch (error) {\n        this.off(toLocalEvent('video.playback.start'), handler)\n        throw error\n      }\n    })\n  },\n}\n\nconst createRoomMetaMethod = <ParamsType extends RoomMethodParams>(\n  method: RoomMethod\n) => {\n  return createRoomMethod<BaseRPCResult, void, ParamsType>(method, {\n    transformResolve: baseCodeTransform,\n    transformParams: (params) => {\n      const { room_session_id, ...meta } = params\n      return { room_session_id, meta }\n    },\n  })\n}\n\ninterface GetMetaOutput {\n  meta: VideoMeta\n}\n\nexport const getMeta = createRoomMethod<GetMetaOutput>('video.get_meta', {\n  transformResolve: ({ meta }) => ({ meta }),\n})\n\nexport interface SetMetaParams extends Record<string, unknown> {}\nexport const setMeta = createRoomMetaMethod<SetMetaParams>('video.set_meta')\n\nexport interface UpdateMetaParams extends Record<string, unknown> {}\nexport const updateMeta =\n  createRoomMetaMethod<UpdateMetaParams>('video.update_meta')\n\nexport type DeleteMetaParams = string[]\nexport const deleteMeta: RoomMethodDescriptor<any, DeleteMetaParams> = {\n  value: function (params) {\n    return this.execute({\n      method: 'video.delete_meta',\n      params: {\n        room_session_id: this.roomSessionId,\n        keys: params,\n      },\n    })\n  },\n}\n\nexport interface GetStreamsOutput {\n  streams: RoomSessionStream[]\n}\n\nexport const getStreams: RoomMethodDescriptor<GetStreamsOutput> = {\n  value: function () {\n    return new Promise(async (resolve) => {\n      const handler = (instance: any) => {\n        resolve(instance)\n      }\n      this.on(toLocalEvent('video.stream.list'), handler)\n\n      try {\n        const payload = await this.execute({\n          method: 'video.stream.list',\n          params: {\n            room_session_id: this.roomSessionId,\n          },\n        })\n        this.emit(toLocalEvent('video.stream.list'), {\n          ...(payload as object),\n          room_session_id: this.roomSessionId,\n        })\n      } catch (error) {\n        this.off(toLocalEvent('video.stream.list'), handler)\n        throw error\n      }\n    })\n  },\n}\n\nexport interface StartStreamParams {\n  url: string\n}\nexport const startStream: RoomMethodDescriptor<any, StartStreamParams> = {\n  value: function (params) {\n    return new Promise(async (resolve) => {\n      const handler = (instance: any) => {\n        resolve(instance)\n      }\n      this.on(toLocalEvent('video.stream.start'), handler)\n\n      try {\n        const payload = await this.execute({\n          method: 'video.stream.start',\n          params: {\n            room_session_id: this.roomSessionId,\n            ...params,\n          },\n        })\n        this.emit(toLocalEvent('video.stream.start'), {\n          ...(payload as object),\n          room_session_id: this.roomSessionId,\n        })\n      } catch (error) {\n        this.off(toLocalEvent('video.stream.start'), handler)\n        throw error\n      }\n    })\n  },\n}\n\nexport type GetLayouts = ReturnType<typeof getLayouts.value>\nexport type GetMembers = ReturnType<typeof getMembers.value>\nexport type HideVideoMuted = ReturnType<typeof hideVideoMuted.value>\nexport type ShowVideoMuted = ReturnType<typeof showVideoMuted.value>\nexport type SetHideVideoMuted = ReturnType<typeof setHideVideoMuted.value>\n\nexport type GetRecordings = ReturnType<typeof getRecordings.value>\nexport type StartRecording = ReturnType<typeof startRecording.value>\n\nexport type GetPlaybacks = ReturnType<typeof getPlaybacks.value>\nexport type Play = ReturnType<typeof play.value>\nexport type GetMeta = ReturnType<typeof getMeta.value>\nexport type SetMeta = ReturnType<typeof setMeta.value>\nexport type UpdateMeta = ReturnType<typeof updateMeta.value>\nexport type DeleteMeta = ReturnType<typeof deleteMeta.value>\n\nexport type GetStreams = ReturnType<typeof getStreams.value>\nexport type StartStream = ReturnType<typeof startStream.value>\n// End Room Methods\n\n/**\n * Room Member Methods\n */\nexport const audioMuteMember = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.audio_mute',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport const audioUnmuteMember = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.audio_unmute',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport const videoMuteMember = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.video_mute',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport const videoUnmuteMember = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.video_unmute',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport const deafMember = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.deaf',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport const undeafMember = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.undeaf',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\n// This is used on a RoomSessionMember instance where we have\n// `this.roomSessionId` and `this.memberId`\nexport const setDeaf: RoomMethodDescriptor<void, boolean> = {\n  value: function (value) {\n    return this.execute(\n      {\n        method: value ? 'video.member.deaf' : 'video.member.undeaf',\n        params: {\n          room_session_id: this.roomSessionId,\n          member_id: this.memberId,\n        },\n      },\n      {\n        transformResolve: baseCodeTransform,\n      }\n    )\n  },\n}\nexport const setInputVolumeMember = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.set_input_volume',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport const setOutputVolumeMember = createRoomMemberMethod<\n  BaseRPCResult,\n  void\n>('video.member.set_output_volume', {\n  transformResolve: baseCodeTransform,\n})\nexport const setInputSensitivityMember = createRoomMemberMethod<\n  BaseRPCResult,\n  void\n>('video.member.set_input_sensitivity', {\n  transformResolve: baseCodeTransform,\n})\n\ninterface PromoteDemoteMemberParams extends Required<MemberCommandParams> {\n  mediaAllowed?: MediaAllowed\n}\n\nexport interface PromoteMemberParams extends PromoteDemoteMemberParams {\n  permissions?: string[]\n  meta?: VideoMeta\n  joinAudioMuted?: boolean\n  joinVideoMuted?: boolean\n}\nexport const promote: RoomMethodDescriptor<void, PromoteMemberParams> = {\n  value: function ({\n    memberId,\n    mediaAllowed,\n    joinAudioMuted,\n    joinVideoMuted,\n    ...rest\n  }) {\n    return this.execute<unknown, void, PromoteMemberParams>(\n      {\n        method: 'video.member.promote',\n        params: {\n          room_session_id: this.roomSessionId,\n          member_id: memberId,\n          media_allowed: mediaAllowed,\n          join_audio_muted: joinAudioMuted,\n          join_video_muted: joinVideoMuted,\n          ...rest,\n        },\n      },\n      {\n        transformResolve: baseCodeTransform as any,\n      }\n    )\n  },\n}\n\nexport interface DemoteMemberParams extends PromoteDemoteMemberParams {}\nexport const demote: RoomMethodDescriptor<void, DemoteMemberParams> = {\n  value: function ({ memberId, mediaAllowed }) {\n    return this.execute<unknown, void, DemoteMemberParams>(\n      {\n        method: 'video.member.demote',\n        params: {\n          room_session_id: this.roomSessionId,\n          member_id: memberId,\n          media_allowed: mediaAllowed,\n        },\n      },\n      {\n        transformResolve: baseCodeTransform as any,\n      }\n    )\n  },\n}\n\nexport interface SetMemberPositionParams extends MemberCommandParams {\n  position: VideoPosition\n}\nexport const setMemberPosition = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.set_position',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport const removeMember: RoomMethodDescriptor<\n  void,\n  Required<RoomMemberMethodParams>\n> = {\n  value: function ({ memberId, ...rest }) {\n    if (!memberId) {\n      throw new TypeError('Invalid or missing \"memberId\" argument')\n    }\n    return this.execute(\n      {\n        method: 'video.member.remove',\n        params: {\n          room_session_id: this.roomSessionId,\n          member_id: memberId,\n          ...rest,\n        },\n      },\n      {\n        transformResolve: baseCodeTransform,\n      }\n    )\n  },\n}\n\nexport const removeAllMembers: RoomMethodDescriptor<void, void> = {\n  value: function () {\n    return this.execute(\n      {\n        method: 'video.member.remove',\n        params: {\n          room_session_id: this.roomSessionId,\n          member_id: 'all',\n        },\n      },\n      {\n        transformResolve: baseCodeTransform,\n      }\n    )\n  },\n}\n\ninterface GetMemberMetaOutput {\n  meta: VideoMeta\n}\n\nexport const getMemberMeta = createRoomMemberMethod<\n  BaseRPCResult & VideoMeta,\n  GetMemberMetaOutput\n>('video.member.get_meta', {\n  transformResolve: ({ meta }) => ({ meta }),\n})\nexport interface SetMemberMetaParams extends MemberCommandParams {\n  meta: VideoMeta\n}\nexport const setMemberMeta = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.set_meta',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\n\nexport interface UpdateMemberMetaParams extends MemberCommandParams {\n  meta: VideoMeta\n}\nexport const updateMemberMeta = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.update_meta',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\nexport interface DeleteMemberMetaParams extends MemberCommandParams {\n  keys: string[]\n}\nexport const deleteMemberMeta = createRoomMemberMethod<BaseRPCResult, void>(\n  'video.member.delete_meta',\n  {\n    transformResolve: baseCodeTransform,\n  }\n)\n\nexport type AudioMuteMember = ReturnType<typeof audioMuteMember.value>\nexport type AudioUnmuteMember = ReturnType<typeof audioUnmuteMember.value>\nexport type VideoMuteMember = ReturnType<typeof videoMuteMember.value>\nexport type VideoUnmuteMember = ReturnType<typeof videoUnmuteMember.value>\nexport type DeafMember = ReturnType<typeof deafMember.value>\nexport type UndeafMember = ReturnType<typeof undeafMember.value>\nexport type SetDeaf = ReturnType<typeof setDeaf.value>\nexport type SetLayout = ReturnType<typeof setLayout.value>\nexport type SetPositions = ReturnType<typeof setPositions.value>\nexport type SetInputVolumeMember = ReturnType<typeof setInputVolumeMember.value>\nexport type SetOutputVolumeMember = ReturnType<\n  typeof setOutputVolumeMember.value\n>\nexport type SetInputSensitivityMember = ReturnType<\n  typeof setInputSensitivityMember.value\n>\nexport type SetMemberPosition = ReturnType<typeof setMemberPosition.value>\nexport type RemoveMember = ReturnType<typeof removeMember.value>\nexport type RemoveAllMembers = ReturnType<typeof removeAllMembers.value>\nexport type GetMemberMeta = ReturnType<typeof getMemberMeta.value>\nexport type SetMemberMeta = ReturnType<typeof setMemberMeta.value>\nexport type UpdateMemberMeta = ReturnType<typeof updateMemberMeta.value>\nexport type DeleteMemberMeta = ReturnType<typeof deleteMemberMeta.value>\nexport type PromoteMember = ReturnType<typeof promote.value>\nexport type DemoteMember = ReturnType<typeof demote.value>\n// End Room Member Methods\n", "import { connect } from '../redux'\nimport { BaseComponent } from '../BaseComponent'\nimport { BaseComponentOptions } from '../utils/interfaces'\nimport { OnlyFunctionProperties } from '../types'\nimport type {\n  VideoRecordingContract,\n  VideoRecordingEventNames,\n} from '../types/videoRecording'\n\n/**\n * Represents a specific recording of a room session.\n */\nexport interface RoomSessionRecording extends VideoRecordingContract {}\n\nexport type RoomSessionRecordingEventsHandlerMapping = Record<\n  VideoRecordingEventNames,\n  (recording: RoomSessionRecording) => void\n>\n\nexport class RoomSessionRecordingAPI\n  extends BaseComponent<RoomSessionRecordingEventsHandlerMapping>\n  implements OnlyFunctionProperties<RoomSessionRecording>\n{\n  async pause() {\n    await this.execute({\n      method: 'video.recording.pause',\n      params: {\n        room_session_id: this.getStateProperty('roomSessionId'),\n        recording_id: this.getStateProperty('id'),\n      },\n    })\n  }\n\n  async resume() {\n    await this.execute({\n      method: 'video.recording.resume',\n      params: {\n        room_session_id: this.getStateProperty('roomSessionId'),\n        recording_id: this.getStateProperty('id'),\n      },\n    })\n  }\n\n  async stop() {\n    await this.execute({\n      method: 'video.recording.stop',\n      params: {\n        room_session_id: this.getStateProperty('roomSessionId'),\n        recording_id: this.getStateProperty('id'),\n      },\n    })\n  }\n}\n\nexport const createRoomSessionRecordingObject = (\n  params: BaseComponentOptions<RoomSessionRecordingEventsHandlerMapping>\n): RoomSessionRecording => {\n  const recording = connect<\n    RoomSessionRecordingEventsHandlerMapping,\n    RoomSessionRecordingAPI,\n    RoomSessionRecording\n  >({\n    store: params.store,\n    Component: RoomSessionRecordingAPI,\n    componentListeners: {\n      errors: 'onError',\n      responses: 'onSuccess',\n    },\n  })(params)\n\n  return recording\n}\n", "import { connect } from '../redux'\nimport { BaseComponent } from '../BaseComponent'\nimport { BaseComponentOptions } from '../utils/interfaces'\nimport type {\n  VideoPlaybackContract,\n  VideoPlaybackMethods,\n  VideoPlaybackEventNames,\n} from '../types/videoPlayback'\n\n/**\n * Instances of this class allow you to control (e.g., pause, resume, stop) the\n * playback inside a room session. You can obtain instances of this class by\n * starting a playback from the desired {@link RoomSession} (see\n * {@link RoomSession.play})\n */\nexport interface RoomSessionPlayback extends VideoPlaybackContract {}\n\nexport type RoomSessionPlaybackEventsHandlerMapping = Record<\n  VideoPlaybackEventNames,\n  (playback: RoomSessionPlayback) => void\n>\n\nexport class RoomSessionPlaybackAPI\n  extends BaseComponent<RoomSessionPlaybackEventsHandlerMapping>\n  implements VideoPlaybackMethods\n{\n  async pause() {\n    await this.execute({\n      method: 'video.playback.pause',\n      params: {\n        room_session_id: this.getStateProperty('roomSessionId'),\n        playback_id: this.getStateProperty('id'),\n      },\n    })\n  }\n\n  async resume() {\n    await this.execute({\n      method: 'video.playback.resume',\n      params: {\n        room_session_id: this.getStateProperty('roomSessionId'),\n        playback_id: this.getStateProperty('id'),\n      },\n    })\n  }\n\n  async stop() {\n    await this.execute({\n      method: 'video.playback.stop',\n      params: {\n        room_session_id: this.getStateProperty('roomSessionId'),\n        playback_id: this.getStateProperty('id'),\n      },\n    })\n  }\n\n  async setVolume(volume: number) {\n    await this.execute({\n      method: 'video.playback.set_volume',\n      params: {\n        room_session_id: this.getStateProperty('roomSessionId'),\n        playback_id: this.getStateProperty('id'),\n        volume,\n      },\n    })\n  }\n\n  async seek(timecode: number) {\n    await this.execute({\n      method: 'video.playback.seek_absolute',\n      params: {\n        room_session_id: this.getStateProperty('roomSessionId'),\n        playback_id: this.getStateProperty('id'),\n        position: Math.abs(timecode),\n      },\n    })\n  }\n\n  async forward(offset: number = 5000) {\n    await this.execute({\n      method: 'video.playback.seek_relative',\n      params: {\n        room_session_id: this.getStateProperty('roomSessionId'),\n        playback_id: this.getStateProperty('id'),\n        position: Math.abs(offset),\n      },\n    })\n  }\n\n  async rewind(offset: number = 5000) {\n    await this.execute({\n      method: 'video.playback.seek_relative',\n      params: {\n        room_session_id: this.getStateProperty('roomSessionId'),\n        playback_id: this.getStateProperty('id'),\n        position: -Math.abs(offset),\n      },\n    })\n  }\n}\n\nexport const createRoomSessionPlaybackObject = (\n  params: BaseComponentOptions<RoomSessionPlaybackEventsHandlerMapping>\n): RoomSessionPlayback => {\n  const playback = connect<\n    RoomSessionPlaybackEventsHandlerMapping,\n    RoomSessionPlaybackAPI,\n    RoomSessionPlayback\n  >({\n    store: params.store,\n    Component: RoomSessionPlaybackAPI,\n    componentListeners: {\n      errors: 'onError',\n      responses: 'onSuccess',\n    },\n  })(params)\n\n  return playback\n}\n", "import { connect } from '../redux'\nimport { BaseComponent } from '../BaseComponent'\nimport { BaseComponentOptions } from '../utils/interfaces'\nimport { OnlyFunctionProperties } from '../types'\nimport type {\n  VideoStreamContract,\n  VideoStreamEventNames,\n} from '../types/videoStream'\n\n/**\n * Represents a specific Stream of a room session.\n */\nexport interface RoomSessionStream extends VideoStreamContract {}\n\nexport type RoomSessionStreamEventsHandlerMapping = Record<\n  VideoStreamEventNames,\n  (stream: RoomSessionStream) => void\n>\n\nexport class RoomSessionStreamAPI\n  extends BaseComponent<RoomSessionStreamEventsHandlerMapping>\n  implements OnlyFunctionProperties<RoomSessionStream>\n{\n  async stop() {\n    await this.execute({\n      method: 'video.stream.stop',\n      params: {\n        room_session_id: this.getStateProperty('roomSessionId'),\n        stream_id: this.getStateProperty('id'),\n      },\n    })\n  }\n}\n\nexport const createRoomSessionStreamObject = (\n  params: BaseComponentOptions<RoomSessionStreamEventsHandlerMapping>\n): RoomSessionStream => {\n  const stream = connect<\n    RoomSessionStreamEventsHandlerMapping,\n    RoomSessionStreamAPI,\n    RoomSessionStream\n  >({\n    store: params.store,\n    Component: RoomSessionStreamAPI,\n    componentListeners: {\n      errors: 'onError',\n      responses: 'onSuccess',\n    },\n  })(params)\n\n  return stream\n}\n", "export * from './methods'\nexport * from './BaseChat'\nexport * from './ChatMessage'\nexport * from './ChatMember'\n", "import { InternalChatChannel } from '../..'\n\nexport const toInternalChatChannels = (\n  channels: string | string[] | undefined\n): InternalChatChannel[] => {\n  const list = !channels || Array.isArray(channels) ? channels : [channels]\n\n  if (Array.isArray(list)) {\n    return list.map((name) => {\n      return {\n        name,\n      }\n    })\n  }\n\n  return []\n}\n", "export * from './toInternalChatChannels'\n\nexport const isValidChannels = (input: unknown): input is string | string[] => {\n  return Array.isArray(input) || typeof input === 'string'\n}\n", "import type {\n  ChatJSONRPCMethod,\n  InternalChatMessageEntity,\n  ChatMessageEntity,\n  InternalChatMemberEntity,\n  ChatMemberEntity,\n} from '../types/chat'\nimport type { PaginationCursor } from '../types/common'\nimport type { BaseChatConsumer } from './BaseChat'\nimport type { ExecuteExtendedOptions, BaseRPCResult } from '../utils/interfaces'\nimport { toExternalJSON } from '../utils'\nimport { toInternalChatChannels, isValidChannels } from './utils'\n\ntype ChatMethodParams = Record<string, unknown>\n\ninterface ChatMethodPropertyDescriptor<OutputType, ParamsType>\n  extends PropertyDescriptor {\n  value: (params: ParamsType) => Promise<OutputType>\n}\ntype ChatMethodDescriptor<\n  OutputType = unknown,\n  ParamsType = ChatMethodParams\n> = ChatMethodPropertyDescriptor<OutputType, ParamsType> &\n  ThisType<BaseChatConsumer>\n\n/**\n * Transform for returning `undefined` for `execute`s that were\n * successully resolved. If the `execute` failed for some reason, then\n * the promise will be rejected and this transform will never be\n * executed.\n */\nconst baseCodeTransform = () => {}\n\nconst createChatMethod = <\n  InputType,\n  OutputType = InputType,\n  ParamsType extends ChatMethodParams = ChatMethodParams\n>(\n  method: ChatJSONRPCMethod,\n  options: ExecuteExtendedOptions<InputType, OutputType, ParamsType> = {}\n): ChatMethodDescriptor<OutputType> => ({\n  value: function (params = {}): Promise<OutputType> {\n    return this.execute(\n      {\n        method,\n        params,\n      },\n      options\n    )\n  },\n})\n\n/**\n * Type the params for each chat method that requires a memberId.\n * Additional params can be passed.\n */\ninterface ChatMemberMethodParams extends Record<string, unknown> {\n  memberId?: string\n}\n\nconst createChatMemberMethod = <\n  InputType,\n  OutputType = InputType,\n  ParamsType extends ChatMemberMethodParams = ChatMemberMethodParams\n>(\n  method: ChatJSONRPCMethod,\n  options: ExecuteExtendedOptions<InputType, OutputType, ParamsType> = {}\n): ChatMethodDescriptor<OutputType> => ({\n  value: function ({ memberId, ...rest } = {}) {\n    return this.execute(\n      {\n        method,\n        params: {\n          member_id: memberId,\n          ...rest,\n        },\n      },\n      options\n    )\n  },\n})\n\n/**\n * Chat Methods\n */\nexport const publish = createChatMethod<BaseRPCResult, void>('chat.publish', {\n  transformResolve: baseCodeTransform,\n})\n\ninterface GetMessagesInput extends BaseRPCResult {\n  messages: InternalChatMessageEntity[]\n  cursor: PaginationCursor\n}\ninterface GetMessagesOutput {\n  messages: ChatMessageEntity[]\n  cursor: PaginationCursor\n}\nexport const getMessages = createChatMethod<\n  GetMessagesInput,\n  GetMessagesOutput\n>('chat.messages.get', {\n  transformResolve: (payload) => ({\n    messages: payload.messages.map((message) => toExternalJSON(message)),\n    cursor: payload.cursor,\n  }),\n})\n\ninterface GetMembersInput extends BaseRPCResult {\n  members: InternalChatMemberEntity[]\n}\ninterface GetMembersOutput {\n  members: ChatMemberEntity[]\n}\nexport const getMembers = createChatMethod<GetMembersInput, GetMembersOutput>(\n  'chat.members.get',\n  {\n    transformResolve: (payload) => ({\n      members: payload.members.map((member) => toExternalJSON(member)),\n    }),\n  }\n)\n\nconst transformParamChannels = (params: ChatMemberMethodParams) => {\n  const channels = isValidChannels(params?.channels)\n    ? toInternalChatChannels(params.channels)\n    : undefined\n\n  return {\n    ...params,\n    channels,\n  }\n}\n/**\n * Chat Member Methods\n */\nexport const setMemberState = createChatMemberMethod<BaseRPCResult, void>(\n  'chat.member.set_state',\n  {\n    transformResolve: baseCodeTransform,\n    transformParams: transformParamChannels,\n  }\n)\n\ninterface GetMemberStateInput extends BaseRPCResult {\n  channels: any\n}\ninterface GetMemberStateOutput {\n  channels: any\n}\nexport const getMemberState = createChatMemberMethod<\n  GetMemberStateInput,\n  GetMemberStateOutput\n>('chat.member.get_state', {\n  transformResolve: (payload) => ({ channels: payload.channels }),\n  transformParams: transformParamChannels,\n})\n", "export * from './BasePubSub'\nexport * from './PubSubMessage'\n", "import { PubSubMessageContract } from '..'\n\n/**\n * Represents a message in a pubSub context.\n */\nexport class PubSubMessage<\n  PayloadType extends PubSubMessageContract = PubSubMessageContract\n> implements PubSubMessageContract\n{\n  constructor(protected payload: PayloadType) {}\n\n  /** The id of this message */\n  get id(): string {\n    return this.payload.id\n  }\n\n  /** The channel in which this message was sent */\n  get channel(): string {\n    return this.payload.channel\n  }\n\n  /** The content of this message */\n  get content(): string {\n    return this.payload.content\n  }\n\n  /** Any metadata associated to this message */\n  get meta(): any {\n    return this.payload.meta\n  }\n\n  /** The date at which this message was published */\n  get publishedAt(): Date {\n    return this.payload.publishedAt\n  }\n}\n", "import { BasePubSubConsumer } from './BasePubSub'\nimport {\n  sagaEffects,\n  SagaIterator,\n  SDKWorker,\n  getLogger,\n  PubSubEventAction,\n} from '..'\nimport { PRODUCT_PREFIX_PUBSUB } from '../utils/constants'\n\nexport const pubSubWorker: SDKWorker<BasePubSubConsumer> =\n  function* pubSubWorker({ channels: { pubSubChannel } }): SagaIterator {\n    while (true) {\n      const action: PubSubEventAction = yield sagaEffects.take(\n        (action: any) => {\n          return action.type.startsWith(`${PRODUCT_PREFIX_PUBSUB}.`)\n        }\n      )\n\n      switch (action.type) {\n        case `${PRODUCT_PREFIX_PUBSUB}.channel.message`: {\n          yield sagaEffects.put(pubSubChannel, {\n            /**\n             * FIXME: This is a hack to get the message to the\n             * correct channel. We'll fix this once we have a\n             * proper way to setup the prefix `channel` at a\n             * BaseConsumer level.\n             */\n            type: `${PRODUCT_PREFIX_PUBSUB}.message` as any,\n            payload: action.payload,\n          })\n          break\n        }\n\n        default: {\n          getLogger().debug('[pubSubWorker] Unrecognized Action', action)\n          break\n        }\n      }\n    }\n  }\n", "import {\n  BaseComponentOptions,\n  BaseConsumer,\n  connect,\n  JSONRPCSubscribeMethod,\n  ExecuteParams,\n  actions,\n  SessionEvents,\n  EventEmitter,\n  EventTransform,\n  toExternalJSON,\n} from '..'\nimport { getAuthState } from '../redux/features/session/sessionSelectors'\nimport type {\n  PubSubChannel,\n  InternalPubSubChannel,\n  PubSubEventNames,\n  PubSubPublishParams,\n  PubSubMessageEventName,\n  PubSubChannelMessageEvent,\n} from '../types/pubSub'\nimport { PRODUCT_PREFIX_PUBSUB } from '../utils/constants'\nimport { PubSubMessage } from './PubSubMessage'\nimport * as workers from './workers'\n\nexport type BasePubSubApiEventsHandlerMapping = Record<\n  PubSubMessageEventName,\n  (message: PubSubMessage) => void\n> &\n  Record<Extract<SessionEvents, 'session.expiring'>, () => void>\n\n/**\n * @privateRemarks\n *\n * Each package will have the option to either extend this\n * type or provide their own event mapping.\n */\nexport type BasePubSubApiEvents<T = BasePubSubApiEventsHandlerMapping> = {\n  [k in keyof T]: T[k]\n}\n\nconst toInternalPubSubChannels = (\n  channels: string[]\n): InternalPubSubChannel[] => {\n  return channels.map((name) => {\n    return {\n      name,\n    }\n  })\n}\n\nexport class BasePubSubConsumer<\n  EventTypes extends EventEmitter.ValidEventTypes = BasePubSubApiEvents\n> extends BaseConsumer<EventTypes> {\n  protected override _eventsPrefix = PRODUCT_PREFIX_PUBSUB\n  protected override subscribeMethod: JSONRPCSubscribeMethod = `${PRODUCT_PREFIX_PUBSUB}.subscribe`\n\n  constructor(options: BaseComponentOptions<EventTypes>) {\n    super(options)\n\n    /**\n     * Since we don't need a namespace for these events\n     * we'll attach them as soon as the Client has been\n     * registered in the Redux store.\n     */\n    this._attachListeners('')\n\n    this.runWorker('pubSub', { worker: workers.pubSubWorker })\n  }\n\n  /** @internal */\n  protected getEmitterTransforms() {\n    return new Map<any, EventTransform>([\n      [\n        ['message'],\n        {\n          type: 'pubSubMessage',\n          instanceFactory: () => {\n            return new PubSubMessage({} as any)\n          },\n          payloadTransform: (payload: PubSubChannelMessageEvent) => {\n            const {\n              channel,\n              /**\n               * Since we're using the same event as `Chat`\n               * the payload comes with a `member` prop. To\n               * avoid confusion (since `PubSub` doesn't\n               * have members) we'll remove it from the\n               * payload sent to the end user.\n               */\n              // @ts-expect-error\n              message: { member, ...restMessage },\n            } = payload.params\n            return toExternalJSON({\n              ...restMessage,\n              channel,\n            })\n          },\n        },\n      ],\n    ])\n  }\n\n  private _getChannelsParam(\n    channels: string | string[] | undefined,\n    method: 'subscribe' | 'unsubscribe'\n  ) {\n    const _channels =\n      !channels || Array.isArray(channels) ? channels : [channels]\n\n    if (!Array.isArray(_channels) || _channels.length === 0) {\n      throw new Error(\n        `Please specify one or more channels when calling .${method}()`\n      )\n    }\n\n    return {\n      channels: toInternalPubSubChannels(_channels),\n    }\n  }\n\n  /** @internal */\n  protected _setSubscribeParams(params: Record<string, any>) {\n    this.subscribeParams = {\n      ...this.subscribeParams,\n      ...params,\n    }\n  }\n\n  /** @internal */\n  protected _getSubscribeParams({ channels }: { channels?: PubSubChannel }) {\n    return {\n      ...this._getChannelsParam(channels, 'subscribe'),\n    }\n  }\n\n  /** @internal */\n  protected _getUnsubscribeParams({ channels }: { channels?: PubSubChannel }) {\n    const channelsParam = this._getChannelsParam(channels, 'unsubscribe')\n\n    return {\n      ...channelsParam,\n    }\n  }\n\n  private _checkMissingSubscriptions() {\n    const subscriptions = this.getSubscriptions()\n    if (subscriptions.length === 0) {\n      this.logger.info(\n        'Subscribe was called before any listeners were attached. Move `.subscribe()` right after your event listeners to suppress this message.'\n      )\n      // @ts-ignore\n      this.once('message', () => {})\n    }\n  }\n\n  async subscribe(channels?: PubSubChannel) {\n    this._checkMissingSubscriptions()\n\n    const params = this._getSubscribeParams({ channels })\n\n    this._setSubscribeParams(params)\n\n    return super.subscribe()\n  }\n\n  async unsubscribe(channels: PubSubChannel): Promise<void> {\n    if (\n      this._sessionAuthStatus === 'unknown' ||\n      this._sessionAuthStatus === 'unauthorized'\n    ) {\n      throw new Error('You must be authenticated to unsubscribe from a channel')\n    }\n\n    const params = this._getUnsubscribeParams({ channels })\n\n    return new Promise(async (resolve, reject) => {\n      const subscriptions = this.getSubscriptions()\n\n      if (subscriptions.length > 0) {\n        const execParams: ExecuteParams = {\n          method: `${PRODUCT_PREFIX_PUBSUB}.unsubscribe`,\n          params: {\n            ...params,\n            events: subscriptions,\n          },\n        }\n\n        try {\n          await this.execute(execParams)\n        } catch (error) {\n          return reject(error)\n        }\n      } else {\n        this.logger.warn(\n          '`unsubscribe()` was called without any listeners attached.'\n        )\n      }\n\n      return resolve()\n    })\n  }\n\n  // Currently only `js` supports this features and it's\n  // being ignored (filtered at the Proxy level) within\n  // `realtime-api`\n  updateToken(token: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      // @ts-expect-error\n      this.once('session.auth_error', (error) => {\n        reject(error)\n      })\n      // @ts-expect-error\n      this.once('session.connected', () => {\n        resolve()\n      })\n\n      this.store.dispatch(actions.reauthAction({ token }))\n    })\n  }\n\n  publish(params: PubSubPublishParams) {\n    return this.execute({\n      method: `${PRODUCT_PREFIX_PUBSUB}.publish`,\n      params,\n    })\n  }\n\n  // Currently only `js` supports this features and it's\n  // being ignored (filtered at the Proxy level) within\n  // `realtime-api`\n  async getAllowedChannels() {\n    await this._waitUntilSessionAuthorized()\n    const authState = this.select(getAuthState)\n    if (authState && 'channels' in authState && authState.channels) {\n      return authState.channels\n    }\n    return {}\n  }\n}\n\nexport const createBasePubSubObject = <PubSubType>(\n  params: BaseComponentOptions<PubSubEventNames>\n) => {\n  const pubSub = connect<BasePubSubApiEvents, BasePubSubConsumer, PubSubType>({\n    store: params.store,\n    Component: BasePubSubConsumer,\n    componentListeners: {\n      errors: 'onError',\n      responses: 'onSuccess',\n    },\n  })(params)\n\n  return pubSub\n}\n", "import { ChatMemberContract } from '..'\n\n/**\n * Represents a member in a chat.\n */\nexport class ChatMember implements ChatMemberContract {\n  constructor(private payload: ChatMemberContract) {}\n\n  /** The id of this member */\n  get id(): string {\n    return this.payload.id\n  }\n\n  /** The channel of this member */\n  get channel(): string {\n    return this.payload.channel\n  }\n\n  /** The state of this member */\n  get state(): any {\n    return this.payload.state ?? {}\n  }\n}\n", "import { ChatMessageContract, ChatMemberContract } from '..'\nimport { PubSubMessage } from '../pubSub'\n\n/**\n * Represents a message in a chat.\n */\nexport class ChatMessage extends PubSubMessage<ChatMessageContract> {\n  /** The member which sent this message */\n  get member(): ChatMemberContract {\n    return this.payload.member\n  }\n}\n", "import { BaseChatConsumer } from './BaseChat'\nimport { sagaEffects, SagaIterator, SDKWorker, getLogger, ChatAction } from '..'\nimport { PRODUCT_PREFIX_PUBSUB, PRODUCT_PREFIX_CHAT } from '../utils/constants'\n\nexport const chatWorker: SDKWorker<BaseChatConsumer> = function* chatWorker({\n  channels: { pubSubChannel },\n}): SagaIterator {\n  while (true) {\n    const action: ChatAction = yield sagaEffects.take((action: any) => {\n      return action.type.startsWith('chat.')\n    })\n\n    switch (action.type) {\n      case 'chat.channel.message': {\n        /**\n         * Since `Chat` is built on top of `PubSub` (which\n         * also has a worker) and for the time being both\n         * namespaces are using the same PRODUCT_PREFIX\n         * there is an overlap on the `chat.channel.message`\n         * event which is automatically handled by\n         * `pubSubWorker`. This means that as long as both\n         * namespace share the same PRODUCT_PREFIX the\n         * `chat.channel.message` event will be a no-op for\n         * `Chat`.\n         */\n        if (PRODUCT_PREFIX_CHAT === PRODUCT_PREFIX_PUBSUB) {\n          break\n        }\n\n        yield sagaEffects.put(pubSubChannel, {\n          /**\n           * FIXME: This is a hack to get the message to the\n           * correct channel. We'll fix this once we have a\n           * proper way to setup the prefix `channel` at a\n           * BaseConsumer level.\n           */\n          type: 'chat.message' as any,\n          payload: action.payload,\n        })\n        break\n      }\n      case 'chat.member.joined':\n      case 'chat.member.updated':\n      case 'chat.member.left':\n        yield sagaEffects.put(pubSubChannel, action)\n        break\n\n      default: {\n        getLogger().debug('[chatWorker] Unrecognized Action', action)\n        break\n      }\n    }\n  }\n}\n", "import {\n  BaseComponentOptions,\n  connect,\n  EventTransform,\n  extendComponent,\n  JSONRPCSubscribeMethod,\n  SessionEvents,\n  toExternalJSON,\n} from '..'\nimport { BasePubSubConsumer } from '../pubSub'\nimport type {\n  ChatChannelMessageEvent,\n  ChatEventNames,\n  ChatMemberEventNames,\n  ChatMemberJoinedEvent,\n  ChatMemberLeftEvent,\n  ChatMemberUpdatedEvent,\n  ChatMessageEventName,\n  ChatMethods,\n} from '../types/chat'\nimport { PRODUCT_PREFIX_CHAT } from '../utils/constants'\nimport { ChatMember } from './ChatMember'\nimport { ChatMessage } from './ChatMessage'\nimport * as chatMethods from './methods'\nimport * as workers from './workers'\n\ntype ChatMemberEvent =\n  | ChatMemberJoinedEvent\n  | ChatMemberLeftEvent\n  | ChatMemberUpdatedEvent\nexport type BaseChatApiEventsHandlerMapping = Record<\n  ChatMessageEventName,\n  (message: ChatMessage) => void\n> &\n  Record<ChatMemberEventNames, (member: ChatMember) => void> &\n  Record<Extract<SessionEvents, 'session.expiring'>, () => void>\n\n/**\n * @privateRemarks\n *\n * Each package will have the option to either extend this\n * type or provide their own event mapping.\n */\nexport type BaseChatApiEvents<T = BaseChatApiEventsHandlerMapping> = {\n  [k in keyof T]: T[k]\n}\n\nexport class BaseChatConsumer extends BasePubSubConsumer<BaseChatApiEvents> {\n  protected override _eventsPrefix = PRODUCT_PREFIX_CHAT\n  protected override subscribeMethod: JSONRPCSubscribeMethod = `${PRODUCT_PREFIX_CHAT}.subscribe`\n\n  constructor(options: BaseComponentOptions<BaseChatApiEvents>) {\n    super(options)\n\n    this.runWorker('chat', { worker: workers.chatWorker })\n  }\n\n  /** @internal */\n  protected override getEmitterTransforms() {\n    return new Map<ChatEventNames | ChatEventNames[], EventTransform>([\n      [\n        ['message'],\n        {\n          type: 'chatMessage',\n          instanceFactory: () => {\n            return new ChatMessage({} as any)\n          },\n          payloadTransform: (payload: ChatChannelMessageEvent) => {\n            const { channel, message } = payload.params\n            return toExternalJSON({\n              ...message,\n              channel,\n            })\n          },\n        },\n      ],\n      [\n        ['member.joined', 'member.left', 'member.updated'],\n        {\n          type: 'chatMember',\n          instanceFactory: (payload: ChatMemberEvent) => {\n            const { member } = payload.params\n            return new ChatMember(toExternalJSON(member))\n          },\n          payloadTransform: (payload: ChatMemberEvent) => {\n            const { member } = payload.params\n            return toExternalJSON(member)\n          },\n        },\n      ],\n    ])\n  }\n}\n\nexport const BaseChatAPI = extendComponent<BaseChatConsumer, ChatMethods>(\n  BaseChatConsumer,\n  {\n    publish: chatMethods.publish,\n    getMembers: chatMethods.getMembers,\n    getMessages: chatMethods.getMessages,\n    setMemberState: chatMethods.setMemberState,\n    getMemberState: chatMethods.getMemberState,\n  }\n)\n\nexport const createBaseChatObject = <ChatType>(\n  params: BaseComponentOptions<ChatEventNames>\n) => {\n  const chat = connect<BaseChatApiEvents, BaseChatConsumer, ChatType>({\n    store: params.store,\n    Component: BaseChatAPI,\n    componentListeners: {\n      errors: 'onError',\n      responses: 'onSuccess',\n    },\n  })(params)\n\n  return chat\n}\n", "export * from './workers'\n", "import { fork, put } from '@redux-saga/core/effects'\nimport {\n  InternalMemberUpdatedEventNames,\n  sagaEffects,\n  SagaIterator,\n  SDKWorker,\n  SDKWorkerParams,\n  VideoMemberUpdatedEventParams,\n  VideoPosition,\n  VideoRoomSubscribedEventParams,\n} from '..'\nimport { findNamespaceInPayload } from '../redux/features/shared/namespace'\n\nfunction* memberPositionLayoutChangedWorker(options: any) {\n  const {\n    action,\n    memberList,\n    channels: { pubSubChannel },\n  } = options\n  const layers = action.payload.layout.layers\n  const processedMembers: Record<string, boolean> = {}\n\n  layers.forEach((layer: any) => {\n    const memberId = layer.member_id\n    if (!memberId) {\n      return\n    }\n\n    const memberEventParams = memberList.get(memberId)\n\n    if (\n      memberEventParams &&\n      layer.position !== memberEventParams.member?.current_position\n    ) {\n      mutateMemberCurrentPosition({\n        memberList,\n        memberId,\n        currentPosition: layer.position,\n      })\n      processedMembers[memberId] = true\n    } else {\n      // Values marked as false won't be put to `pubSubChannel`\n      processedMembers[memberId] = false\n    }\n  })\n\n  for (const [memberId, payload] of memberList) {\n    if (processedMembers[memberId]) {\n      yield put(pubSubChannel, {\n        type: 'video.member.updated',\n        payload,\n      })\n\n      /**\n       * `undefined` means that we couldn't find the\n       * `memberId` inside the `layout.layers` array, which\n       * implies that the user should now be off-canvas\n       */\n    } else if (processedMembers[memberId] === undefined) {\n      const updatedMemberEventParams = mutateMemberCurrentPosition({\n        memberList,\n        memberId,\n        currentPosition: 'off-canvas',\n      })\n\n      if (!updatedMemberEventParams) {\n        return\n      }\n\n      yield put(pubSubChannel, {\n        type: 'video.member.updated',\n        payload: updatedMemberEventParams,\n      })\n    }\n  }\n}\n\nexport function* memberUpdatedWorker({\n  action,\n  channels,\n  memberList,\n}: Omit<SDKWorkerParams<any>, 'runSaga'> & {\n  memberList: MemberEventParamsList\n  action: any\n}) {\n  const memberId = action.payload.member.id\n  const updatedMemberEventParams = mutateMemberCurrentPosition({\n    memberList,\n    memberId,\n    currentPosition: memberList.get(memberId)?.member?.current_position,\n  })\n\n  if (!updatedMemberEventParams) {\n    return\n  }\n\n  const {\n    member: { updated = [] },\n  } = action.payload\n\n  const memberUpdatedPayload = {\n    ...updatedMemberEventParams,\n    member: {\n      ...updatedMemberEventParams.member,\n      ...action.payload.member,\n    },\n  }\n  /** member.updated event is the only one updating the memberList payload */\n  memberList.set(memberId, memberUpdatedPayload)\n\n  for (const key of updated) {\n    const type = `${action.type}.${key}` as InternalMemberUpdatedEventNames\n    yield put(channels.pubSubChannel, {\n      type,\n      payload: memberUpdatedPayload,\n    })\n  }\n\n  yield put(channels.pubSubChannel, {\n    type: action.type,\n    payload: memberUpdatedPayload,\n  })\n}\n\nexport const MEMBER_POSITION_COMPOUND_EVENTS = new Map<any, any>([\n  [\n    'video.member.updated',\n    [\n      'video.layout.changed',\n      // `member.joined` and `member.left` are needed to\n      // keep the member list up to date\n      'video.member.joined',\n      'video.member.left',\n    ],\n  ],\n])\n\nexport const memberPositionWorker: SDKWorker<any> =\n  function* memberPositionWorker({\n    instance,\n    channels,\n    initialState,\n  }): SagaIterator {\n    if (!initialState) {\n      return\n    }\n\n    const { swEventChannel } = channels\n    let memberList = initializeMemberList(initialState)\n\n    const addToMemberList = (payload: VideoMemberUpdatedEventParams) => {\n      /**\n       * Add to memberList for both `member.joined` and `member.updated`\n       * note: changes made for audience users.\n       */\n      if (!memberList.has(payload.member.id)) {\n        memberList.set(payload.member.id, payload)\n      }\n    }\n\n    while (true) {\n      const action = yield sagaEffects.take(swEventChannel, (action: any) => {\n        const istargetEvent =\n          action.type === 'video.member.updated' ||\n          action.type === 'video.layout.changed' ||\n          action.type === 'video.member.joined' ||\n          action.type === 'video.member.left'\n\n        return (\n          istargetEvent &&\n          findNamespaceInPayload(action) === instance._eventsNamespace\n        )\n      })\n\n      switch (action.type) {\n        case 'video.member.updated': {\n          addToMemberList(action.payload)\n          yield fork(memberUpdatedWorker, {\n            action,\n            channels,\n            memberList,\n            instance,\n          })\n          break\n        }\n        case 'video.member.joined': {\n          addToMemberList(action.payload)\n          break\n        }\n        case 'video.member.left': {\n          const member = action.payload.member\n          memberList.delete(member.id)\n          break\n        }\n        case 'video.layout.changed': {\n          yield fork(memberPositionLayoutChangedWorker, {\n            action,\n            channels,\n            memberList,\n            instance,\n          })\n          break\n        }\n      }\n    }\n  }\n\ntype MemberEventParamsList = Map<string, VideoMemberUpdatedEventParams>\n\nconst mutateMemberCurrentPosition = ({\n  memberList,\n  memberId,\n  currentPosition,\n}: {\n  memberList: MemberEventParamsList\n  memberId: string\n  currentPosition?: VideoPosition\n}) => {\n  const memberEventParams = memberList.get(memberId)\n\n  if (!memberEventParams) {\n    return\n\n    // This is to avoid setting an undefined property\n  } else if (!currentPosition) {\n    return memberEventParams\n  }\n\n  const updatedMemberEventParams: VideoMemberUpdatedEventParams = {\n    ...memberEventParams,\n    member: {\n      ...memberEventParams?.member,\n      current_position: currentPosition,\n    },\n  }\n  memberList.set(memberId, updatedMemberEventParams)\n\n  return updatedMemberEventParams\n}\n\nconst initializeMemberList = (payload: VideoRoomSubscribedEventParams) => {\n  const members = payload.room_session.members\n  const memberList: MemberEventParamsList = new Map()\n\n  members.forEach((member) => {\n    memberList.set(member.id, {\n      room_id: payload.room_session.room_id,\n      room_session_id: payload.room_session.id,\n      // At this point we don't have `member.updated`\n      // @ts-expect-error\n      member,\n    })\n  })\n\n  return memberList\n}\n", "import { multicastChannel } from '@redux-saga/core'\nimport { configureStore, ConfigureStoreOptions, SDKStore } from './redux'\nimport { PubSubChannel, SwEventChannel } from './redux/interfaces'\nimport { BaseSession } from './BaseSession'\nimport { RPCConnectResult, InternalSDKLogger } from './utils/interfaces'\nimport { EventEmitter } from './utils/EventEmitter'\nimport { actions } from '.'\n\nconst PROJECT_ID = '8f0a119a-cda7-4497-a47d-c81493b824d4'\nconst TOKEN = '<VRT>'\n\nexport const createMockedLogger = (): InternalSDKLogger => ({\n  fatal: jest.fn(),\n  error: jest.fn(),\n  warn: jest.fn(),\n  info: jest.fn(),\n  debug: jest.fn(),\n  trace: jest.fn(),\n  wsTraffic: jest.fn(),\n})\n\n/**\n * Helper method to configure a Store w/o Saga middleware.\n * Useful to test slices and reducers logic.\n *\n * @returns Redux Store\n */\nexport const configureJestStore = (\n  options?: Partial<ConfigureStoreOptions>\n) => {\n  return configureStore({\n    userOptions: {\n      project: PROJECT_ID,\n      token: TOKEN,\n      devTools: false,\n      emitter: new EventEmitter(),\n    },\n    SessionConstructor: BaseSession,\n    runSagaMiddleware: false,\n    ...options,\n  }) as SDKStore\n}\n\n/**\n * Helper method to configure a Store with a rootSaga\n * and a mocked Session object.\n * This allow to write integration tests.\n *\n * @returns { store, session, emitter, destroy }\n */\nexport const configureFullStack = () => {\n  const session = {\n    dispatch: console.log,\n    connect: jest.fn(),\n    disconnect: jest.fn(),\n    execute: jest.fn(),\n  }\n  const emitter = new EventEmitter()\n  const store = configureStore({\n    userOptions: {\n      project: PROJECT_ID,\n      token: TOKEN,\n      devTools: false,\n      emitter,\n    },\n    SessionConstructor: jest.fn().mockImplementation(() => {\n      return session\n    }),\n  })\n\n  store.dispatch(actions.initAction())\n  store.dispatch(actions.authSuccessAction())\n\n  return {\n    store,\n    session,\n    emitter,\n    destroy: () => store.dispatch(actions.destroyAction()),\n  }\n}\n\nexport const wait = (ms: number) => {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms)\n  })\n}\n\nexport const rpcConnectResultVRT: RPCConnectResult = {\n  identity:\n    'f3bc99df-2c3d-4fa4-b1dc-e8a8ffc579e6@e3fefa44-1bad-4be9-ad9b-1cbb9abd60c7.west-us',\n  authorization: {\n    type: 'video',\n    project: '8f0a119a-cda7-4497-a47d-c81493b824d4',\n    scopes: ['video'],\n    scope_id: '26675883-8499-4ee9-85eb-691c4aa209f8',\n    resource: '9c80f1e8-9430-4070-a043-937eb3a96b38',\n    join_as: 'member',\n    user_name: 'Joe',\n    room: {\n      name: 'lobby',\n      display_name: 'Lobby',\n      scopes: ['room.self.audio_mute', 'room.self.audio_unmute'],\n      meta: {},\n    },\n    signature:\n      'SGZtkRD9fvuBAOUp1UF56zESxdEvGT6qSGZtkRD9fvuBAOUp1UF56zESxdEvGT6q',\n    media_allowed: 'all',\n    audio_allowed: 'both',\n    video_allowed: 'both',\n    meta: {},\n  },\n  protocol:\n    'signalwire_SGZtkRD9fvuBAOUp1UF56zESxdEvGT6qSGZtkRD9fvuBAOUp1UF56zESxdEvGT6q_03e8c927-8ea3-4661-86d5-778c3e03296a_8f0a119a-cda7-4497-a47d-c81493b824d4',\n  ice_servers: [\n    {\n      urls: 'turn.swire.io:443',\n      credential: 'sFTwvi8ShXcYNOcyYjFy3ATIUpQ=',\n      credentialType: 'password',\n      username: '1619521908:8f0a119a-cda7-4497-a47d-c81493b824d4',\n    },\n  ],\n}\n\nexport const createPubSubChannel = (): PubSubChannel => multicastChannel()\nexport const createSwEventChannel = (): SwEventChannel => multicastChannel()\n"],
  "mappings": "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",
  "names": []
}
