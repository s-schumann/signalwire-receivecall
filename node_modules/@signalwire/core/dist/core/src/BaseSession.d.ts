import { PayloadAction } from './redux';
import { SessionOptions, RPCConnectResult, JSONRPCRequest, JSONRPCResponse, WebSocketAdapter, NodeSocketAdapter, WebSocketClient, SessionStatus, SessionAuthError } from './utils/interfaces';
export declare const SW_SYMBOL: unique symbol;
export declare class BaseSession {
    options: SessionOptions;
    /** @internal */
    __sw_symbol: symbol;
    uuid: string;
    WebSocketConstructor: NodeSocketAdapter | WebSocketAdapter;
    agent: string;
    connectVersion: {
        major: number;
        minor: number;
        revision: number;
    };
    reauthenticate?(): Promise<void>;
    protected _rpcConnectResult: RPCConnectResult;
    private _requests;
    private _socket;
    private _host;
    private _executeTimeoutMs;
    private _executeTimeoutError;
    private _executeQueue;
    private _checkPingDelay;
    private _checkPingTimer;
    private _reconnectTimer;
    private _status;
    private wsOpenHandler;
    private wsCloseHandler;
    private wsErrorHandler;
    constructor(options: SessionOptions);
    get host(): string;
    get rpcConnectResult(): RPCConnectResult;
    get relayProtocol(): string;
    get signature(): string;
    protected get logger(): import("./utils/interfaces").InternalSDKLogger;
    get connecting(): boolean;
    get connected(): boolean;
    get closing(): boolean;
    get closed(): boolean;
    get status(): SessionStatus;
    get idle(): boolean;
    get ready(): boolean;
    set token(token: string);
    /**
     * Connect the websocket
     *
     * @return void
     */
    connect(): void;
    /**
     * Allow children classes to override it.
     * @return WebSocket instance
     */
    protected _createSocket(): WebSocketClient;
    /** Allow children classes to override it. */
    protected destroySocket(): void;
    protected _addSocketListeners(): void;
    protected _removeSocketListeners(): void;
    /**
     * Clear the Session and close the WS connection.
     * @return void
     */
    disconnect(): Promise<void>;
    /**
     * Send a JSON object to the server.
     * @return Promise that will resolve/reject depending on the server response
     */
    execute(msg: JSONRPCRequest | JSONRPCResponse): Promise<any>;
    /**
     * Authenticate with the SignalWire Network
     * @return Promise<void>
     */
    authenticate(): Promise<void>;
    authError(error: SessionAuthError): void;
    protected _onSocketOpen(event: Event): Promise<void>;
    protected _onSocketError(event: Event): void;
    protected _onSocketClose(event: CloseEvent): void;
    private _clearTimers;
    protected _onSocketMessage(event: MessageEvent): void | Promise<void>;
    protected _handleWebSocketMessage(_payload: JSONRPCRequest | JSONRPCResponse): void;
    dispatch(_payload: PayloadAction<any>): void;
    /**
     * Check the current relayProtocol against the signature
     * to make sure is still valid.
     * @return boolean
     */
    protected _relayProtocolIsValid(): boolean | "";
    protected encode<T>(input: T): Parameters<WebSocketClient['send']>[0];
    protected decode<T>(input: any): T;
    private _send;
    private _addToExecuteQueue;
    private _flushExecuteQueue;
    private _clearCheckPingTimer;
    private _pingHandler;
    private _closeConnection;
}
//# sourceMappingURL=BaseSession.d.ts.map