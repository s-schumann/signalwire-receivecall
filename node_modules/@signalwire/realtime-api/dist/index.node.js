var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __reflectGet = Reflect.get;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Chat: () => Chat_exports,
  Messaging: () => Messaging_exports,
  PubSub: () => PubSub_exports,
  Task: () => Task_exports,
  Video: () => Video_exports,
  Voice: () => Voice_exports,
  config: () => config,
  createClient: () => createClient2,
  getConfig: () => getConfig
});
module.exports = __toCommonJS(src_exports);

// src/video/Video.ts
var Video_exports = {};
__export(Video_exports, {
  Client: () => VideoClient,
  createVideoObject: () => createVideoObject
});
var import_core10 = require("@signalwire/core");

// src/AutoSubscribeConsumer.ts
var import_core = require("@signalwire/core");
var AutoSubscribeConsumer = class extends import_core.BaseConsumer {
  constructor(options) {
    super(options);
    __publicField(this, "debouncedSubscribe");
    this.debouncedSubscribe = (0, import_core.debounce)(this.subscribe, 100);
  }
  on(event, fn) {
    const instance = super.on(event, fn);
    this.debouncedSubscribe();
    return instance;
  }
  once(event, fn) {
    const instance = super.once(event, fn);
    this.debouncedSubscribe();
    return instance;
  }
};

// src/video/RoomSession.ts
var import_core4 = require("@signalwire/core");

// src/video/RoomSessionMember.ts
var import_core2 = require("@signalwire/core");
var RoomSessionMemberComponent = class extends import_core2.BaseComponent {
  remove() {
    return __async(this, null, function* () {
      yield this.execute({
        method: "video.member.remove",
        params: {
          room_session_id: this.getStateProperty("roomSessionId"),
          member_id: this.getStateProperty("memberId")
        }
      });
    });
  }
};
var RoomSessionMemberAPI = (0, import_core2.extendComponent)(RoomSessionMemberComponent, {
  audioMute: import_core2.Rooms.audioMuteMember,
  audioUnmute: import_core2.Rooms.audioUnmuteMember,
  videoMute: import_core2.Rooms.videoMuteMember,
  videoUnmute: import_core2.Rooms.videoUnmuteMember,
  setDeaf: import_core2.Rooms.setDeaf,
  setMicrophoneVolume: import_core2.Rooms.setInputVolumeMember,
  setInputVolume: import_core2.Rooms.setInputVolumeMember,
  setSpeakerVolume: import_core2.Rooms.setOutputVolumeMember,
  setOutputVolume: import_core2.Rooms.setOutputVolumeMember,
  setInputSensitivity: import_core2.Rooms.setInputSensitivityMember
});
var createRoomSessionMemberObject = (params) => {
  const member = (0, import_core2.connect)({
    store: params.store,
    Component: RoomSessionMemberAPI,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(params);
  return member;
};

// src/video/memberPosition/workers.ts
var import_core3 = require("@signalwire/core");
var memberPositionWorker = function* memberPositionWorker2(options) {
  const { instance, channels } = options;
  const { swEventChannel } = channels;
  const action = yield import_core3.sagaEffects.take(swEventChannel, (action2) => {
    const istargetEvent = action2.type === "video.room.subscribed";
    return istargetEvent && (0, import_core3.findNamespaceInPayload)(action2) === instance._eventsNamespace;
  });
  yield import_core3.sagaEffects.fork(import_core3.MemberPosition.memberPositionWorker, __spreadProps(__spreadValues({}, options), {
    initialState: action.payload
  }));
};

// src/video/RoomSession.ts
var RoomSessionConsumer = class extends import_core4.BaseConsumer {
  constructor(options) {
    super(options);
    __publicField(this, "_eventsPrefix", "video");
    __publicField(this, "subscribeParams", {
      get_initial_state: true
    });
    __publicField(this, "debouncedSubscribe");
    this.debouncedSubscribe = (0, import_core4.debounce)(this.subscribe, 100);
    this.runWorker("memberPositionWorker", {
      worker: memberPositionWorker
    });
  }
  _internal_on(event, fn) {
    return super.on(event, fn);
  }
  on(event, fn) {
    const instance = super.on(event, fn);
    this.debouncedSubscribe();
    return instance;
  }
  once(event, fn) {
    const instance = super.once(event, fn);
    this.debouncedSubscribe();
    return instance;
  }
  subscribe() {
    return new Promise((resolve, reject) => __async(this, null, function* () {
      const handler = (payload) => {
        resolve(payload);
      };
      const subscriptions = this.getSubscriptions();
      if (subscriptions.length === 0) {
        this.logger.debug("`subscribe()` was called without any listeners attached.");
        return;
      }
      try {
        __superGet(RoomSessionConsumer.prototype, this, "once").call(this, "room.subscribed", handler);
        yield __superGet(RoomSessionConsumer.prototype, this, "subscribe").call(this);
      } catch (error) {
        __superGet(RoomSessionConsumer.prototype, this, "off").call(this, "room.subscribed", handler);
        return reject(error);
      }
    }));
  }
  getCompoundEvents() {
    return new Map([
      ...import_core4.MemberPosition.MEMBER_POSITION_COMPOUND_EVENTS
    ]);
  }
  getEmitterTransforms() {
    return /* @__PURE__ */ new Map([
      [
        "video.room.subscribed",
        {
          type: "roomSessionSubscribed",
          instanceFactory: () => {
            return this;
          },
          payloadTransform: (payload) => {
            return (0, import_core4.toExternalJSON)(payload.room_session);
          },
          nestedFieldsToProcess: {
            members: {
              eventTransformType: "roomSessionMember",
              processInstancePayload: (payload) => {
                return {
                  room_session_id: this.getStateProperty("roomSessionId"),
                  member: payload
                };
              }
            },
            recordings: {
              eventTransformType: "roomSessionRecording",
              processInstancePayload: (payload) => {
                return {
                  room_session_id: this.getStateProperty("roomSessionId"),
                  recording: payload
                };
              }
            },
            streams: {
              eventTransformType: "roomSessionStream",
              processInstancePayload: (payload) => {
                return {
                  room_session_id: this.getStateProperty("roomSessionId"),
                  stream: payload
                };
              }
            }
          },
          getInstanceEventNamespace: (payload) => {
            return payload.room_session.id;
          },
          getInstanceEventChannel: (payload) => {
            return payload.room_session.event_channel;
          }
        }
      ],
      [
        [(0, import_core4.toLocalEvent)("video.recording.list")],
        {
          type: "roomSessionRecordingList",
          instanceFactory: (_payload) => {
            return {};
          },
          payloadTransform: (payload) => {
            return payload;
          },
          nestedFieldsToProcess: {
            recordings: {
              eventTransformType: "roomSessionRecording",
              processInstancePayload: (payload) => {
                return {
                  room_session_id: this.getStateProperty("roomSessionId"),
                  recording: payload
                };
              }
            }
          }
        }
      ],
      [
        [(0, import_core4.toLocalEvent)("video.playback.list")],
        {
          type: "roomSessionPlaybackList",
          instanceFactory: (_payload) => {
            return {};
          },
          payloadTransform: (payload) => {
            return payload;
          },
          nestedFieldsToProcess: {
            playbacks: {
              eventTransformType: "roomSessionPlayback",
              processInstancePayload: (payload) => {
                return {
                  room_session_id: this.getStateProperty("roomSessionId"),
                  playback: payload
                };
              }
            }
          }
        }
      ],
      [
        "video.room.updated",
        {
          type: "roomSession",
          instanceFactory: () => {
            return this;
          },
          payloadTransform: (payload) => {
            return (0, import_core4.toExternalJSON)(__spreadProps(__spreadValues({}, payload.room_session), {
              room_session_id: payload.room_session.id
            }));
          },
          getInstanceEventNamespace: (payload) => {
            return payload.room_session.id;
          },
          getInstanceEventChannel: (payload) => {
            return payload.room_session.event_channel;
          }
        }
      ],
      [
        "video.layout.changed",
        {
          type: "roomSessionLayout",
          instanceFactory: () => {
            return {};
          },
          payloadTransform: (payload) => {
            return (0, import_core4.toExternalJSON)(payload.layout);
          }
        }
      ],
      [
        [
          "video.member.joined",
          "video.member.left",
          "video.member.talking",
          "video.member.talking.start",
          "video.member.talking.started",
          "video.member.talking.stop",
          "video.member.talking.ended",
          "video.member.updated",
          ...import_core4.INTERNAL_MEMBER_UPDATED_EVENTS
        ],
        {
          type: "roomSessionMember",
          instanceFactory: (_payload) => {
            return createRoomSessionMemberObject({
              store: this.store,
              emitter: this.options.emitter
            });
          },
          payloadTransform: (payload) => {
            return (0, import_core4.toExternalJSON)(__spreadProps(__spreadValues({}, payload.member), {
              member_id: payload.member.id
            }));
          }
        }
      ],
      [
        [
          (0, import_core4.toLocalEvent)("video.recording.start"),
          "video.recording.started",
          "video.recording.updated",
          "video.recording.ended"
        ],
        {
          type: "roomSessionRecording",
          instanceFactory: (_payload) => {
            return import_core4.Rooms.createRoomSessionRecordingObject({
              store: this.store,
              emitter: this.emitter
            });
          },
          payloadTransform: (payload) => {
            return (0, import_core4.toExternalJSON)(__spreadProps(__spreadValues({}, payload.recording), {
              room_session_id: payload.room_session_id
            }));
          }
        }
      ],
      [
        [
          (0, import_core4.toLocalEvent)("video.playback.start"),
          "video.playback.started",
          "video.playback.updated",
          "video.playback.ended"
        ],
        {
          type: "roomSessionPlayback",
          instanceFactory: (_payload) => {
            return import_core4.Rooms.createRoomSessionPlaybackObject({
              store: this.store,
              emitter: this.emitter
            });
          },
          payloadTransform: (payload) => {
            return (0, import_core4.toExternalJSON)(__spreadProps(__spreadValues({}, payload.playback), {
              room_session_id: payload.room_session_id
            }));
          }
        }
      ],
      [
        ["video.room.audience_count", "video.room.audienceCount"],
        {
          type: "roomSessionAudienceCount",
          instanceFactory: (_payload) => {
            return {};
          },
          payloadTransform: (payload) => {
            return (0, import_core4.toExternalJSON)(payload);
          }
        }
      ],
      [
        [(0, import_core4.toLocalEvent)("video.stream.list")],
        {
          type: "roomSessionStreamList",
          instanceFactory: (_payload) => {
            return {};
          },
          payloadTransform: (payload) => {
            return payload;
          },
          nestedFieldsToProcess: {
            streams: {
              eventTransformType: "roomSessionStream",
              processInstancePayload: (payload) => {
                return {
                  room_session_id: this.getStateProperty("roomSessionId"),
                  stream: payload
                };
              }
            }
          }
        }
      ],
      [
        [
          (0, import_core4.toLocalEvent)("video.stream.start"),
          "video.stream.started",
          "video.stream.ended"
        ],
        {
          type: "roomSessionStream",
          instanceFactory: (_payload) => {
            return import_core4.Rooms.createRoomSessionStreamObject({
              store: this.store,
              emitter: this.emitter
            });
          },
          payloadTransform: (payload) => {
            return (0, import_core4.toExternalJSON)(__spreadProps(__spreadValues({}, payload.stream), {
              room_session_id: payload.room_session_id
            }));
          }
        }
      ]
    ]);
  }
};
var RoomSessionAPI = (0, import_core4.extendComponent)(RoomSessionConsumer, {
  videoMute: import_core4.Rooms.videoMuteMember,
  videoUnmute: import_core4.Rooms.videoUnmuteMember,
  getMembers: import_core4.Rooms.getMembers,
  audioMute: import_core4.Rooms.audioMuteMember,
  audioUnmute: import_core4.Rooms.audioUnmuteMember,
  deaf: import_core4.Rooms.deafMember,
  undeaf: import_core4.Rooms.undeafMember,
  setInputVolume: import_core4.Rooms.setInputVolumeMember,
  setOutputVolume: import_core4.Rooms.setOutputVolumeMember,
  setMicrophoneVolume: import_core4.Rooms.setInputVolumeMember,
  setSpeakerVolume: import_core4.Rooms.setOutputVolumeMember,
  setInputSensitivity: import_core4.Rooms.setInputSensitivityMember,
  removeMember: import_core4.Rooms.removeMember,
  removeAllMembers: import_core4.Rooms.removeAllMembers,
  setHideVideoMuted: import_core4.Rooms.setHideVideoMuted,
  getLayouts: import_core4.Rooms.getLayouts,
  setLayout: import_core4.Rooms.setLayout,
  setPositions: import_core4.Rooms.setPositions,
  setMemberPosition: import_core4.Rooms.setMemberPosition,
  getRecordings: import_core4.Rooms.getRecordings,
  startRecording: import_core4.Rooms.startRecording,
  getPlaybacks: import_core4.Rooms.getPlaybacks,
  play: import_core4.Rooms.play,
  getMeta: import_core4.Rooms.getMeta,
  setMeta: import_core4.Rooms.setMeta,
  updateMeta: import_core4.Rooms.updateMeta,
  deleteMeta: import_core4.Rooms.deleteMeta,
  getMemberMeta: import_core4.Rooms.getMemberMeta,
  setMemberMeta: import_core4.Rooms.setMemberMeta,
  updateMemberMeta: import_core4.Rooms.updateMemberMeta,
  deleteMemberMeta: import_core4.Rooms.deleteMemberMeta,
  promote: import_core4.Rooms.promote,
  demote: import_core4.Rooms.demote,
  getStreams: import_core4.Rooms.getStreams,
  startStream: import_core4.Rooms.startStream
});
var createRoomSessionObject = (params) => {
  const roomSession = (0, import_core4.connect)({
    store: params.store,
    Component: RoomSessionAPI,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(params);
  return roomSession;
};

// src/client/Client.ts
var import_core5 = require("@signalwire/core");
var Client = class extends import_core5.BaseClient {
};

// src/client/clientConnect.ts
var clientConnect = (client) => {
  return client.connect().catch(() => {
  });
};

// src/client/setupClient.ts
var import_core9 = require("@signalwire/core");

// src/utils/internals.ts
var import_core7 = require("@signalwire/core");

// src/configure/index.ts
var GLOBAL_CONFIG = {};
var getConfig = () => {
  return GLOBAL_CONFIG;
};
var config = (_a) => {
  var _b = _a, {
    cache = GLOBAL_CONFIG
  } = _b, options = __objRest(_b, [
    "cache"
  ]);
  if (cache) {
    GLOBAL_CONFIG = cache;
  }
  Object.entries(options).forEach(([key, value]) => {
    GLOBAL_CONFIG[key] = value;
  });
};

// src/Session.ts
var import_core6 = require("@signalwire/core");
var import_ws = __toESM(require("ws"));
var Session = class extends import_core6.BaseSession {
  constructor() {
    super(...arguments);
    __publicField(this, "WebSocketConstructor", import_ws.default);
    __publicField(this, "agent", "@signalwire/nodejs/realtime-api/3.6.0");
  }
};

// src/utils/internals.ts
var setupInternals = (userOptions) => {
  const emitter = (0, import_core7.getEventEmitter)();
  const baseOptions = __spreadProps(__spreadValues({}, userOptions), {
    emitter
  });
  const store = (0, import_core7.configureStore)({
    userOptions: baseOptions,
    SessionConstructor: Session
  });
  return { store, emitter };
};
var getToken = (userToken) => {
  const globalConfig = getConfig();
  const token = userToken || globalConfig.token || process.env.SW_TOKEN;
  if (!token) {
    throw new Error("Missing `token`");
  }
  return token;
};
var getProject = (userProject) => {
  const globalConfig = getConfig();
  const project = userProject || globalConfig.project || process.env.SW_PROJECT;
  if (!project) {
    throw new Error("Missing `project`");
  }
  return project;
};
var getCredentials = (options) => {
  const project = getProject(options == null ? void 0 : options.project);
  const token = getToken(options == null ? void 0 : options.token);
  return { project, token };
};

// src/client/clientProxyFactory.ts
var defaultInterceptors = {
  connect: clientConnect
};
var clientProxyFactory = (client, interceptors = defaultInterceptors) => {
  const clientConnect2 = interceptors.connect || clientConnect;
  const clientOn = (...args) => {
    clientConnect2(client);
    return client.on(...args);
  };
  const clientOnce = (...args) => {
    clientConnect2(client);
    return client.once(...args);
  };
  return new Proxy(client, {
    get(target, prop, receiver) {
      if (prop === "on") {
        return clientOn;
      } else if (prop === "once") {
        return clientOnce;
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/client/getClient.ts
var import_core8 = require("@signalwire/core");
var CLIENTS_MAP = /* @__PURE__ */ new Map();
var createClient = (userOptions) => {
  const client = (0, import_core8.connect)({
    store: userOptions.store,
    Component: Client,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(userOptions);
  return client;
};
var getClient = (_a) => {
  var _b = _a, {
    cache = CLIENTS_MAP
  } = _b, userOptions = __objRest(_b, [
    "cache"
  ]);
  const { emitter, store } = setupInternals(userOptions);
  const client = createClient(__spreadProps(__spreadValues({}, userOptions), {
    store,
    emitter
  }));
  const config2 = {
    client,
    store,
    emitter
  };
  return config2;
};

// src/client/setupClient.ts
var setupClient = (userOptions) => {
  const credentials = getCredentials({
    token: userOptions == null ? void 0 : userOptions.token,
    project: userOptions == null ? void 0 : userOptions.project
  });
  const { client, store, emitter } = getClient(__spreadValues(__spreadValues({}, userOptions), credentials));
  client.on("session.auth_error", () => {
    (0, import_core9.getLogger)().error("Wrong credentials: couldn't connect the client.");
  });
  const proxiedClient = clientProxyFactory(client);
  return {
    client: proxiedClient,
    store,
    emitter
  };
};

// src/video/VideoClient.ts
var VideoClient = function(options) {
  const { client, store, emitter } = setupClient(options);
  const video = createVideoObject({
    store,
    emitter
  });
  const videoSubscribe = () => __async(this, null, function* () {
    yield clientConnect(client);
    return video.subscribe();
  });
  const interceptors = {
    subscribe: videoSubscribe,
    _session: client,
    disconnect: () => client.disconnect()
  };
  return new Proxy(video, {
    get(target, prop, receiver) {
      if (prop in interceptors) {
        return interceptors[prop];
      }
      if (typeof target[prop] === "function") {
        clientConnect(client);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/video/Video.ts
var videoRoomGetTriggerEvent = (0, import_core10.toLocalEvent)("video.room.get");
var VideoAPI = class extends AutoSubscribeConsumer {
  constructor() {
    super(...arguments);
    __publicField(this, "_eventsPrefix", "video");
    __publicField(this, "subscribeParams", {
      get_initial_state: true
    });
  }
  getEmitterTransforms() {
    return /* @__PURE__ */ new Map([
      [
        [videoRoomGetTriggerEvent, "video.room.started", "video.room.ended"],
        {
          type: "roomSession",
          instanceFactory: () => {
            return createRoomSessionObject({
              store: this.store,
              emitter: this.options.emitter
            });
          },
          payloadTransform: (payload) => {
            return (0, import_core10.toExternalJSON)(__spreadProps(__spreadValues({}, payload.room_session), {
              room_session_id: payload.room_session.id
            }));
          },
          getInstanceEventNamespace: (payload) => {
            return payload.room_session.id;
          },
          getInstanceEventChannel: (payload) => {
            return payload.room_session.event_channel;
          }
        }
      ]
    ]);
  }
  getRoomSessions() {
    return __async(this, null, function* () {
      return new Promise((resolve, reject) => __async(this, null, function* () {
        try {
          const { rooms = [] } = yield this.execute({
            method: "video.rooms.get",
            params: {}
          });
          const roomSessions = [];
          const handler = (instance) => roomSessions.push(instance);
          this.on(videoRoomGetTriggerEvent, handler);
          rooms.forEach((room_session) => {
            this.emit(videoRoomGetTriggerEvent, { room_session });
          });
          resolve({ roomSessions });
        } catch (error) {
          console.error("Error listing room sessions", error);
          reject(error);
        }
      }));
    });
  }
  getRoomSessionById(id) {
    return __async(this, null, function* () {
      return new Promise((resolve, reject) => __async(this, null, function* () {
        try {
          const { room } = yield this.execute({
            method: "video.room.get",
            params: {
              room_session_id: id
            }
          });
          this.once(videoRoomGetTriggerEvent, (instance) => {
            resolve({ roomSession: instance });
          });
          this.emit(videoRoomGetTriggerEvent, { room_session: room });
        } catch (error) {
          console.error("Error retrieving the room session", error);
          reject(error);
        }
      }));
    });
  }
};
var createVideoObject = (params) => {
  const video = (0, import_core10.connect)({
    store: params.store,
    Component: VideoAPI,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(params);
  const proxy = new Proxy(video, {
    get(target, prop, receiver) {
      if (prop === "_eventsNamespace") {
        return "";
      } else if (prop === "eventChannel") {
        return "video.rooms";
      }
      return Reflect.get(target, prop, receiver);
    }
  });
  return proxy;
};

// src/createClient.ts
var import_core12 = require("@signalwire/core");

// src/Client.ts
var import_core11 = require("@signalwire/core");
var Client2 = class extends import_core11.BaseClient {
  constructor() {
    super(...arguments);
    __publicField(this, "_consumers", /* @__PURE__ */ new Map());
  }
  onAuth(session) {
    return __async(this, null, function* () {
      try {
        if (session.authStatus === "authorized") {
          this._consumers.forEach((consumer) => {
            consumer.subscribe();
          });
        }
      } catch (error) {
        this.logger.error("Client subscription failed.");
        this.disconnect();
        throw error;
      }
    });
  }
  get video() {
    if (this._consumers.has("video")) {
      return this._consumers.get("video");
    }
    const video = createVideoObject({
      store: this.store,
      emitter: this.options.emitter
    });
    this._consumers.set("video", video);
    return video;
  }
};

// src/createClient.ts
var createClient2 = (userOptions) => __async(void 0, null, function* () {
  const baseUserOptions = __spreadProps(__spreadValues({}, userOptions), {
    emitter: (0, import_core12.getEventEmitter)()
  });
  const store = (0, import_core12.configureStore)({
    userOptions: baseUserOptions,
    SessionConstructor: Session
  });
  const client = (0, import_core12.connect)({
    store,
    Component: Client2,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    },
    sessionListeners: {
      authStatus: "onAuth"
    }
  })(baseUserOptions);
  return client;
});

// src/chat/Chat.ts
var Chat_exports = {};
__export(Chat_exports, {
  ChatMember: () => import_core14.ChatMember,
  ChatMessage: () => import_core14.ChatMessage,
  Client: () => ChatClient
});
var import_core14 = require("@signalwire/core");

// src/chat/ChatClient.ts
var import_core13 = require("@signalwire/core");
var INTERCEPTED_METHODS = [
  "subscribe",
  "publish",
  "getMessages",
  "getMembers",
  "getMemberState",
  "setMemberState"
];
var UNSUPPORTED_METHODS = ["getAllowedChannels", "updateToken"];
var ChatClient = function(options) {
  const { client, store, emitter } = setupClient(options);
  const chat = import_core13.Chat.createBaseChatObject({
    store,
    emitter
  });
  const createInterceptor = (prop) => {
    return (...params) => __async(this, null, function* () {
      yield clientConnect(client);
      return chat[prop](...params);
    });
  };
  const interceptors = {
    _session: client,
    disconnect: () => client.disconnect()
  };
  return new Proxy(chat, {
    get(target, prop, receiver) {
      if (prop in interceptors) {
        return interceptors[prop];
      }
      if (prop !== "_session" && INTERCEPTED_METHODS.includes(prop)) {
        return createInterceptor(prop);
      } else if (UNSUPPORTED_METHODS.includes(prop)) {
        return void 0;
      }
      if (typeof target[prop] === "function") {
        clientConnect(client);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/pubSub/PubSub.ts
var PubSub_exports = {};
__export(PubSub_exports, {
  Client: () => PubSubClient,
  PubSubMessage: () => import_core16.PubSubMessage
});
var import_core16 = require("@signalwire/core");

// src/pubSub/PubSubClient.ts
var import_core15 = require("@signalwire/core");
var INTERCEPTED_METHODS2 = ["subscribe", "publish"];
var UNSUPPORTED_METHODS2 = ["getAllowedChannels", "updateToken"];
var PubSubClient = function(options) {
  const { client, store, emitter } = setupClient(options);
  const pubSub = import_core15.PubSub.createBasePubSubObject({
    store,
    emitter
  });
  const createInterceptor = (prop) => {
    return (...params) => __async(this, null, function* () {
      yield clientConnect(client);
      return pubSub[prop](...params);
    });
  };
  const interceptors = {
    _session: client,
    disconnect: () => client.disconnect()
  };
  return new Proxy(pubSub, {
    get(target, prop, receiver) {
      if (prop in interceptors) {
        return interceptors[prop];
      }
      if (prop !== "_session" && INTERCEPTED_METHODS2.includes(prop)) {
        return createInterceptor(prop);
      } else if (UNSUPPORTED_METHODS2.includes(prop)) {
        return void 0;
      }
      if (typeof target[prop] === "function") {
        clientConnect(client);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/task/Task.ts
var Task_exports = {};
__export(Task_exports, {
  Client: () => TaskClient,
  createTaskObject: () => createTaskObject,
  send: () => send
});
var import_core18 = require("@signalwire/core");
var import_core19 = require("@signalwire/core");

// src/task/workers.ts
var import_core17 = require("@signalwire/core");
var taskWorker = function* (options) {
  (0, import_core17.getLogger)().trace("taskWorker started");
  const { channels } = options;
  const { swEventChannel, pubSubChannel } = channels;
  while (true) {
    const action = yield import_core17.sagaEffects.take(swEventChannel, (action2) => {
      return action2.type === "queuing.relay.tasks";
    });
    yield import_core17.sagaEffects.put(pubSubChannel, {
      type: "task.received",
      payload: action.payload.message
    });
  }
  (0, import_core17.getLogger)().trace("taskWorker ended");
};

// src/common/clientContext.ts
var clientContextInterceptorsFactory = (client) => {
  return {
    addContexts(contexts) {
      return __async(this, null, function* () {
        yield clientConnect(client);
        const executeParams = {
          method: "signalwire.receive",
          params: {
            contexts
          }
        };
        return client.execute(executeParams);
      });
    },
    removeContexts(contexts) {
      return __async(this, null, function* () {
        yield clientConnect(client);
        const executeParams = {
          method: "signalwire.unreceive",
          params: {
            contexts
          }
        };
        return client.execute(executeParams);
      });
    }
  };
};

// src/task/TaskClient.ts
var TaskClient = function(options) {
  const { client, store, emitter } = setupClient(options);
  const task = createTaskObject({
    store,
    emitter
  });
  const disconnect = () => client.disconnect();
  const interceptors = __spreadProps(__spreadValues({}, clientContextInterceptorsFactory(client)), {
    _session: client,
    disconnect
  });
  return new Proxy(task, {
    get(target, prop, receiver) {
      if (prop in interceptors) {
        return interceptors[prop];
      }
      if (typeof target[prop] === "function") {
        clientConnect(client);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/task/send.ts
var import_node_https = require("https");
var PATH = "/api/relay/rest/tasks";
var HOST = "relay.signalwire.com";
var send = ({
  host = HOST,
  project,
  token,
  context,
  message
}) => {
  if (!project || !token) {
    throw new Error("Invalid options: project and token are required!");
  }
  return new Promise((resolve, reject) => {
    try {
      const Authorization = `Basic ${Buffer.from(`${project}:${token}`).toString("base64")}`;
      const data = JSON.stringify({ context, message });
      const options = {
        host,
        port: 443,
        method: "POST",
        path: PATH,
        headers: {
          Authorization,
          "Content-Type": "application/json",
          "Content-Length": data.length
        }
      };
      const req = (0, import_node_https.request)(options, ({ statusCode }) => {
        statusCode === 204 ? resolve() : reject();
      });
      req.on("error", reject);
      req.write(data);
      req.end();
    } catch (error) {
      reject(error);
    }
  });
};

// src/task/Task.ts
var TaskAPI = class extends import_core18.BaseComponent {
  constructor(options) {
    super(options);
    this.runWorker("taskWorker", {
      worker: taskWorker
    });
    this._attachListeners("");
  }
};
var createTaskObject = (params) => {
  const task = (0, import_core19.connect)({
    store: params.store,
    Component: TaskAPI,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(params);
  return task;
};

// src/messaging/Messaging.ts
var Messaging_exports = {};
__export(Messaging_exports, {
  Client: () => MessagingClient,
  Message: () => Message,
  createMessagingObject: () => createMessagingObject
});
var import_core21 = require("@signalwire/core");
var import_core22 = require("@signalwire/core");

// src/messaging/workers.ts
var import_core20 = require("@signalwire/core");
var messagingWorker = function* (options) {
  const { channels } = options;
  const { swEventChannel, pubSubChannel } = channels;
  while (true) {
    const action = yield import_core20.sagaEffects.take(swEventChannel, (action2) => {
      return action2.type.startsWith("messaging.");
    });
    (0, import_core20.getLogger)().debug("messagingWorker:", action);
    switch (action.type) {
      case "messaging.receive": {
        yield import_core20.sagaEffects.put(pubSubChannel, {
          type: "message.received",
          payload: action.payload
        });
        break;
      }
      case "messaging.state": {
        yield import_core20.sagaEffects.put(pubSubChannel, {
          type: "message.updated",
          payload: action.payload
        });
        break;
      }
      default: {
        (0, import_core20.getLogger)().warn("[messagingWorker] Unrecognized Action", action);
        break;
      }
    }
  }
};

// src/messaging/Message.ts
var Message = class {
  constructor(options) {
    __publicField(this, "id");
    __publicField(this, "state");
    __publicField(this, "context");
    __publicField(this, "from");
    __publicField(this, "to");
    __publicField(this, "body");
    __publicField(this, "direction");
    __publicField(this, "media");
    __publicField(this, "segments");
    __publicField(this, "tags");
    __publicField(this, "reason");
    this.id = options.message_id;
    this.state = options.message_state;
    this.context = options.context;
    this.from = options.from_number;
    this.to = options.to_number;
    this.body = options.body;
    this.direction = options.direction;
    this.media = options.media || [];
    this.segments = options.segments;
    this.tags = options.tags || [];
    this.reason = options.reason;
  }
};

// src/messaging/MessagingClient.ts
var MessagingClient = function(options) {
  const { client, store, emitter } = setupClient(options);
  const messaging = createMessagingObject({
    store,
    emitter
  });
  client.once("session.connected", () => {
    messaging.applyEmitterTransforms();
  });
  const send2 = (...args) => __async(this, null, function* () {
    yield clientConnect(client);
    return messaging.send(...args);
  });
  const disconnect = () => client.disconnect();
  const interceptors = __spreadProps(__spreadValues({}, clientContextInterceptorsFactory(client)), {
    send: send2,
    _session: client,
    disconnect
  });
  return new Proxy(messaging, {
    get(target, prop, receiver) {
      if (prop in interceptors) {
        return interceptors[prop];
      }
      if (typeof target[prop] === "function") {
        clientConnect(client);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/messaging/Messaging.ts
var MessagingAPI = class extends import_core22.BaseComponent {
  constructor(options) {
    super(options);
    this.runWorker("messagingWorker", {
      worker: messagingWorker
    });
    this._attachListeners("");
  }
  getEmitterTransforms() {
    return /* @__PURE__ */ new Map([
      [
        [
          "messaging.state",
          "messaging.receive",
          "message.updated",
          "message.received"
        ],
        {
          type: "messagingMessage",
          instanceFactory: (payload) => {
            return new Message(payload);
          },
          payloadTransform: (payload) => {
            const _a = payload, {
              message_id,
              message_state,
              from_number,
              to_number,
              tag
            } = _a, rest = __objRest(_a, [
              "message_id",
              "message_state",
              "from_number",
              "to_number",
              "tag"
            ]);
            return (0, import_core21.toExternalJSON)(__spreadProps(__spreadValues({}, rest), {
              id: message_id,
              state: message_state,
              from: from_number,
              to: to_number
            }));
          }
        }
      ]
    ]);
  }
  send(params) {
    return __async(this, null, function* () {
      const _a = params, { from = "", to = "" } = _a, rest = __objRest(_a, ["from", "to"]);
      const sendParams = __spreadProps(__spreadValues({}, rest), {
        from_number: from,
        to_number: to
      });
      try {
        const response = yield this.execute({
          method: "messaging.send",
          params: sendParams
        });
        return (0, import_core21.toExternalJSON)(response);
      } catch (error) {
        this.logger.error("Error sending message", error.jsonrpc);
        throw error.jsonrpc;
      }
    });
  }
};
var createMessagingObject = (params) => {
  const messaging = (0, import_core22.connect)({
    store: params.store,
    Component: MessagingAPI,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(params);
  return messaging;
};

// src/voice/Voice.ts
var Voice_exports = {};
__export(Voice_exports, {
  Client: () => VoiceClient,
  DeviceBuilder: () => DeviceBuilder,
  Playlist: () => Playlist,
  createVoiceObject: () => createVoiceObject
});
var import_core41 = require("@signalwire/core");

// src/voice/Call.ts
var import_core40 = require("@signalwire/core");

// src/AutoApplyTransformsConsumer.ts
var import_core23 = require("@signalwire/core");
var AutoApplyTransformsConsumer = class extends import_core23.BaseConsumer {
  on(event, fn) {
    const instance = super.on(event, fn);
    this.applyEmitterTransforms();
    return instance;
  }
  once(event, fn) {
    const instance = super.once(event, fn);
    this.applyEmitterTransforms();
    return instance;
  }
};

// src/voice/utils.ts
var import_core24 = require("@signalwire/core");
var toInternalDevice = (device) => {
  switch (device.type) {
    case "sip": {
      const _a = device, { type } = _a, params = __objRest(_a, ["type"]);
      return {
        type,
        params: (0, import_core24.toSnakeCaseKeys)(params)
      };
    }
    case "phone": {
      const _b = device, { to, from, type } = _b, rest = __objRest(_b, ["to", "from", "type"]);
      return {
        type,
        params: (0, import_core24.toSnakeCaseKeys)(__spreadProps(__spreadValues({}, rest), {
          to_number: to,
          from_number: from
        }))
      };
    }
  }
  return device;
};
var toInternalDevices = (params, internalDevices = []) => {
  params.forEach((dev, index) => {
    if (Array.isArray(dev)) {
      internalDevices[index] = toInternalDevices(dev);
    } else {
      internalDevices[index] = toInternalDevice(dev);
    }
  });
  return internalDevices;
};
var toInternalPlay = (media) => {
  const _a = media, { type } = _a, params = __objRest(_a, ["type"]);
  return { type, params };
};
var toInternalPlayParams = (params, result = []) => {
  params.forEach((media, index) => {
    if (Array.isArray(media)) {
      result[index] = toInternalPlayParams(media);
    } else {
      result[index] = toInternalPlay(media);
    }
  });
  return result;
};

// src/voice/Playlist.ts
var Playlist = class {
  constructor(params = {}) {
    this.params = params;
    __publicField(this, "_media", []);
  }
  get volume() {
    var _a;
    return (_a = this.params) == null ? void 0 : _a.volume;
  }
  get media() {
    return this._media;
  }
  add(params) {
    this._media.push(params);
    return this;
  }
  static Audio(params) {
    return __spreadValues({ type: "audio" }, params);
  }
  static TTS(params) {
    return __spreadValues({ type: "tts" }, params);
  }
  static Silence(params) {
    return __spreadValues({ type: "silence" }, params);
  }
  static Ringtone(params) {
    return __spreadValues({ type: "ringtone" }, params);
  }
};

// src/voice/workers/voiceCallStateWorker.ts
var import_core25 = require("@signalwire/core");
var voiceCallStateWorker = function* (options) {
  const { channels, instance } = options;
  const { swEventChannel, pubSubChannel } = channels;
  (0, import_core25.getLogger)().trace("voiceCallStateWorker started", instance.id, instance.tag);
  let run = true;
  const done = () => run = false;
  while (run) {
    const action = yield import_core25.sagaEffects.take(swEventChannel, (action2) => {
      if (action2.type === "calling.call.state") {
        if (instance.id) {
          return instance.id === action2.payload.call_id;
        }
        return instance.tag === action2.payload.tag;
      }
      return false;
    });
    const newPayload = __spreadProps(__spreadValues({}, action.payload), {
      tag: instance.tag
    });
    yield import_core25.sagaEffects.put(pubSubChannel, {
      type: "calling.call.state",
      payload: newPayload
    });
    if (newPayload.call_state === "ended") {
      done();
    }
  }
  (0, import_core25.getLogger)().trace("voiceCallStateWorker ended", instance.id, instance.tag);
};

// src/voice/workers/voiceCallReceiveWorker.ts
var import_core26 = require("@signalwire/core");
var voiceCallReceiveWorker = function* (options) {
  var _a;
  (0, import_core26.getLogger)().trace("voiceCallReceiveWorker started");
  const { channels, instance } = options;
  const { swEventChannel, pubSubChannel } = channels;
  const { contexts = [] } = (_a = instance == null ? void 0 : instance.options) != null ? _a : {};
  if (!contexts.length) {
    throw new Error("Invalid contexts to receive inbound calls");
  }
  while (true) {
    const action = yield import_core26.sagaEffects.take(swEventChannel, (action2) => {
      return action2.type === "calling.call.receive" && contexts.includes(action2.payload.context);
    });
    yield import_core26.sagaEffects.put(pubSubChannel, {
      type: "calling.call.received",
      payload: action.payload
    });
  }
  (0, import_core26.getLogger)().trace("voiceCallReceiveWorker ended");
};

// src/voice/workers/voiceCallPlayWorker.ts
var import_core27 = require("@signalwire/core");
var voiceCallPlayWorker = function* (options) {
  (0, import_core27.getLogger)().trace("voiceCallPlayWorker started");
  const { channels, instance, initialState } = options;
  const { swEventChannel, pubSubChannel } = channels;
  const { controlId } = initialState;
  if (!controlId) {
    throw new Error("Missing controlId for playback");
  }
  let paused = false;
  let run = true;
  const done = () => run = false;
  while (run) {
    const action = yield import_core27.sagaEffects.take(swEventChannel, (action2) => {
      return action2.type === "calling.call.play" && action2.payload.control_id === controlId;
    });
    const payloadWithTag = __spreadValues({
      tag: instance.tag
    }, action.payload);
    yield import_core27.sagaEffects.put(pubSubChannel, {
      type: callingPlaybackTriggerEvent,
      payload: payloadWithTag
    });
    switch (action.payload.state) {
      case "playing": {
        const type = paused ? "calling.playback.updated" : "calling.playback.started";
        paused = false;
        yield import_core27.sagaEffects.put(pubSubChannel, {
          type,
          payload: payloadWithTag
        });
        break;
      }
      case "paused": {
        paused = true;
        yield import_core27.sagaEffects.put(pubSubChannel, {
          type: "calling.playback.updated",
          payload: payloadWithTag
        });
        break;
      }
      case "error":
        break;
      case "finished": {
        yield import_core27.sagaEffects.put(pubSubChannel, {
          type: "calling.playback.ended",
          payload: payloadWithTag
        });
        yield import_core27.sagaEffects.put(pubSubChannel, {
          type: "calling.playback.ended",
          payload: __spreadValues({
            tag: controlId
          }, action.payload)
        });
        done();
        break;
      }
    }
  }
  (0, import_core27.getLogger)().trace("voiceCallPlayWorker ended");
};

// src/voice/workers/voiceCallRecordWorker.ts
var import_core28 = require("@signalwire/core");
var voiceCallRecordWorker = function* (options) {
  (0, import_core28.getLogger)().trace("voiceCallRecordWorker started");
  const { channels, instance, initialState } = options;
  const { swEventChannel, pubSubChannel } = channels;
  const { controlId } = initialState;
  if (!controlId) {
    throw new Error("Missing controlId for recording");
  }
  let run = true;
  const done = () => run = false;
  while (run) {
    const action = yield import_core28.sagaEffects.take(swEventChannel, (action2) => {
      return action2.type === "calling.call.record" && action2.payload.control_id === controlId;
    });
    const payloadWithTag = __spreadValues({
      tag: instance.tag
    }, action.payload);
    yield import_core28.sagaEffects.put(pubSubChannel, {
      type: callingRecordTriggerEvent,
      payload: payloadWithTag
    });
    switch (action.payload.state) {
      case "recording": {
        yield import_core28.sagaEffects.put(pubSubChannel, {
          type: "calling.recording.started",
          payload: payloadWithTag
        });
        break;
      }
      case "no_input":
      case "finished": {
        const typeToEmit = action.payload.state === "finished" ? "calling.recording.ended" : "calling.recording.failed";
        yield import_core28.sagaEffects.put(pubSubChannel, {
          type: typeToEmit,
          payload: payloadWithTag
        });
        yield import_core28.sagaEffects.put(pubSubChannel, {
          type: typeToEmit,
          payload: __spreadValues({
            tag: controlId
          }, action.payload)
        });
        done();
        break;
      }
    }
  }
  (0, import_core28.getLogger)().trace("voiceCallRecordWorker ended");
};

// src/voice/workers/voiceCallPromptWorker.ts
var import_core29 = require("@signalwire/core");
var voiceCallPromptWorker = function* (options) {
  (0, import_core29.getLogger)().trace("voiceCallPromptWorker started");
  const { channels, instance, initialState } = options;
  const { swEventChannel, pubSubChannel } = channels;
  const { controlId } = initialState;
  if (!controlId) {
    throw new Error("Missing controlId for prompt");
  }
  let run = true;
  const done = () => run = false;
  while (run) {
    const action = yield import_core29.sagaEffects.take(swEventChannel, (action2) => {
      return action2.type === "calling.call.collect" && action2.payload.control_id === controlId;
    });
    const payloadWithTag = __spreadValues({
      tag: instance.tag
    }, action.payload);
    yield import_core29.sagaEffects.put(pubSubChannel, {
      type: callingPromptTriggerEvent,
      payload: payloadWithTag
    });
    if (action.payload.result) {
      let typeToEmit;
      switch (action.payload.result.type) {
        case "no_match":
        case "no_input":
        case "error": {
          typeToEmit = "calling.prompt.failed";
          break;
        }
        case "speech":
        case "digit": {
          typeToEmit = "calling.prompt.ended";
          break;
        }
      }
      yield import_core29.sagaEffects.put(pubSubChannel, {
        type: typeToEmit,
        payload: payloadWithTag
      });
      yield import_core29.sagaEffects.put(pubSubChannel, {
        type: typeToEmit,
        payload: __spreadValues({
          tag: controlId
        }, action.payload)
      });
      done();
    }
    if (action.payload.final === false) {
      yield import_core29.sagaEffects.put(pubSubChannel, {
        type: "calling.prompt.updated",
        payload: payloadWithTag
      });
    }
  }
  (0, import_core29.getLogger)().trace("voiceCallPromptWorker ended");
};

// src/voice/workers/voiceCallTapWorker.ts
var import_core30 = require("@signalwire/core");
var voiceCallTapWorker = function* (options) {
  (0, import_core30.getLogger)().trace("voiceCallTapWorker started");
  const { channels, instance, initialState } = options;
  const { swEventChannel, pubSubChannel } = channels;
  const { controlId } = initialState;
  if (!controlId) {
    throw new Error("Missing controlId for tapping");
  }
  let run = true;
  const done = () => run = false;
  while (run) {
    const action = yield import_core30.sagaEffects.take(swEventChannel, (action2) => {
      return action2.type === "calling.call.tap" && action2.payload.control_id === controlId;
    });
    const payloadWithTag = __spreadValues({
      tag: instance.tag
    }, action.payload);
    yield import_core30.sagaEffects.put(pubSubChannel, {
      type: callingTapTriggerEvent,
      payload: payloadWithTag
    });
    switch (action.payload.state) {
      case "tapping": {
        yield import_core30.sagaEffects.put(pubSubChannel, {
          type: "calling.tap.started",
          payload: payloadWithTag
        });
        break;
      }
      case "finished": {
        yield import_core30.sagaEffects.put(pubSubChannel, {
          type: "calling.tap.ended",
          payload: payloadWithTag
        });
        yield import_core30.sagaEffects.put(pubSubChannel, {
          type: "calling.tap.ended",
          payload: __spreadValues({
            tag: controlId
          }, action.payload)
        });
        done();
        break;
      }
    }
  }
  (0, import_core30.getLogger)().trace("voiceCallTapWorker ended");
};

// src/voice/workers/voiceCallConnectWorker.ts
var import_core31 = require("@signalwire/core");
var voiceCallConnectWorker = function* (options) {
  (0, import_core31.getLogger)().trace("voiceCallConnectWorker started");
  const { channels, instance } = options;
  const { swEventChannel, pubSubChannel } = channels;
  let run = true;
  const done = () => run = false;
  while (run) {
    const action = yield import_core31.sagaEffects.take(swEventChannel, (action2) => {
      var _a;
      return action2.type === "calling.call.connect" && (action2.payload.call_id === instance.callId || action2.payload.tag === instance.tag || ((_a = action2.payload.peer) == null ? void 0 : _a.tag) === instance.tag);
    });
    const payloadWithTag = __spreadValues({
      tag: instance.tag
    }, action.payload);
    yield import_core31.sagaEffects.put(pubSubChannel, {
      type: `calling.connect.${action.payload.connect_state}`,
      payload: payloadWithTag
    });
    switch (action.payload.connect_state) {
      case "connected": {
        yield import_core31.sagaEffects.put(pubSubChannel, {
          type: "calling.call.state",
          payload: {
            call_id: instance.callId,
            call_state: instance.state,
            context: instance.context,
            tag: instance.tag,
            direction: instance.direction,
            device: instance.device,
            node_id: instance.nodeId,
            peer: action.payload.peer
          }
        });
        break;
      }
      case "disconnected":
      case "failed": {
        done();
        break;
      }
    }
  }
  (0, import_core31.getLogger)().trace("voiceCallConnectWorker ended");
};

// src/voice/workers/voiceCallDialWorker.ts
var import_core32 = require("@signalwire/core");
var TARGET_DIAL_STATES = [
  "answered",
  "failed"
];
var voiceCallDialWorker = function* (options) {
  const { channels, instance, onDone, onFail } = options;
  const { swEventChannel } = channels;
  (0, import_core32.getLogger)().trace("voiceCallDialWorker started");
  const action = yield import_core32.sagaEffects.take(swEventChannel, (action2) => {
    if (action2.type === "calling.call.dial" && TARGET_DIAL_STATES.includes(action2.payload.dial_state)) {
      return instance.tag === action2.payload.tag;
    }
    return false;
  });
  if (action.payload.dial_state === "answered") {
    onDone == null ? void 0 : onDone(instance);
  } else if (action.payload.dial_state === "failed") {
    onFail == null ? void 0 : onFail((0, import_core32.toExternalJSON)(action.payload));
  } else {
    throw new Error("[voiceCallDialWorker] unhandled call_state");
  }
  (0, import_core32.getLogger)().trace("voiceCallDialWorker ended");
};

// src/voice/workers/VoiceCallSendDigitWorker.ts
var import_core33 = require("@signalwire/core");
var TARGET_STATES = [
  "finished"
];
var voiceCallSendDigitsWorker = function* (options) {
  (0, import_core33.getLogger)().trace("voiceCallSendDigitsWorker started");
  const { channels, onDone, onFail, initialState = {}, instance } = options;
  const { swEventChannel } = channels;
  const { controlId } = initialState;
  if (!controlId) {
    throw new Error("Missing controlId for sendDigits");
  }
  const action = yield import_core33.sagaEffects.take(swEventChannel, (action2) => {
    if (action2.type === "calling.call.send_digits" && TARGET_STATES.includes(action2.payload.state)) {
      return action2.payload.control_id === controlId;
    }
    return false;
  });
  if (action.payload.state === "finished") {
    onDone == null ? void 0 : onDone(instance);
  } else {
    const error = new Error(`[voiceCallSendDigitsWorker] unhandled state: '${action.payload.state}'`);
    if (typeof onFail === "function") {
      onFail({ error });
    } else {
      throw error;
    }
  }
  (0, import_core33.getLogger)().trace("voiceCallSendDigitsWorker ended");
};

// src/voice/workers/voiceCallDetectWorker.ts
var import_core34 = require("@signalwire/core");
var voiceCallDetectWorker = function* (options) {
  (0, import_core34.getLogger)().trace("voiceCallDetectWorker started");
  const { channels, instance, initialState } = options;
  const { swEventChannel, pubSubChannel } = channels;
  const { controlId, waitForBeep = false } = initialState;
  if (!controlId) {
    throw new Error("Missing controlId for tapping");
  }
  let waitingForReady = false;
  let run = true;
  let lastAction;
  const done = () => run = false;
  while (run) {
    const action = yield import_core34.sagaEffects.take(swEventChannel, (action2) => {
      return action2.type === "calling.call.detect" && action2.payload.control_id === controlId;
    });
    const { detect } = action.payload;
    if (!detect) {
      continue;
    }
    lastAction = action;
    const payloadWithTag = __spreadValues({
      tag: instance.tag
    }, action.payload);
    yield import_core34.sagaEffects.put(pubSubChannel, {
      type: callingDetectTriggerEvent,
      payload: payloadWithTag
    });
    const {
      type,
      params: { event }
    } = detect;
    if (event === "error" || event === "finished") {
      yield import_core34.sagaEffects.put(pubSubChannel, {
        type: "calling.detect.ended",
        payload: payloadWithTag
      });
      done();
      continue;
    }
    yield import_core34.sagaEffects.put(pubSubChannel, {
      type: "calling.detect.updated",
      payload: payloadWithTag
    });
    switch (type) {
      case "machine": {
        if (waitingForReady && event === "READY") {
          yield import_core34.sagaEffects.put(pubSubChannel, {
            type: "calling.detect.ended",
            payload: payloadWithTag
          });
          done();
        }
        if (waitForBeep) {
          waitingForReady = true;
        }
        break;
      }
    }
  }
  if (lastAction) {
    yield import_core34.sagaEffects.put(pubSubChannel, {
      type: "calling.detect.ended",
      payload: __spreadProps(__spreadValues({}, lastAction.payload), {
        tag: controlId
      })
    });
  }
  (0, import_core34.getLogger)().trace("voiceCallDetectWorker ended");
};

// src/voice/CallPlayback.ts
var import_core35 = require("@signalwire/core");
var CallPlaybackAPI = class extends import_core35.BaseComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "_eventsPrefix", "calling");
    __publicField(this, "callId");
    __publicField(this, "nodeId");
    __publicField(this, "controlId");
    __publicField(this, "state", "playing");
    __publicField(this, "_volume");
  }
  get id() {
    return this.controlId;
  }
  get volume() {
    return this._volume;
  }
  pause() {
    return __async(this, null, function* () {
      yield this.execute({
        method: "calling.play.pause",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: this.controlId
        }
      });
      return this;
    });
  }
  resume() {
    return __async(this, null, function* () {
      yield this.execute({
        method: "calling.play.resume",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: this.controlId
        }
      });
      return this;
    });
  }
  stop() {
    return __async(this, null, function* () {
      yield this.execute({
        method: "calling.play.stop",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: this.controlId
        }
      });
      return this;
    });
  }
  setVolume(volume) {
    return __async(this, null, function* () {
      this._volume = volume;
      yield this.execute({
        method: "calling.play.volume",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: this.controlId,
          volume
        }
      });
      return this;
    });
  }
  waitForEnded() {
    return this.ended();
  }
  ended() {
    return new Promise((resolve) => {
      this._attachListeners(this.controlId);
      const handler = () => {
        resolve(this);
      };
      this.once("playback.ended", handler);
    });
  }
};
var createCallPlaybackObject = (params) => {
  const playback = (0, import_core35.connect)({
    store: params.store,
    Component: CallPlaybackAPI,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(params);
  return playback;
};

// src/voice/CallRecording.ts
var import_core36 = require("@signalwire/core");
var CallRecordingAPI = class extends import_core36.BaseComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "_eventsPrefix", "calling");
    __publicField(this, "callId");
    __publicField(this, "nodeId");
    __publicField(this, "controlId");
    __publicField(this, "state", "recording");
  }
  get id() {
    return this.controlId;
  }
  stop() {
    return __async(this, null, function* () {
      yield this.execute({
        method: "calling.record.stop",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: this.controlId
        }
      });
      return this;
    });
  }
  ended() {
    return new Promise((resolve) => {
      this._attachListeners(this.controlId);
      const handler = () => {
        this.off("recording.ended", handler);
        this.off("recording.failed", handler);
        resolve(this);
      };
      this.once("recording.ended", handler);
      this.once("recording.failed", handler);
    });
  }
};
var createCallRecordingObject = (params) => {
  const record = (0, import_core36.connect)({
    store: params.store,
    Component: CallRecordingAPI,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(params);
  return record;
};

// src/voice/CallPrompt.ts
var import_core37 = require("@signalwire/core");
var CallPromptAPI = class extends import_core37.BaseComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "_eventsPrefix", "calling");
    __publicField(this, "callId");
    __publicField(this, "nodeId");
    __publicField(this, "controlId");
    __publicField(this, "result");
  }
  get id() {
    return this.controlId;
  }
  get type() {
    var _a;
    return (_a = this.result) == null ? void 0 : _a.type;
  }
  get reason() {
    return this.type;
  }
  get digits() {
    var _a;
    if (((_a = this.result) == null ? void 0 : _a.type) === "digit") {
      return this.result.params.digits;
    }
    return void 0;
  }
  get terminator() {
    var _a;
    if (((_a = this.result) == null ? void 0 : _a.type) === "digit") {
      return this.result.params.terminator;
    }
    return void 0;
  }
  get text() {
    var _a;
    if (((_a = this.result) == null ? void 0 : _a.type) === "speech") {
      return this.result.params.text;
    }
    return void 0;
  }
  get confidence() {
    var _a;
    if (((_a = this.result) == null ? void 0 : _a.type) === "speech") {
      return this.result.params.confidence;
    }
    return void 0;
  }
  stop() {
    return __async(this, null, function* () {
      if (!this.result) {
        yield this.execute({
          method: "calling.play_and_collect.stop",
          params: {
            node_id: this.nodeId,
            call_id: this.callId,
            control_id: this.controlId
          }
        });
      }
      return this;
    });
  }
  setVolume(volume) {
    return __async(this, null, function* () {
      yield this.execute({
        method: "calling.play_and_collect.volume",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: this.controlId,
          volume
        }
      });
      return this;
    });
  }
  waitForResult() {
    return this.ended();
  }
  ended() {
    return new Promise((resolve) => {
      this._attachListeners(this.controlId);
      const handler = (_callPrompt) => {
        this.off("prompt.ended", handler);
        this.off("prompt.failed", handler);
        resolve(this);
      };
      this.once("prompt.ended", handler);
      this.once("prompt.failed", handler);
    });
  }
};
var createCallPromptObject = (params) => {
  const record = (0, import_core37.connect)({
    store: params.store,
    Component: CallPromptAPI,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(params);
  return record;
};

// src/voice/CallTap.ts
var import_core38 = require("@signalwire/core");
var CallTapAPI = class extends import_core38.BaseComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "callId");
    __publicField(this, "nodeId");
    __publicField(this, "controlId");
    __publicField(this, "state");
  }
  get id() {
    return this.controlId;
  }
  stop() {
    return __async(this, null, function* () {
      if (this.state !== "finished") {
        yield this.execute({
          method: "calling.tap.stop",
          params: {
            node_id: this.nodeId,
            call_id: this.callId,
            control_id: this.controlId
          }
        });
      }
      return this;
    });
  }
  ended() {
    return new Promise((resolve) => {
      this._attachListeners(this.controlId);
      const handler = () => {
        resolve(this);
      };
      this.once("tap.ended", handler);
    });
  }
};
var createCallTapObject = (params) => {
  const tap = (0, import_core38.connect)({
    store: params.store,
    Component: CallTapAPI,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(params);
  return tap;
};

// src/voice/CallDetect.ts
var import_core39 = require("@signalwire/core");
var CallDetectAPI = class extends import_core39.BaseComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "_eventsPrefix", "calling");
    __publicField(this, "callId");
    __publicField(this, "nodeId");
    __publicField(this, "controlId");
    __publicField(this, "detect");
  }
  get id() {
    return this.controlId;
  }
  get type() {
    var _a;
    return (_a = this == null ? void 0 : this.detect) == null ? void 0 : _a.type;
  }
  stop() {
    return __async(this, null, function* () {
      yield this.execute({
        method: "calling.detect.stop",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: this.controlId
        }
      });
      return this;
    });
  }
  waitForResult() {
    return this.ended();
  }
  ended() {
    return new Promise((resolve) => {
      this._attachListeners(this.controlId);
      this.once("detect.ended", () => {
        resolve(this);
      });
    });
  }
};
var createCallDetectObject = (params) => {
  const detect = (0, import_core39.connect)({
    store: params.store,
    Component: CallDetectAPI,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(params);
  return detect;
};

// src/voice/DeviceBuilder.ts
var DeviceBuilder = class {
  constructor() {
    __publicField(this, "_devices", []);
  }
  get devices() {
    return this._devices;
  }
  add(params) {
    if (Array.isArray(params)) {
      this._devices.push(params);
    } else {
      this._devices.push([params]);
    }
    return this;
  }
  static Phone(params) {
    return __spreadValues({ type: "phone" }, params);
  }
  static Sip(params) {
    return __spreadValues({ type: "sip" }, params);
  }
};

// src/voice/Call.ts
var callingPlaybackTriggerEvent = (0, import_core40.toLocalEvent)("calling.playback.trigger");
var callingRecordTriggerEvent = (0, import_core40.toLocalEvent)("calling.recording.trigger");
var callingPromptTriggerEvent = (0, import_core40.toLocalEvent)("calling.prompt.trigger");
var callingTapTriggerEvent = (0, import_core40.toLocalEvent)("calling.tap.trigger");
var callingDetectTriggerEvent = (0, import_core40.toLocalEvent)("calling.detect.trigger");
var CallConsumer = class extends AutoApplyTransformsConsumer {
  constructor(options) {
    super(options);
    __publicField(this, "_eventsPrefix", "calling");
    __publicField(this, "callId");
    __publicField(this, "nodeId");
    __publicField(this, "peer");
    __publicField(this, "callState");
    __publicField(this, "detectAnsweringMachine", this.amd);
    this._attachListeners(this.__uuid);
    this.applyEmitterTransforms({ local: true });
    this.on("call.state", () => {
    });
    this.runWorker("voiceCallStateWorker", {
      worker: voiceCallStateWorker
    });
  }
  get id() {
    return this.callId;
  }
  get state() {
    return this.callState;
  }
  get tag() {
    return this.__uuid;
  }
  get type() {
    var _a, _b;
    return (_b = (_a = this.device) == null ? void 0 : _a.type) != null ? _b : "";
  }
  get from() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    if (this.type === "phone") {
      return (_c = (_b = (_a = this.device) == null ? void 0 : _a.params) == null ? void 0 : _b.fromNumber) != null ? _c : "";
    } else if (this.type === "sip") {
      return (_f = (_e = (_d = this.device) == null ? void 0 : _d.params) == null ? void 0 : _e.from) != null ? _f : "";
    }
    return (_i = (_h = (_g = this.device) == null ? void 0 : _g.params) == null ? void 0 : _h.from) != null ? _i : "";
  }
  get to() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    if (this.type === "phone") {
      return (_c = (_b = (_a = this.device) == null ? void 0 : _a.params) == null ? void 0 : _b.toNumber) != null ? _c : "";
    } else if (this.type === "sip") {
      return (_f = (_e = (_d = this.device) == null ? void 0 : _d.params) == null ? void 0 : _e.to) != null ? _f : "";
    }
    return (_i = (_h = (_g = this.device) == null ? void 0 : _g.params) == null ? void 0 : _h.to) != null ? _i : "";
  }
  get headers() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this.device) == null ? void 0 : _a.params) == null ? void 0 : _b.headers) != null ? _c : [];
  }
  getEmitterTransforms() {
    return /* @__PURE__ */ new Map([
      [
        [
          callingPlaybackTriggerEvent,
          "calling.playback.started",
          "calling.playback.updated",
          "calling.playback.ended"
        ],
        {
          type: "voiceCallPlayback",
          instanceFactory: (_payload) => {
            return createCallPlaybackObject({
              store: this.store,
              emitter: this.emitter
            });
          },
          payloadTransform: (payload) => {
            return (0, import_core40.toExternalJSON)(payload);
          }
        }
      ],
      [
        [
          callingRecordTriggerEvent,
          "calling.recording.started",
          "calling.recording.updated",
          "calling.recording.ended",
          "calling.recording.failed"
        ],
        {
          type: "voiceCallRecord",
          instanceFactory: (_payload) => {
            return createCallRecordingObject({
              store: this.store,
              emitter: this.emitter
            });
          },
          payloadTransform: (payload) => {
            return (0, import_core40.toExternalJSON)(payload);
          }
        }
      ],
      [
        [
          callingPromptTriggerEvent,
          "calling.prompt.started",
          "calling.prompt.updated",
          "calling.prompt.ended",
          "calling.prompt.failed"
        ],
        {
          type: "voiceCallPrompt",
          instanceFactory: (_payload) => {
            return createCallPromptObject({
              store: this.store,
              emitter: this.emitter
            });
          },
          payloadTransform: (payload) => {
            return (0, import_core40.toExternalJSON)(payload);
          }
        }
      ],
      [
        [callingTapTriggerEvent, "calling.tap.started", "calling.tap.ended"],
        {
          type: "voiceCallTap",
          instanceFactory: (_payload) => {
            return createCallTapObject({
              store: this.store,
              emitter: this.emitter
            });
          },
          payloadTransform: (payload) => {
            return (0, import_core40.toExternalJSON)(payload);
          }
        }
      ],
      [
        ["calling.call.state"],
        {
          type: "voiceCallState",
          instanceFactory: (_payload) => {
            return this;
          },
          payloadTransform: (payload) => {
            return (0, import_core40.toExternalJSON)(payload);
          }
        }
      ],
      [
        ["calling.connect.connected"],
        {
          type: "voiceCallConnect",
          instanceFactory: (_payload) => {
            return createCallObject({
              store: this.store,
              emitter: this.emitter
            });
          },
          payloadTransform: (payload) => {
            const _a = payload.peer, { tag } = _a, peerParams = __objRest(_a, ["tag"]);
            return (0, import_core40.toExternalJSON)(peerParams);
          }
        }
      ],
      [
        [
          callingDetectTriggerEvent,
          "calling.detect.started",
          "calling.detect.updated",
          "calling.detect.ended"
        ],
        {
          type: "voiceCallDetect",
          instanceFactory: (_payload) => {
            return createCallDetectObject({
              store: this.store,
              emitter: this.emitter
            });
          },
          payloadTransform: (payload) => {
            return (0, import_core40.toExternalJSON)(payload);
          }
        }
      ]
    ]);
  }
  dial(params) {
    return new Promise((resolve, reject) => {
      this.runWorker("voiceCallDialWorker", {
        worker: voiceCallDialWorker,
        onDone: resolve,
        onFail: reject
      });
      let executeParams;
      if (params instanceof DeviceBuilder) {
        const { devices } = params;
        executeParams = {
          tag: this.__uuid,
          devices: toInternalDevices(devices)
        };
      } else if ("region" in params) {
        const { region, devices: deviceBuilder } = params;
        executeParams = {
          tag: this.__uuid,
          region,
          devices: toInternalDevices(deviceBuilder.devices)
        };
      } else {
        throw new Error("[dial] Invalid input");
      }
      this.execute({
        method: "calling.dial",
        params: executeParams
      }).catch((e) => {
        reject(e);
      });
    });
  }
  hangup(reason = "hangup") {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call hangup() on a call that hasn't been established.`));
      }
      this.on("call.state", (params) => {
        if (params.callState === "ended") {
          resolve(new Error("Failed to hangup the call."));
        }
      });
      this.execute({
        method: "calling.end",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          reason
        }
      }).catch((e) => {
        reject(e);
      });
    });
  }
  answer() {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call answer() on a call without callId.`));
      }
      this.on("call.state", (params) => {
        if (params.callState === "answered") {
          resolve(this);
        } else if (params.callState === "ended") {
          reject(new Error("Failed to answer the call."));
        }
      });
      this.execute({
        method: "calling.answer",
        params: {
          node_id: this.nodeId,
          call_id: this.callId
        }
      }).catch((e) => {
        reject(e);
      });
    });
  }
  play(params) {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call play() on a call not established yet.`));
      }
      const controlId = (0, import_core40.uuid)();
      this.runWorker("voiceCallPlayWorker", {
        worker: voiceCallPlayWorker,
        initialState: {
          controlId
        }
      });
      const resolveHandler = (callPlayback) => {
        resolve(callPlayback);
      };
      this.on(callingPlaybackTriggerEvent, resolveHandler);
      this.execute({
        method: "calling.play",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: controlId,
          volume: params.volume,
          play: toInternalPlayParams(params.media)
        }
      }).then(() => {
        const startEvent = {
          control_id: controlId,
          call_id: this.id,
          node_id: this.nodeId
        };
        this.emit(callingPlaybackTriggerEvent, startEvent);
      }).catch((e) => {
        this.off(callingPlaybackTriggerEvent, resolveHandler);
        reject(e);
      });
    });
  }
  playAudio(params) {
    const _a = params, { volume } = _a, rest = __objRest(_a, ["volume"]);
    const playlist = new Playlist({ volume }).add(Playlist.Audio(rest));
    return this.play(playlist);
  }
  playSilence(params) {
    const playlist = new Playlist().add(Playlist.Silence(params));
    return this.play(playlist);
  }
  playRingtone(params) {
    const _a = params, { volume } = _a, rest = __objRest(_a, ["volume"]);
    const playlist = new Playlist({ volume }).add(Playlist.Ringtone(rest));
    return this.play(playlist);
  }
  playTTS(params) {
    const _a = params, { volume } = _a, rest = __objRest(_a, ["volume"]);
    const playlist = new Playlist({ volume }).add(Playlist.TTS(rest));
    return this.play(playlist);
  }
  record(params) {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call record() on a call not established yet.`));
      }
      const controlId = (0, import_core40.uuid)();
      this.runWorker("voiceCallRecordWorker", {
        worker: voiceCallRecordWorker,
        initialState: {
          controlId
        }
      });
      const resolveHandler = (callRecording) => {
        resolve(callRecording);
      };
      this.on(callingRecordTriggerEvent, resolveHandler);
      const record = (0, import_core40.toSnakeCaseKeys)(params);
      this.execute({
        method: "calling.record",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: controlId,
          record
        }
      }).then(() => {
        const startEvent = {
          control_id: controlId,
          call_id: this.id,
          node_id: this.nodeId,
          record
        };
        this.emit(callingRecordTriggerEvent, startEvent);
      }).catch((e) => {
        this.off(callingRecordTriggerEvent, resolveHandler);
        reject(e);
      });
    });
  }
  recordAudio(params = {}) {
    return this.record({
      audio: params
    });
  }
  prompt(params) {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call record() on a call not established yet.`));
      }
      if (!params.playlist) {
        reject(new Error(`Missing 'playlist' params.`));
      }
      const controlId = (0, import_core40.uuid)();
      this.runWorker("voiceCallPromptWorker", {
        worker: voiceCallPromptWorker,
        initialState: {
          controlId
        }
      });
      const resolveHandler = (callRecording) => {
        resolve(callRecording);
      };
      this.on(callingPromptTriggerEvent, resolveHandler);
      const { volume, media } = params.playlist;
      const { initial_timeout, partial_results, digits, speech } = (0, import_core40.toSnakeCaseKeys)(params);
      const collect = {
        initial_timeout,
        partial_results,
        digits,
        speech
      };
      this.execute({
        method: "calling.play_and_collect",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: controlId,
          volume,
          play: toInternalPlayParams(media),
          collect
        }
      }).then(() => {
        const startEvent = {
          control_id: controlId,
          call_id: this.id,
          node_id: this.nodeId
        };
        this.emit("prompt.started", startEvent);
        this.emit(callingPromptTriggerEvent, startEvent);
      }).catch((e) => {
        this.off("prompt.started", resolveHandler);
        this.off(callingPromptTriggerEvent, resolveHandler);
        reject(e);
      });
    });
  }
  promptAudio(params) {
    const _a = params, { url, volume } = _a, rest = __objRest(_a, ["url", "volume"]);
    const playlist = new Playlist({ volume }).add(Playlist.Audio({ url }));
    return this.prompt(__spreadValues({
      playlist
    }, rest));
  }
  promptRingtone(params) {
    const _a = params, { name, duration, volume } = _a, rest = __objRest(_a, ["name", "duration", "volume"]);
    const playlist = new Playlist({ volume }).add(Playlist.Ringtone({ name, duration }));
    return this.prompt(__spreadValues({
      playlist
    }, rest));
  }
  promptTTS(params) {
    const _a = params, { text, language, gender, volume } = _a, rest = __objRest(_a, ["text", "language", "gender", "volume"]);
    const playlist = new Playlist({ volume }).add(Playlist.TTS({ text, language, gender }));
    return this.prompt(__spreadValues({
      playlist
    }, rest));
  }
  sendDigits(digits) {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call sendDigits() on a call not established yet.`));
      }
      const controlId = (0, import_core40.uuid)();
      const cleanup = () => {
        this.off("call.state", callStateHandler);
      };
      this.runWorker("voiceCallSendDigitsWorker", {
        worker: voiceCallSendDigitsWorker,
        initialState: {
          controlId
        },
        onDone: (args) => {
          cleanup();
          resolve(args);
        },
        onFail: ({ error }) => {
          cleanup();
          reject(error);
        }
      });
      const callStateHandler = (params) => {
        if (params.callState === "ended" || params.callState === "ending") {
          reject(new Error("Call is ended or about to end, couldn't send digits in time."));
        }
      };
      this.once("call.state", callStateHandler);
      this.execute({
        method: "calling.send_digits",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: controlId,
          digits
        }
      }).catch((e) => {
        reject(e);
      });
    });
  }
  tap(params) {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call tap() on a call not established yet.`));
      }
      const controlId = (0, import_core40.uuid)();
      this.runWorker("voiceCallTapWorker", {
        worker: voiceCallTapWorker,
        initialState: {
          controlId
        }
      });
      const resolveHandler = (callTap) => {
        resolve(callTap);
      };
      this.on(callingTapTriggerEvent, resolveHandler);
      const {
        audio = {},
        device: _a
      } = params, _b = _a, { type } = _b, rest = __objRest(_b, ["type"]);
      this.execute({
        method: "calling.tap",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: controlId,
          tap: {
            type: "audio",
            params: audio
          },
          device: {
            type,
            params: rest
          }
        }
      }).then(() => {
        const startEvent = {
          control_id: controlId,
          call_id: this.id,
          node_id: this.nodeId
        };
        this.emit(callingTapTriggerEvent, startEvent);
      }).catch((e) => {
        this.off(callingTapTriggerEvent, resolveHandler);
        reject(e);
      });
    });
  }
  tapAudio(params) {
    const { direction, device } = params;
    return this.tap({ audio: { direction }, device });
  }
  connect(params) {
    return new Promise((resolve, reject) => {
      var _a;
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call connect() on a call not established yet.`));
      }
      let executeParams;
      if (params instanceof DeviceBuilder) {
        const { devices } = params;
        executeParams = {
          tag: this.__uuid,
          devices: toInternalDevices(devices)
        };
      } else if ("ringback" in params) {
        const { ringback, devices: deviceBuilder } = params;
        executeParams = {
          tag: this.__uuid,
          ringback: toInternalPlayParams((_a = ringback == null ? void 0 : ringback.media) != null ? _a : []),
          devices: toInternalDevices(deviceBuilder.devices)
        };
      } else {
        throw new Error("[connect] Invalid input");
      }
      this.runWorker("voiceCallConnectWorker", {
        worker: voiceCallConnectWorker
      });
      const resolveHandler = (payload) => {
        this.off("connect.failed", rejectHandler);
        resolve(payload);
      };
      const rejectHandler = (payload) => {
        this.off("connect.connected", resolveHandler);
        reject((0, import_core40.toExternalJSON)(payload));
      };
      this.once("connect.connected", resolveHandler);
      this.once("connect.failed", rejectHandler);
      this.execute({
        method: "calling.connect",
        params: __spreadValues({
          node_id: this.nodeId,
          call_id: this.callId,
          tag: this.__uuid
        }, executeParams)
      }).catch((e) => {
        this.off("connect.connected", resolveHandler);
        this.off("connect.failed", rejectHandler);
        reject(e);
      });
    });
  }
  connectPhone(_a) {
    var _b = _a, { ringback } = _b, params = __objRest(_b, ["ringback"]);
    const devices = new DeviceBuilder().add(DeviceBuilder.Phone(params));
    return this.connect({ devices, ringback });
  }
  connectSip(_c) {
    var _d = _c, { ringback } = _d, params = __objRest(_d, ["ringback"]);
    const devices = new DeviceBuilder().add(DeviceBuilder.Sip(params));
    return this.connect({ devices, ringback });
  }
  disconnect() {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId || !this.peer) {
        reject(new Error(`Can't call disconnect() on a call not connected yet.`));
      }
      const resolveHandler = () => {
        resolve();
      };
      this.once("connect.disconnected", resolveHandler);
      this.execute({
        method: "calling.disconnect",
        params: {
          node_id: this.nodeId,
          call_id: this.callId
        }
      }).catch((e) => {
        this.off("connect.disconnected", resolveHandler);
        reject(e);
      });
    });
  }
  waitForDisconnected() {
    return this.disconnect;
  }
  disconnected() {
    return new Promise((resolve) => {
      const resolveHandler = () => {
        resolve(this);
      };
      this.once("connect.disconnected", resolveHandler);
      this.once("connect.failed", resolveHandler);
      if (this.state === "ended" || this.state === "ending") {
        return resolveHandler();
      }
    });
  }
  detect(params) {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call detect() on a call not established yet.`));
      }
      const _a = params, { waitForBeep = false, timeout, type } = _a, rest = __objRest(_a, ["waitForBeep", "timeout", "type"]);
      const controlId = (0, import_core40.uuid)();
      this.runWorker("voiceCallDetectWorker", {
        worker: voiceCallDetectWorker,
        initialState: {
          controlId,
          waitForBeep
        }
      });
      const resolveHandler = (callDetect) => {
        resolve(callDetect);
      };
      this.on(callingDetectTriggerEvent, resolveHandler);
      this.execute({
        method: "calling.detect",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: controlId,
          timeout,
          detect: {
            type,
            params: (0, import_core40.toSnakeCaseKeys)(rest)
          }
        }
      }).then(() => {
        const startEvent = {
          control_id: controlId,
          call_id: this.id,
          node_id: this.nodeId
        };
        this.emit(callingDetectTriggerEvent, startEvent);
      }).catch((e) => {
        this.off(callingDetectTriggerEvent, resolveHandler);
        reject(e);
      });
    });
  }
  amd(params = {}) {
    return this.detect(__spreadProps(__spreadValues({}, params), {
      type: "machine"
    }));
  }
  detectFax(params = {}) {
    return this.detect(__spreadProps(__spreadValues({}, params), {
      type: "fax"
    }));
  }
  detectDigit(params = {}) {
    return this.detect(__spreadProps(__spreadValues({}, params), {
      type: "digit"
    }));
  }
  waitFor(params) {
    return new Promise((resolve) => {
      if (!params) {
        resolve(true);
      }
      const events = Array.isArray(params) ? params : [params];
      const emittedCallStates = /* @__PURE__ */ new Set();
      const shouldResolve = () => emittedCallStates.size === events.length;
      const shouldWaitForEnded = events.includes("ended");
      const shouldResolveUnsuccessful = (state) => {
        return !shouldWaitForEnded && state === "ended";
      };
      this.on("call.state", (params2) => {
        if (events.includes(params2.callState)) {
          emittedCallStates.add(params2.callState);
        } else if (shouldResolveUnsuccessful(params2.callState)) {
          return resolve(false);
        }
        if (shouldResolve()) {
          resolve(true);
        }
      });
    });
  }
};
var CallAPI = (0, import_core40.extendComponent)(CallConsumer, {});
var createCallObject = (params) => {
  const call = (0, import_core40.connect)({
    store: params.store,
    Component: CallAPI,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(params);
  return call;
};

// src/voice/VoiceClient.ts
var VoiceClient = function(options) {
  const { client, store, emitter } = setupClient(options);
  const voice = createVoiceObject(__spreadValues({
    store,
    emitter
  }, options));
  const callDial = (dialer) => __async(this, null, function* () {
    yield clientConnect(client);
    const call = createCallObject({
      store,
      emitter
    });
    yield call.dial(dialer);
    return call;
  });
  const disconnect = () => client.disconnect();
  const interceptors = __spreadProps(__spreadValues({}, clientContextInterceptorsFactory(client)), {
    dial: callDial,
    _session: client,
    disconnect
  });
  return new Proxy(voice, {
    get(target, prop, receiver) {
      if (prop in interceptors) {
        return interceptors[prop];
      }
      if (typeof target[prop] === "function") {
        clientConnect(client);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/voice/Voice.ts
var VoiceAPI = class extends AutoApplyTransformsConsumer {
  constructor(options) {
    super(options);
    __publicField(this, "_eventsPrefix", "calling");
    this.runWorker("voiceCallReceiveWorker", {
      worker: voiceCallReceiveWorker
    });
    this._attachListeners("");
  }
  getEmitterTransforms() {
    return /* @__PURE__ */ new Map([
      [
        "calling.call.received",
        {
          mode: "no-cache",
          type: "voiceCallReceived",
          instanceFactory: (_payload) => {
            return createCallObject({
              store: this.store,
              emitter: this.emitter
            });
          },
          payloadTransform: (payload) => {
            return (0, import_core41.toExternalJSON)(payload);
          }
        }
      ]
    ]);
  }
  dialPhone(_a) {
    var _b = _a, { region } = _b, params = __objRest(_b, ["region"]);
    const devices = new DeviceBuilder().add(DeviceBuilder.Phone(params));
    return this.dial({
      region,
      devices
    });
  }
  dialSip(_c) {
    var _d = _c, { region } = _d, params = __objRest(_d, ["region"]);
    const devices = new DeviceBuilder().add(DeviceBuilder.Sip(params));
    return this.dial({
      region,
      devices
    });
  }
};
var createVoiceObject = (params) => {
  const voice = (0, import_core41.connect)({
    store: params.store,
    Component: VoiceAPI,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(params);
  return voice;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Chat,
  Messaging,
  PubSub,
  Task,
  Video,
  Voice,
  config,
  createClient,
  getConfig
});
//# sourceMappingURL=index.node.js.map
