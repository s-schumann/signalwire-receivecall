{
  "version": 3,
  "sources": ["../src/video/Video.ts", "../src/AutoSubscribeConsumer.ts", "../src/video/RoomSession.ts", "../src/video/RoomSessionMember.ts", "../src/video/memberPosition/workers.ts", "../src/client/Client.ts", "../src/client/clientConnect.ts", "../src/client/setupClient.ts", "../src/utils/internals.ts", "../src/configure/index.ts", "../src/Session.ts", "../src/client/clientProxyFactory.ts", "../src/client/getClient.ts", "../src/video/VideoClient.ts", "../src/createClient.ts", "../src/Client.ts", "../src/chat/Chat.ts", "../src/chat/ChatClient.ts", "../src/pubSub/PubSub.ts", "../src/pubSub/PubSubClient.ts", "../src/task/Task.ts", "../src/task/workers.ts", "../src/common/clientContext.ts", "../src/task/TaskClient.ts", "../src/task/send.ts", "../src/messaging/Messaging.ts", "../src/messaging/workers.ts", "../src/messaging/Message.ts", "../src/messaging/MessagingClient.ts", "../src/voice/Voice.ts", "../src/voice/Call.ts", "../src/AutoApplyTransformsConsumer.ts", "../src/voice/utils.ts", "../src/voice/Playlist.ts", "../src/voice/workers/voiceCallStateWorker.ts", "../src/voice/workers/voiceCallReceiveWorker.ts", "../src/voice/workers/voiceCallPlayWorker.ts", "../src/voice/workers/voiceCallRecordWorker.ts", "../src/voice/workers/voiceCallPromptWorker.ts", "../src/voice/workers/voiceCallTapWorker.ts", "../src/voice/workers/voiceCallConnectWorker.ts", "../src/voice/workers/voiceCallDialWorker.ts", "../src/voice/workers/VoiceCallSendDigitWorker.ts", "../src/voice/workers/voiceCallDetectWorker.ts", "../src/voice/CallPlayback.ts", "../src/voice/CallRecording.ts", "../src/voice/CallPrompt.ts", "../src/voice/CallTap.ts", "../src/voice/CallDetect.ts", "../src/voice/DeviceBuilder.ts", "../src/voice/VoiceClient.ts"],
  "sourcesContent": ["import {\n  BaseComponentOptions,\n  connect,\n  EventTransform,\n  InternalVideoRoomSessionEventNames,\n  toExternalJSON,\n  ConsumerContract,\n  RoomSessionRecording,\n  VideoRoomEventParams,\n  RoomSessionPlayback,\n  toLocalEvent,\n} from '@signalwire/core'\nimport { AutoSubscribeConsumer } from '../AutoSubscribeConsumer'\nimport type { RealtimeClient } from '../client/Client'\n\nimport {\n  RealTimeRoomApiEvents,\n  RealTimeVideoApiEvents,\n  RealTimeVideoApiEventsHandlerMapping,\n  RealTimeRoomApiEventsHandlerMapping,\n} from '../types/video'\nimport {\n  createRoomSessionObject,\n  RoomSession,\n  RoomSessionFullState,\n  RoomSessionUpdated,\n} from './RoomSession'\nimport type {\n  RoomSessionMember,\n  RoomSessionMemberUpdated,\n} from './RoomSessionMember'\n\nconst videoRoomGetTriggerEvent = toLocalEvent<TransformEvent>('video.room.get')\n\ntype TransformEvent =\n  | Extract<\n      InternalVideoRoomSessionEventNames,\n      'video.room.started' | 'video.room.ended'\n    >\n  | 'video.__local__.room.get'\n\nexport interface Video extends ConsumerContract<RealTimeVideoApiEvents> {\n  /** @internal */\n  subscribe(): Promise<void>\n  /** @internal */\n  _session: RealtimeClient\n  /**\n   * Disconnects this client. The client will stop receiving events and you will\n   * need to create a new instance if you want to use it again.\n   *\n   * @example\n   *\n   * ```js\n   * client.disconnect()\n   * ```\n   */\n  disconnect(): void\n\n  getRoomSessions(): Promise<{ roomSessions: RoomSession[] }>\n  getRoomSessionById(id: string): Promise<{ roomSession: RoomSession }>\n}\nexport type {\n  RealTimeRoomApiEvents,\n  RealTimeRoomApiEventsHandlerMapping,\n  RealTimeVideoApiEvents,\n  RealTimeVideoApiEventsHandlerMapping,\n  RoomSession,\n  RoomSessionFullState,\n  RoomSessionMember,\n  RoomSessionMemberUpdated,\n  RoomSessionPlayback,\n  RoomSessionRecording,\n  RoomSessionUpdated,\n}\n\nexport type {\n  ClientEvents,\n  EmitterContract,\n  EntityUpdated,\n  GlobalVideoEvents,\n  InternalVideoMemberEntity,\n  LayoutChanged,\n  MEMBER_UPDATED_EVENTS,\n  MemberCommandParams,\n  MemberCommandWithValueParams,\n  MemberCommandWithVolumeParams,\n  MemberJoined,\n  MemberLeft,\n  MemberListUpdated,\n  MemberTalking,\n  MemberTalkingEnded,\n  MemberTalkingEventNames,\n  MemberTalkingStart,\n  MemberTalkingStarted,\n  MemberTalkingStop,\n  MemberUpdated,\n  MemberUpdatedEventNames,\n  PlaybackEnded,\n  PlaybackStarted,\n  PlaybackUpdated,\n  RecordingEnded,\n  RecordingStarted,\n  RecordingUpdated,\n  RoomEnded,\n  RoomStarted,\n  RoomSubscribed,\n  RoomUpdated,\n  SipCodec,\n  VideoLayoutEventNames,\n  VideoMemberContract,\n  VideoMemberEntity,\n  VideoMemberEventNames,\n  VideoMemberType,\n  VideoPlaybackEventNames,\n  VideoPosition,\n  VideoRecordingEventNames,\n} from '@signalwire/core'\n\n/** @internal */\nclass VideoAPI extends AutoSubscribeConsumer<RealTimeVideoApiEvents> {\n  /** @internal */\n  protected _eventsPrefix = 'video' as const\n\n  /** @internal */\n  protected subscribeParams = {\n    get_initial_state: true,\n  }\n\n  /** @internal */\n  protected getEmitterTransforms() {\n    return new Map<TransformEvent | TransformEvent[], EventTransform>([\n      [\n        [videoRoomGetTriggerEvent, 'video.room.started', 'video.room.ended'],\n        {\n          // TODO: create a new key or use `roomSession`?\n          type: 'roomSession',\n          instanceFactory: () => {\n            return createRoomSessionObject({\n              store: this.store,\n              // Emitter is now typed.\n              // @ts-expect-error\n              emitter: this.options.emitter,\n            })\n          },\n          payloadTransform: (payload: VideoRoomEventParams) => {\n            return toExternalJSON({\n              ...payload.room_session,\n              room_session_id: payload.room_session.id,\n            })\n          },\n          getInstanceEventNamespace: (payload: VideoRoomEventParams) => {\n            return payload.room_session.id\n          },\n          getInstanceEventChannel: (payload: VideoRoomEventParams) => {\n            return payload.room_session.event_channel\n          },\n        },\n      ],\n    ])\n  }\n\n  async getRoomSessions() {\n    return new Promise<{ roomSessions: RoomSession[] }>(\n      async (resolve, reject) => {\n        try {\n          const { rooms = [] }: any = await this.execute({\n            method: 'video.rooms.get',\n            params: {},\n          })\n          const roomSessions: RoomSession[] = []\n          const handler = (instance: RoomSession) => roomSessions.push(instance)\n\n          // @ts-expect-error\n          this.on(videoRoomGetTriggerEvent, handler)\n\n          rooms.forEach((room_session: any) => {\n            // @ts-expect-error\n            this.emit(videoRoomGetTriggerEvent, { room_session })\n          })\n\n          // // @ts-expect-error\n          // this.off(videoRoomGetTriggerEvent, handler)\n          resolve({ roomSessions })\n        } catch (error) {\n          console.error('Error listing room sessions', error)\n          reject(error)\n        }\n      }\n    )\n  }\n\n  async getRoomSessionById(id: string) {\n    return new Promise<{ roomSession: RoomSession }>(\n      async (resolve, reject) => {\n        try {\n          const { room }: any = await this.execute({\n            method: 'video.room.get',\n            params: {\n              room_session_id: id,\n            },\n          })\n\n          // @ts-expect-error\n          this.once(videoRoomGetTriggerEvent, (instance: RoomSession) => {\n            resolve({ roomSession: instance })\n          })\n\n          // @ts-expect-error\n          this.emit(videoRoomGetTriggerEvent, { room_session: room })\n        } catch (error) {\n          console.error('Error retrieving the room session', error)\n          reject(error)\n        }\n      }\n    )\n  }\n}\n\n/** @internal */\nexport const createVideoObject = (\n  params: BaseComponentOptions<RealTimeVideoApiEvents>\n): Video => {\n  const video = connect<RealTimeVideoApiEvents, VideoAPI, Video>({\n    store: params.store,\n    Component: VideoAPI,\n    componentListeners: {\n      errors: 'onError',\n      responses: 'onSuccess',\n    },\n  })(params)\n\n  const proxy = new Proxy<Video>(video, {\n    get(target: any, prop: any, receiver: any) {\n      if (prop === '_eventsNamespace') {\n        /**\n         * Events at this level will always be global so\n         * there's no need for a namespace.\n         */\n        return ''\n      } else if (prop === 'eventChannel') {\n        return 'video.rooms'\n      }\n\n      return Reflect.get(target, prop, receiver)\n    },\n  })\n\n  return proxy\n}\n\nexport * from './VideoClient'\n", "import {\n  BaseComponentOptions,\n  BaseConsumer,\n  EventEmitter,\n  debounce,\n} from '@signalwire/core'\n\nexport class AutoSubscribeConsumer<\n  EventTypes extends EventEmitter.ValidEventTypes\n> extends BaseConsumer<EventTypes> {\n  /** @internal */\n  private debouncedSubscribe: ReturnType<typeof debounce>\n\n  constructor(options: BaseComponentOptions<EventTypes>) {\n    super(options)\n\n    this.debouncedSubscribe = debounce(this.subscribe, 100)\n  }\n\n  override on(\n    event: EventEmitter.EventNames<EventTypes>,\n    fn: EventEmitter.EventListener<EventTypes, any>\n  ) {\n    const instance = super.on(event, fn)\n    this.debouncedSubscribe()\n    return instance\n  }\n\n  override once(\n    event: EventEmitter.EventNames<EventTypes>,\n    fn: EventEmitter.EventListener<EventTypes, any>\n  ) {\n    const instance = super.once(event, fn)\n    this.debouncedSubscribe()\n    return instance\n  }\n}\n", "import {\n  BaseComponentOptions,\n  connect,\n  EventTransform,\n  extendComponent,\n  InternalVideoMemberEventNames,\n  INTERNAL_MEMBER_UPDATED_EVENTS,\n  Rooms,\n  toExternalJSON,\n  toLocalEvent,\n  VideoMemberEventParams,\n  InternalVideoRoomSessionEventNames,\n  VideoRoomAudienceCountEventNames,\n  VideoRoomAudienceCountEventParams,\n  VideoRoomUpdatedEventParams,\n  VideoRoomSubscribedEventParams,\n  InternalVideoLayoutEventNames,\n  InternalVideoRecordingEventNames,\n  InternalVideoPlaybackEventNames,\n  InternalVideoStreamEventNames,\n  VideoPlaybackEventParams,\n  VideoLayoutChangedEventParams,\n  VideoRoomSessionContract,\n  VideoRoomSessionMethods,\n  ConsumerContract,\n  EntityUpdated,\n  BaseConsumer,\n  EventEmitter,\n  MemberPosition,\n  debounce,\n} from '@signalwire/core'\nimport { RealTimeRoomApiEvents } from '../types'\nimport {\n  createRoomSessionMemberObject,\n  RoomSessionMember,\n} from './RoomSessionMember'\nimport { memberPositionWorker } from './memberPosition/workers'\n\ntype EmitterTransformsEvents =\n  | InternalVideoRoomSessionEventNames\n  | VideoRoomAudienceCountEventNames\n  | InternalVideoMemberEventNames\n  | InternalVideoLayoutEventNames\n  | InternalVideoRecordingEventNames\n  | 'video.__local__.recording.start'\n  | InternalVideoPlaybackEventNames\n  | 'video.__local__.playback.start'\n  | InternalVideoStreamEventNames\n  | 'video.__local__.stream.start'\n\nexport interface RoomSession\n  extends VideoRoomSessionContract,\n    ConsumerContract<RealTimeRoomApiEvents, RoomSessionFullState> {}\n\nexport type RoomSessionUpdated = EntityUpdated<RoomSession>\nexport interface RoomSessionFullState extends Omit<RoomSession, 'members'> {\n  /** List of members that are part of this room session */\n  members?: RoomSessionMember[]\n}\n\nexport class RoomSessionConsumer extends BaseConsumer<RealTimeRoomApiEvents> {\n  protected _eventsPrefix = 'video' as const\n\n  /** @internal */\n  protected subscribeParams = {\n    get_initial_state: true,\n  }\n\n  /** @internal */\n  private debouncedSubscribe: ReturnType<typeof debounce>\n\n  constructor(options: BaseComponentOptions<RealTimeRoomApiEvents>) {\n    super(options)\n\n    this.debouncedSubscribe = debounce(this.subscribe, 100)\n    this.runWorker('memberPositionWorker', {\n      worker: memberPositionWorker,\n    })\n  }\n\n  /** @internal */\n  protected _internal_on(\n    event: keyof RealTimeRoomApiEvents,\n    fn: EventEmitter.EventListener<RealTimeRoomApiEvents, any>\n  ) {\n    return super.on(event, fn)\n  }\n\n  on(\n    event: keyof RealTimeRoomApiEvents,\n    fn: EventEmitter.EventListener<RealTimeRoomApiEvents, any>\n  ) {\n    const instance = super.on(event, fn)\n    this.debouncedSubscribe()\n    return instance\n  }\n\n  once(\n    event: keyof RealTimeRoomApiEvents,\n    fn: EventEmitter.EventListener<RealTimeRoomApiEvents, any>\n  ) {\n    const instance = super.once(event, fn)\n    this.debouncedSubscribe()\n    return instance\n  }\n\n  /**\n   * @privateRemarks\n   *\n   * Override BaseConsumer `subscribe` to resolve the promise when the 'room.subscribed'\n   * event comes. This way we can return to the user the room full state.\n   * Note: the payload will go through an EventTrasform - see the `type: roomSessionSubscribed`\n   * below.\n   */\n  subscribe() {\n    return new Promise(async (resolve, reject) => {\n      const handler = (payload: RoomSessionFullState) => {\n        resolve(payload)\n      }\n      const subscriptions = this.getSubscriptions()\n      if (subscriptions.length === 0) {\n        this.logger.debug(\n          '`subscribe()` was called without any listeners attached.'\n        )\n        return\n      }\n\n      try {\n        /**\n         * Note that we're using `super.once` (instead of\n         * `this.once`) here, because we don't want to\n         * re-trigger our added custom behavior.\n         */\n        super.once('room.subscribed', handler)\n        await super.subscribe()\n      } catch (error) {\n        super.off('room.subscribed', handler)\n        return reject(error)\n      }\n    })\n  }\n\n  /** @internal */\n  protected override getCompoundEvents() {\n    return new Map<any, any>([\n      ...MemberPosition.MEMBER_POSITION_COMPOUND_EVENTS,\n    ])\n  }\n\n  /** @internal */\n  protected getEmitterTransforms() {\n    return new Map<\n      EmitterTransformsEvents | EmitterTransformsEvents[],\n      EventTransform\n    >([\n      [\n        'video.room.subscribed',\n        {\n          type: 'roomSessionSubscribed',\n          instanceFactory: () => {\n            return this\n          },\n          payloadTransform: (payload: VideoRoomSubscribedEventParams) => {\n            return toExternalJSON(payload.room_session)\n          },\n          nestedFieldsToProcess: {\n            members: {\n              eventTransformType: 'roomSessionMember',\n              processInstancePayload: (payload) => {\n                return {\n                  room_session_id: this.getStateProperty('roomSessionId'),\n                  member: payload,\n                }\n              },\n            },\n            recordings: {\n              eventTransformType: 'roomSessionRecording',\n              processInstancePayload: (payload) => {\n                return {\n                  room_session_id: this.getStateProperty('roomSessionId'),\n                  recording: payload,\n                }\n              },\n            },\n            streams: {\n              eventTransformType: 'roomSessionStream',\n              processInstancePayload: (payload) => {\n                return {\n                  room_session_id: this.getStateProperty('roomSessionId'),\n                  stream: payload,\n                }\n              },\n            },\n          },\n          getInstanceEventNamespace: (\n            payload: VideoRoomSubscribedEventParams\n          ) => {\n            return payload.room_session.id\n          },\n          getInstanceEventChannel: (\n            payload: VideoRoomSubscribedEventParams\n          ) => {\n            return payload.room_session.event_channel\n          },\n        },\n      ],\n      [\n        [toLocalEvent<EmitterTransformsEvents>('video.recording.list')],\n        {\n          type: 'roomSessionRecordingList',\n          instanceFactory: (_payload: any) => {\n            return {}\n          },\n          payloadTransform: (payload: any) => {\n            return payload\n          },\n          nestedFieldsToProcess: {\n            recordings: {\n              eventTransformType: 'roomSessionRecording',\n              processInstancePayload: (payload) => {\n                return {\n                  room_session_id: this.getStateProperty('roomSessionId'),\n                  recording: payload,\n                }\n              },\n            },\n          },\n        },\n      ],\n      [\n        [toLocalEvent<EmitterTransformsEvents>('video.playback.list')],\n        {\n          type: 'roomSessionPlaybackList',\n          instanceFactory: (_payload: any) => {\n            return {}\n          },\n          payloadTransform: (payload: any) => {\n            return payload\n          },\n          nestedFieldsToProcess: {\n            playbacks: {\n              eventTransformType: 'roomSessionPlayback',\n              processInstancePayload: (payload) => {\n                return {\n                  room_session_id: this.getStateProperty('roomSessionId'),\n                  playback: payload,\n                }\n              },\n            },\n          },\n        },\n      ],\n      [\n        'video.room.updated',\n        {\n          type: 'roomSession',\n          instanceFactory: () => {\n            return this\n          },\n          payloadTransform: (payload: VideoRoomUpdatedEventParams) => {\n            return toExternalJSON({\n              ...payload.room_session,\n              room_session_id: payload.room_session.id,\n            })\n          },\n          getInstanceEventNamespace: (payload: VideoRoomUpdatedEventParams) => {\n            return payload.room_session.id\n          },\n          getInstanceEventChannel: (payload: VideoRoomUpdatedEventParams) => {\n            return payload.room_session.event_channel\n          },\n        },\n      ],\n      [\n        'video.layout.changed',\n        {\n          type: 'roomSessionLayout',\n          instanceFactory: () => {\n            // TODO: Implement a Layout object when we have a better payload\n            // from the backend\n            return {}\n          },\n          payloadTransform: (payload: VideoLayoutChangedEventParams) => {\n            return toExternalJSON(payload.layout)\n          },\n        },\n      ],\n      [\n        [\n          'video.member.joined',\n          'video.member.left',\n          'video.member.talking',\n          'video.member.talking.start',\n          'video.member.talking.started',\n          'video.member.talking.stop',\n          'video.member.talking.ended',\n          'video.member.updated',\n          ...INTERNAL_MEMBER_UPDATED_EVENTS,\n        ],\n        {\n          type: 'roomSessionMember',\n          instanceFactory: (_payload: VideoMemberEventParams) => {\n            return createRoomSessionMemberObject({\n              store: this.store,\n              // TODO: the emitter is now typed so types\n              // don't match but internally it doesn't\n              // matter that much.\n              // @ts-expect-error\n              emitter: this.options.emitter,\n            })\n          },\n          payloadTransform: (payload: VideoMemberEventParams) => {\n            return toExternalJSON({\n              ...payload.member,\n              /**\n               * The server is sending the member id as `id`\n               * but internally (i.e in CustomMethods) we\n               * reference it as `memberId`. This is needed\n               * because sometimes we have to deal with\n               * multiple ids at once and having them\n               * properly prefixed makes it easier to read.\n               */\n              member_id: payload.member.id,\n            })\n          },\n        },\n      ],\n      [\n        [\n          toLocalEvent<EmitterTransformsEvents>('video.recording.start'),\n          'video.recording.started',\n          'video.recording.updated',\n          'video.recording.ended',\n        ],\n        {\n          type: 'roomSessionRecording',\n          instanceFactory: (_payload: any) => {\n            return Rooms.createRoomSessionRecordingObject({\n              store: this.store,\n              // @ts-expect-error\n              emitter: this.emitter,\n            })\n          },\n          payloadTransform: (payload: any) => {\n            return toExternalJSON({\n              ...payload.recording,\n              room_session_id: payload.room_session_id,\n            })\n          },\n        },\n      ],\n      [\n        [\n          toLocalEvent<EmitterTransformsEvents>('video.playback.start'),\n          'video.playback.started',\n          'video.playback.updated',\n          'video.playback.ended',\n        ],\n        {\n          type: 'roomSessionPlayback',\n          instanceFactory: (_payload: any) => {\n            return Rooms.createRoomSessionPlaybackObject({\n              store: this.store,\n              // @ts-expect-error\n              emitter: this.emitter,\n            })\n          },\n          payloadTransform: (payload: VideoPlaybackEventParams) => {\n            return toExternalJSON({\n              ...payload.playback,\n              room_session_id: payload.room_session_id,\n            })\n          },\n        },\n      ],\n      [\n        ['video.room.audience_count', 'video.room.audienceCount'],\n        {\n          type: 'roomSessionAudienceCount',\n          instanceFactory: (_payload: VideoRoomAudienceCountEventParams) => {\n            return {}\n          },\n          payloadTransform: (payload: VideoRoomAudienceCountEventParams) => {\n            return toExternalJSON(payload)\n          },\n        },\n      ],\n      [\n        [toLocalEvent<EmitterTransformsEvents>('video.stream.list')],\n        {\n          type: 'roomSessionStreamList',\n          instanceFactory: (_payload: any) => {\n            return {}\n          },\n          payloadTransform: (payload: any) => {\n            return payload\n          },\n          nestedFieldsToProcess: {\n            streams: {\n              eventTransformType: 'roomSessionStream',\n              processInstancePayload: (payload) => {\n                return {\n                  room_session_id: this.getStateProperty('roomSessionId'),\n                  stream: payload,\n                }\n              },\n            },\n          },\n        },\n      ],\n      [\n        [\n          toLocalEvent<EmitterTransformsEvents>('video.stream.start'),\n          'video.stream.started',\n          'video.stream.ended',\n        ],\n        {\n          type: 'roomSessionStream',\n          instanceFactory: (_payload: any) => {\n            return Rooms.createRoomSessionStreamObject({\n              store: this.store,\n              // @ts-expect-error\n              emitter: this.emitter,\n            })\n          },\n          payloadTransform: (payload: any) => {\n            return toExternalJSON({\n              ...payload.stream,\n              room_session_id: payload.room_session_id,\n            })\n          },\n        },\n      ],\n    ])\n  }\n}\n\nexport const RoomSessionAPI = extendComponent<\n  RoomSessionConsumer,\n  VideoRoomSessionMethods\n>(RoomSessionConsumer, {\n  videoMute: Rooms.videoMuteMember,\n  videoUnmute: Rooms.videoUnmuteMember,\n  getMembers: Rooms.getMembers,\n  audioMute: Rooms.audioMuteMember,\n  audioUnmute: Rooms.audioUnmuteMember,\n  deaf: Rooms.deafMember,\n  undeaf: Rooms.undeafMember,\n  setInputVolume: Rooms.setInputVolumeMember,\n  setOutputVolume: Rooms.setOutputVolumeMember,\n  setMicrophoneVolume: Rooms.setInputVolumeMember,\n  setSpeakerVolume: Rooms.setOutputVolumeMember,\n  setInputSensitivity: Rooms.setInputSensitivityMember,\n  removeMember: Rooms.removeMember,\n  removeAllMembers: Rooms.removeAllMembers,\n  setHideVideoMuted: Rooms.setHideVideoMuted,\n  getLayouts: Rooms.getLayouts,\n  setLayout: Rooms.setLayout,\n  setPositions: Rooms.setPositions,\n  setMemberPosition: Rooms.setMemberPosition,\n  getRecordings: Rooms.getRecordings,\n  startRecording: Rooms.startRecording,\n  getPlaybacks: Rooms.getPlaybacks,\n  play: Rooms.play,\n  getMeta: Rooms.getMeta,\n  setMeta: Rooms.setMeta,\n  updateMeta: Rooms.updateMeta,\n  deleteMeta: Rooms.deleteMeta,\n  getMemberMeta: Rooms.getMemberMeta,\n  setMemberMeta: Rooms.setMemberMeta,\n  updateMemberMeta: Rooms.updateMemberMeta,\n  deleteMemberMeta: Rooms.deleteMemberMeta,\n  promote: Rooms.promote,\n  demote: Rooms.demote,\n  getStreams: Rooms.getStreams,\n  startStream: Rooms.startStream,\n})\n\nexport const createRoomSessionObject = (\n  params: BaseComponentOptions<EmitterTransformsEvents>\n): RoomSession => {\n  const roomSession = connect<\n    RealTimeRoomApiEvents,\n    RoomSessionConsumer,\n    RoomSession\n  >({\n    store: params.store,\n    Component: RoomSessionAPI,\n    componentListeners: {\n      errors: 'onError',\n      responses: 'onSuccess',\n    },\n  })(params)\n\n  return roomSession\n}\n", "import {\n  connect,\n  BaseComponent,\n  BaseComponentOptions,\n  extendComponent,\n  Rooms,\n  VideoMemberContract,\n  VideoMemberMethods,\n  EntityUpdated,\n} from '@signalwire/core'\n\n/**\n * Represents a member of a room session. You receive instances of this type by\n * listening to room events, for example on a {@link RoomSession} object.\n *\n * > \u2139\uFE0F State of RoomSessionMember objects\n * >\n * > The state of RoomSessionMember objects, for example `member.visible`, is\n * > immutable. When you receive instances of RoomSessionMember from event\n * > listeners, the state of the member always refers to that specific point in\n * > time and remains fixed for the whole lifetime of the object.\n */\nexport interface RoomSessionMember extends VideoMemberContract {}\nexport type RoomSessionMemberUpdated = EntityUpdated<RoomSessionMember>\n\n// TODO: Extend from a variant of `BaseComponent` that\n// doesn't expose EventEmitter methods\nclass RoomSessionMemberComponent extends BaseComponent<{}> {\n  async remove() {\n    await this.execute({\n      method: 'video.member.remove',\n      params: {\n        room_session_id: this.getStateProperty('roomSessionId'),\n        member_id: this.getStateProperty('memberId'),\n      },\n    })\n  }\n}\n\nconst RoomSessionMemberAPI = extendComponent<\n  RoomSessionMemberComponent,\n  // `remove` is defined by `RoomSessionMemberComponent`\n  Omit<VideoMemberMethods, 'remove'>\n>(RoomSessionMemberComponent, {\n  audioMute: Rooms.audioMuteMember,\n  audioUnmute: Rooms.audioUnmuteMember,\n  videoMute: Rooms.videoMuteMember,\n  videoUnmute: Rooms.videoUnmuteMember,\n  setDeaf: Rooms.setDeaf,\n  setMicrophoneVolume: Rooms.setInputVolumeMember,\n  setInputVolume: Rooms.setInputVolumeMember,\n  setSpeakerVolume: Rooms.setOutputVolumeMember,\n  setOutputVolume: Rooms.setOutputVolumeMember,\n  setInputSensitivity: Rooms.setInputSensitivityMember,\n})\n\nexport const createRoomSessionMemberObject = (\n  params: BaseComponentOptions<{}>\n): RoomSessionMember => {\n  const member = connect<{}, RoomSessionMemberComponent, RoomSessionMember>({\n    store: params.store,\n    Component: RoomSessionMemberAPI,\n    componentListeners: {\n      errors: 'onError',\n      responses: 'onSuccess',\n    },\n  })(params)\n\n  return member\n}\n", "import {\n  sagaEffects,\n  SagaIterator,\n  SDKWorker,\n  MemberPosition,\n  findNamespaceInPayload,\n} from '@signalwire/core'\n\nexport const memberPositionWorker: SDKWorker<any> =\n  function* memberPositionWorker(options): SagaIterator {\n    const { instance, channels } = options\n    const { swEventChannel } = channels\n    const action = yield sagaEffects.take(swEventChannel, (action: any) => {\n      const istargetEvent = action.type === 'video.room.subscribed'\n\n      return (\n        istargetEvent &&\n        findNamespaceInPayload(action) === instance._eventsNamespace\n      )\n    })\n\n    yield sagaEffects.fork(MemberPosition.memberPositionWorker, {\n      ...options,\n      initialState: action.payload,\n    })\n  }\n", "/**\n * Note: This file will eventually replace\n * packages/realtime-api/src/Client.ts\n */\n\nimport {\n  BaseClient as CoreBaseClient,\n  ClientContract,\n  ClientEvents,\n} from '@signalwire/core'\n\nexport interface RealtimeClient\n  extends ClientContract<RealtimeClient, ClientEvents> {\n  /**\n   * Connects this client to the SignalWire network.\n   *\n   * As a general best practice, it is suggested to connect the event listeners\n   * *before* connecting the client, so that no events are lost.\n   *\n   * @returns Upon connection, asynchronously returns an instance of this same\n   * object.\n   *\n   * @example\n   * ```typescript\n   * const client = await createClient({project, token})\n   * client.video.on('room.started', async (roomSession) => { })  // connect events\n   * await client.connect()\n   * ```\n   */\n  connect(): Promise<RealtimeClient>\n\n  /**\n   * Disconnects this client from the SignalWire network.\n   */\n  disconnect(): void\n}\n\nexport class Client extends CoreBaseClient<ClientEvents> {}\n", "import { RealtimeClient } from './Client'\n\nexport const clientConnect = (client: RealtimeClient) => {\n  /**\n   * We swallow the (possible) error here to avoid polluting\n   * the stdout. The error itself won't be swallowed from\n   * the user (it will be handled by our `rootSaga`) and we\n   * can extend that behavior by adding the following\n   * listener:\n   * client.on('session.auth_error', () => { ... })\n   */\n  return client.connect().catch(() => {})\n}\n", "import { getLogger, UserOptions } from '@signalwire/core'\nimport { getCredentials } from '../utils/internals'\nimport { clientProxyFactory } from './clientProxyFactory'\nimport { getClient, ClientConfig, ClientCache } from './getClient'\n\ninterface SetupClientOptions {\n  project?: string\n  token?: string\n  logLevel?: UserOptions['logLevel']\n  cache?: ClientCache\n}\n\nexport const setupClient = (userOptions?: SetupClientOptions): ClientConfig => {\n  const credentials = getCredentials({\n    token: userOptions?.token,\n    project: userOptions?.project,\n  })\n  const { client, store, emitter } = getClient({\n    ...userOptions,\n    ...credentials,\n  })\n\n  client.on('session.auth_error', () => {\n    getLogger().error(\"Wrong credentials: couldn't connect the client.\")\n\n    // TODO: we can execute the future `onConnectError` from here.\n  })\n\n  const proxiedClient = clientProxyFactory(client)\n\n  return {\n    client: proxiedClient,\n    store,\n    emitter,\n  }\n}\n", "import { configureStore, getEventEmitter, UserOptions } from '@signalwire/core'\nimport { getConfig } from '../configure'\nimport { Session } from '../Session'\n\nexport const setupInternals = (userOptions: {\n  project: string\n  token: string\n  logLevel?: UserOptions['logLevel']\n}) => {\n  /**\n   * The emitter will be used across the entire stack so no\n   * need to type it here. Typings will be provided by each\n   * constructor.\n   */\n  const emitter = getEventEmitter<any>()\n\n  const baseOptions = {\n    ...userOptions,\n    emitter,\n  }\n\n  const store = configureStore({\n    userOptions: baseOptions,\n    SessionConstructor: Session,\n  })\n\n  return { store, emitter }\n}\n\nconst getToken = (userToken?: string) => {\n  const globalConfig = getConfig()\n  const token = userToken || globalConfig.token || process.env.SW_TOKEN\n\n  if (!token) {\n    // TODO: Add error message\n    throw new Error('Missing `token`')\n  }\n\n  return token\n}\n\nconst getProject = (userProject?: string) => {\n  const globalConfig = getConfig()\n  const project = userProject || globalConfig.project || process.env.SW_PROJECT\n\n  if (!project) {\n    // TODO: Add error message\n    throw new Error('Missing `project`')\n  }\n\n  return project\n}\n\ninterface GetCredentialsOptions {\n  token?: string\n  project?: string\n}\n\nexport const getCredentials = (options?: GetCredentialsOptions) => {\n  const project = getProject(options?.project)\n  const token = getToken(options?.token)\n\n  return { project, token }\n}\n", "export interface GlobalConfig {\n  token?: string\n  project?: string\n}\n\nlet GLOBAL_CONFIG: GlobalConfig = {}\n\nexport const getConfig = (): GlobalConfig => {\n  return GLOBAL_CONFIG\n}\n\n/** @ignore */\nexport interface ConfigOptions extends GlobalConfig {\n  /** @internal */\n  cache?: GlobalConfig\n}\n\n/** @internal */\nexport const config = ({\n  cache = GLOBAL_CONFIG,\n  ...options\n}: ConfigOptions) => {\n  if (cache) {\n    GLOBAL_CONFIG = cache\n  }\n\n  Object.entries(options).forEach(([key, value]) => {\n    // TODO: filter out properties\n    // @ts-expect-error\n    GLOBAL_CONFIG[key] = value\n  })\n}\n", "import { BaseSession } from '@signalwire/core'\nimport WebSocket from 'ws'\n\nexport class Session extends BaseSession {\n  public WebSocketConstructor = WebSocket\n  public agent = process.env.SDK_PKG_AGENT!\n}\n", "import { RealtimeClient } from './Client'\nimport { clientConnect as baseClientConnect } from './clientConnect'\n\ninterface ClientInterceptors {\n  connect?: (client: RealtimeClient) => Promise<void | RealtimeClient>\n}\n\nconst defaultInterceptors: ClientInterceptors = {\n  connect: baseClientConnect,\n}\n\nexport const clientProxyFactory = (\n  client: RealtimeClient,\n  interceptors: ClientInterceptors = defaultInterceptors\n) => {\n  const clientConnect = interceptors.connect || baseClientConnect\n\n  // Client interceptors\n  const clientOn: RealtimeClient['on'] = (...args) => {\n    clientConnect(client)\n\n    return client.on(...args)\n  }\n  const clientOnce: RealtimeClient['once'] = (...args) => {\n    clientConnect(client)\n\n    return client.once(...args)\n  }\n\n  return new Proxy<RealtimeClient>(client, {\n    get(target: RealtimeClient, prop: keyof RealtimeClient, receiver: any) {\n      if (prop === 'on') {\n        return clientOn\n      } else if (prop === 'once') {\n        return clientOnce\n      }\n\n      return Reflect.get(target, prop, receiver)\n    },\n  })\n}\n", "import {\n  ClientEvents,\n  configureStore,\n  connect,\n  EventEmitter,\n  UserOptions,\n} from '@signalwire/core'\nimport { setupInternals } from '../utils/internals'\nimport { Client, RealtimeClient } from './Client'\n\nexport interface ClientConfig {\n  client: RealtimeClient\n  store: ReturnType<typeof configureStore>\n  emitter: EventEmitter<any>\n}\n\nexport type ClientCache = Map<string, ClientConfig>\n\nconst CLIENTS_MAP: ClientCache = new Map()\n\n// const getClientKey = ({\n//   project,\n//   token,\n// }: {\n//   project: string\n//   token: string\n// }) => {\n//   return `${project}:${token}`\n// }\n\nconst createClient = (userOptions: {\n  project: string\n  token: string\n  logLevel?: UserOptions['logLevel']\n  store: ReturnType<typeof configureStore>\n  emitter: EventEmitter\n}) => {\n  const client = connect<ClientEvents, Client, RealtimeClient>({\n    store: userOptions.store,\n    Component: Client,\n    componentListeners: {\n      errors: 'onError',\n      responses: 'onSuccess',\n    },\n  })(userOptions)\n\n  return client\n}\n\nexport const getClient = ({\n  cache = CLIENTS_MAP,\n  ...userOptions\n}: {\n  project: string\n  token: string\n  logLevel?: UserOptions['logLevel']\n  cache?: ClientCache\n}): ClientConfig => {\n  // const clientKey = getClientKey({\n  //   project: userOptions.project,\n  //   token: userOptions.token,\n  // })\n\n  // if (cache.has(clientKey)) {\n  //   // @ts-expect-error\n  //   return cache.get(clientKey)\n  // } else {\n  const { emitter, store } = setupInternals(userOptions)\n  const client = createClient({\n    ...userOptions,\n    store,\n    emitter,\n  })\n  const config: ClientConfig = {\n    client,\n    store,\n    emitter,\n  }\n  // cache.set(clientKey, config)\n  return config\n  // }\n}\n", "import type { UserOptions } from '@signalwire/core'\nimport type { RealTimeVideoApiEvents } from '../types'\nimport { setupClient, clientConnect } from '../client/index'\nimport { createVideoObject, Video } from './Video'\n\n/**\n * List of events for {@link Video.Client}.\n */\nexport interface VideoClientApiEvents extends RealTimeVideoApiEvents {}\n\nexport interface VideoApiFullState extends VideoClient {}\n\ninterface VideoClient extends Video {\n  new (opts: VideoClientOptions): this\n}\n\nexport interface VideoClientOptions\n  extends Omit<UserOptions, 'host' | '_onRefreshToken' | 'token'> {\n  token?: string\n}\n\n/**\n * You can use instances of this class to subscribe to video events. Please see\n * {@link VideoClientApiEvents} for the full list of events you can subscribe\n * to.\n *\n * @param options - {@link VideoClientOptions}\n *\n * @example\n *\n * ```javascript\n * const video = new Video.Client({\n *   project: '<project-id>',\n *   token: '<project-token>'\n * })\n *\n * video.on('room.started', async (roomSession) => {\n *   console.log(\"Room started\")\n * });\n *\n * video.on('room.ended', async (roomSession) => {\n *   console.log(\"Room ended\")\n * });\n * ```\n */\nconst VideoClient = function (options?: VideoClientOptions) {\n  const { client, store, emitter } = setupClient(options)\n\n  const video = createVideoObject({\n    store,\n    emitter,\n  })\n\n  const videoSubscribe: Video['subscribe'] = async () => {\n    await clientConnect(client)\n\n    return video.subscribe()\n  }\n\n  const interceptors = {\n    // keep subscribe in here to await clientConnect\n    subscribe: videoSubscribe,\n    _session: client,\n    disconnect: () => client.disconnect(),\n  } as const\n\n  return new Proxy<Omit<VideoClient, 'new'>>(video, {\n    get(target: VideoClient, prop: keyof VideoClient, receiver: any) {\n      if (prop in interceptors) {\n        // @ts-expect-error\n        return interceptors[prop]\n      }\n\n      // Always connect the underlying client if the user call a function on the Proxy\n      if (typeof target[prop] === 'function') {\n        clientConnect(client)\n      }\n\n      return Reflect.get(target, prop, receiver)\n    },\n  })\n  // For consistency with other constructors we'll make TS force the use of `new`\n} as unknown as { new (options?: VideoClientOptions): VideoClient }\n\nexport { VideoClient as Client }\n", "import {\n  ClientEvents,\n  configureStore,\n  connect,\n  getEventEmitter,\n  UserOptions,\n  InternalUserOptions,\n} from '@signalwire/core'\nimport { Client, RealtimeClient } from './Client'\nimport { Session } from './Session'\n\n/** @internal */\nexport interface CreateClientOptions extends UserOptions {}\nexport type { RealtimeClient, ClientEvents }\n\n/**\n * Creates a real-time Client.\n * @param userOptions\n * @param userOptions.project SignalWire project id, e.g. `a10d8a9f-2166-4e82-56ff-118bc3a4840f`\n * @param userOptions.token SignalWire project token, e.g. `PT9e5660c101cd140a1c93a0197640a369cf5f16975a0079c9`\n * @param userOptions.logLevel logging level\n * @returns an instance of a real-time Client.\n *\n * @example\n * ```typescript\n * const client = await createClient({\n *   project: '<project-id>',\n *   token: '<project-token>'\n * })\n * ```\n *\n * @deprecated You no longer need to create the client\n * manually. You can use the product constructors, like\n * {@link Video.Client}, to access the same functionality.\n */\nexport const createClient: (userOptions: {\n  project?: string\n  token: string\n  logLevel?: 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'silent'\n}) => Promise<RealtimeClient> =\n  // Note: types are inlined for clarity of documentation\n  async (userOptions) => {\n    const baseUserOptions: InternalUserOptions = {\n      ...userOptions,\n      emitter: getEventEmitter<ClientEvents>(),\n    }\n    const store = configureStore({\n      userOptions: baseUserOptions,\n      SessionConstructor: Session,\n    })\n\n    const client = connect<ClientEvents, Client, RealtimeClient>({\n      store,\n      Component: Client,\n      componentListeners: {\n        errors: 'onError',\n        responses: 'onSuccess',\n      },\n      sessionListeners: {\n        authStatus: 'onAuth',\n      },\n    })(baseUserOptions)\n\n    return client\n  }\n", "import {\n  BaseClient,\n  EventsPrefix,\n  SessionState,\n  ClientContract,\n  ClientEvents,\n} from '@signalwire/core'\nimport { createVideoObject, Video } from './video/Video'\n\n/**\n * A real-time Client.\n *\n * To construct an instance of this class, please use {@link createClient}.\n *\n * Example usage:\n * ```typescript\n * import {createClient} from '@signalwire/realtime-api'\n *\n * // Obtain a client:\n * const client = await createClient({ project, token })\n *\n * // Listen on events:\n * client.video.on('room.started', async (room) => { })\n *\n * // Connect:\n * await client.connect()\n * ```\n * @deprecated It's no longer needed to create the client\n * manually. You can use the product constructors, like\n * Video.Client, to access the same functionality.\n */\nexport interface RealtimeClient\n  extends ClientContract<RealtimeClient, ClientEvents> {\n  /**\n   * Connects this client to the SignalWire network.\n   *\n   * As a general best practice, it is suggested to connect the event listeners\n   * *before* connecting the client, so that no events are lost.\n   *\n   * @returns Upon connection, asynchronously returns an instance of this same\n   * object.\n   *\n   * @example\n   * ```typescript\n   * const client = await createClient({project, token})\n   * client.video.on('room.started', async (roomSession) => { })  // connect events\n   * await client.connect()\n   * ```\n   */\n  connect(): Promise<RealtimeClient>\n\n  /**\n   * Disconnects this client from the SignalWire network.\n   */\n  disconnect(): void\n\n  /**\n   * Access the Video API Consumer\n   */\n  video: Video\n}\n\ntype ClientNamespaces = Video\n\nexport class Client extends BaseClient<ClientEvents> {\n  private _consumers: Map<EventsPrefix, ClientNamespaces> = new Map()\n\n  async onAuth(session: SessionState) {\n    try {\n      if (session.authStatus === 'authorized') {\n        this._consumers.forEach((consumer) => {\n          consumer.subscribe()\n        })\n      }\n    } catch (error) {\n      this.logger.error('Client subscription failed.')\n      this.disconnect()\n\n      /**\n       * TODO: This error is not being catched by us so it's\n       * gonna appear as `UnhandledPromiseRejectionWarning`.\n       * The reason we are re-throwing here is because if\n       * this happens something serious happened and the app\n       * won't work anymore since subscribes aren't working.\n       */\n      throw error\n    }\n  }\n\n  get video(): Video {\n    if (this._consumers.has('video')) {\n      return this._consumers.get('video')!\n    }\n    const video = createVideoObject({\n      store: this.store,\n      // Emitter is now typed but we share it across objects\n      // so types won't match\n      // @ts-expect-error\n      emitter: this.options.emitter,\n    })\n    this._consumers.set('video', video)\n    return video\n  }\n}\n", "export { ChatMember, ChatMessage } from '@signalwire/core'\nexport type {\n  ChatAction,\n  ChatChannel,\n  ChatChannelMessageEvent,\n  ChatChannelMessageEventParams,\n  ChatChannelState,\n  ChatEvent,\n  ChatGetMembersParams,\n  ChatGetMemberStateParams,\n  ChatGetMessagesParams,\n  ChatMemberContract,\n  ChatMemberEntity,\n  ChatMemberJoinedEvent,\n  ChatMemberJoinedEventParams,\n  ChatMemberLeftEvent,\n  ChatMemberLeftEventParams,\n  ChatMemberUpdatedEvent,\n  ChatMemberUpdatedEventParams,\n  ChatMessageContract,\n  ChatMessageEntity,\n  ChatSetMemberStateParams,\n  InternalChatMemberEntity,\n  InternalChatMessageEntity,\n  InternalPubSubMessageEntity,\n  MapToPubSubShape,\n  MessagingAction,\n  PaginationCursor,\n  PubSubAction,\n  PubSubChannel,\n  PubSubChannelMessageEvent,\n  PubSubChannelMessageEventParams,\n  PubSubEvent,\n  PubSubEventAction,\n  PubSubPublishParams,\n} from '@signalwire/core'\nexport { ChatClientApiEvents, Client } from './ChatClient'\nexport type { ChatClientOptions } from './ChatClient'\n", "import {\n  ChatContract,\n  ConsumerContract,\n  UserOptions,\n  Chat as ChatNamespace,\n} from '@signalwire/core'\nimport { clientConnect, setupClient, RealtimeClient } from '../client/index'\nimport type { RealTimeChatApiEventsHandlerMapping } from '../types/chat'\n\nexport interface ChatClientApiEvents\n  extends ChatNamespace.BaseChatApiEvents<RealTimeChatApiEventsHandlerMapping> {}\n\nexport interface ClientFullState extends ChatClient {}\ninterface ChatClient\n  extends Omit<ChatContract, 'getAllowedChannels' | 'updateToken'>,\n    Omit<ConsumerContract<ChatClientApiEvents, ClientFullState>, 'subscribe'> {\n  new (opts: ChatClientOptions): this\n\n  /** @internal */\n  _session: RealtimeClient\n}\nexport interface ChatClientOptions\n  extends Omit<UserOptions, 'host' | '_onRefreshToken' | 'token'> {\n  token?: string\n}\n\ntype ClientMethods = Exclude<keyof ChatClient, '_session'>\nconst INTERCEPTED_METHODS: ClientMethods[] = [\n  'subscribe',\n  'publish',\n  'getMessages',\n  'getMembers',\n  'getMemberState',\n  'setMemberState',\n]\nconst UNSUPPORTED_METHODS = ['getAllowedChannels', 'updateToken']\n\n/**\n * You can use instances of this class to control the chat and subscribe to its\n * events. Please see {@link ChatClientApiEvents} for the full list of events\n * you can subscribe to.\n *\n * @param options - {@link ChatClientOptions}\n *\n * @returns - {@link ChatClient}\n *\n * @example\n *\n * ```javascript\n * const chatClient = new Chat.Client({\n *   project: '<project-id>',\n *   token: '<api-token>'\n * })\n *\n * await chatClient.subscribe([ 'mychannel1', 'mychannel2' ])\n *\n * chatClient.on('message', (message) => {\n *   console.log(\"Received\", message.content,\n *               \"on\", message.channel,\n *               \"at\", message.publishedAt)\n * })\n *\n * await chatClient.publish({\n *   channel: 'mychannel1',\n *   content: 'hello world'\n * })\n * ```\n */\nconst ChatClient = function (options?: ChatClientOptions) {\n  const { client, store, emitter } = setupClient(options)\n  const chat = ChatNamespace.createBaseChatObject<ChatClient>({\n    store,\n    emitter,\n  })\n\n  const createInterceptor = <K extends ClientMethods>(prop: K) => {\n    return async (...params: Parameters<ChatClient[K]>) => {\n      await clientConnect(client)\n\n      // @ts-expect-error\n      return chat[prop](...params)\n    }\n  }\n\n  const interceptors = {\n    _session: client,\n    disconnect: () => client.disconnect(),\n  } as const\n\n  return new Proxy<ChatClient>(chat, {\n    get(target: ChatClient, prop: keyof ChatClient, receiver: any) {\n      if (prop in interceptors) {\n        // @ts-expect-error\n        return interceptors[prop]\n      }\n\n      // FIXME: types and _session check\n      if (prop !== '_session' && INTERCEPTED_METHODS.includes(prop)) {\n        return createInterceptor(prop)\n      } else if (UNSUPPORTED_METHODS.includes(prop)) {\n        return undefined\n      }\n\n      // Always connect the underlying client if the user call a function on the Proxy\n      if (typeof target[prop] === 'function') {\n        clientConnect(client)\n      }\n\n      return Reflect.get(target, prop, receiver)\n    },\n  })\n  // For consistency with other constructors we'll make TS force the use of `new`\n} as unknown as { new (options?: ChatClientOptions): ChatClient }\n\nexport { ChatClient as Client }\n", "export { PubSubMessage } from '@signalwire/core'\nexport { Client } from './PubSubClient'\nexport type { PubSubMessageContract } from '@signalwire/core'\nexport type { PubSubClientApiEvents } from './PubSubClient'\n", "import {\n  ConsumerContract,\n  UserOptions,\n  PubSub as PubSubNamespace,\n  PubSubContract,\n} from '@signalwire/core'\nimport { clientConnect, setupClient, RealtimeClient } from '../client/index'\nimport type { RealTimePubSubApiEventsHandlerMapping } from '../types/pubSub'\n\nexport interface PubSubClientApiEvents\n  extends PubSubNamespace.BasePubSubApiEvents<RealTimePubSubApiEventsHandlerMapping> {}\n\nexport interface ClientFullState extends PubSubClient {}\ninterface PubSubClient\n  extends Omit<PubSubContract, 'getAllowedChannels' | 'updateToken'>,\n    Omit<\n      ConsumerContract<PubSubClientApiEvents, ClientFullState>,\n      'subscribe'\n    > {\n  new (opts: PubSubClientOptions): this\n\n  /** @internal */\n  _session: RealtimeClient\n}\n\ninterface PubSubClientOptions\n  extends Omit<UserOptions, 'host' | '_onRefreshToken' | 'token'> {\n  token?: string\n}\n\ntype ClientMethods = Exclude<keyof PubSubClient, '_session'>\nconst INTERCEPTED_METHODS: ClientMethods[] = ['subscribe', 'publish']\nconst UNSUPPORTED_METHODS = ['getAllowedChannels', 'updateToken']\n\n/**\n * Creates a new PubSub client.\n *\n * @param options - {@link PubSubClientOptions}\n *\n * @example\n *\n * ```js\n * import { PubSub } from '@signalwire/realtime-api'\n *\n * const pubSubClient = new PubSub.Client({\n *   project: '<project-id>',\n *   token: '<api-token>'\n * })\n * ```\n */\nconst PubSubClient = function (options?: PubSubClientOptions) {\n  const { client, store, emitter } = setupClient(options)\n  const pubSub = PubSubNamespace.createBasePubSubObject<PubSubClient>({\n    store,\n    emitter,\n  })\n\n  const createInterceptor = <K extends ClientMethods>(prop: K) => {\n    return async (...params: Parameters<PubSubClient[K]>) => {\n      await clientConnect(client)\n\n      // @ts-expect-error\n      return pubSub[prop](...params)\n    }\n  }\n\n  const interceptors = {\n    _session: client,\n    disconnect: () => client.disconnect(),\n  } as const\n\n  return new Proxy<PubSubClient>(pubSub, {\n    get(target: PubSubClient, prop: keyof PubSubClient, receiver: any) {\n      if (prop in interceptors) {\n        // @ts-expect-error\n        return interceptors[prop]\n      }\n\n      // FIXME: types and _session check\n      if (prop !== '_session' && INTERCEPTED_METHODS.includes(prop)) {\n        return createInterceptor(prop)\n      } else if (UNSUPPORTED_METHODS.includes(prop)) {\n        return undefined\n      }\n\n      // Always connect the underlying client if the user call a function on the Proxy\n      if (typeof target[prop] === 'function') {\n        clientConnect(client)\n      }\n\n      return Reflect.get(target, prop, receiver)\n    },\n  })\n  // For consistency with other constructors we'll make TS force the use of `new`\n} as unknown as { new (options?: PubSubClientOptions): PubSubClient }\n\nexport { PubSubClient as Client }\n", "import {\n  DisconnectableClientContract,\n  BaseComponentOptions,\n  BaseComponent,\n  ClientContextContract,\n} from '@signalwire/core'\nimport { connect } from '@signalwire/core'\nimport type { TaskClientApiEvents } from '../types'\nimport { RealtimeClient } from '../client/index'\nimport { taskWorker } from './workers'\n\nexport interface Task\n  extends DisconnectableClientContract<Task, TaskClientApiEvents>,\n    ClientContextContract {\n  /** @internal */\n  _session: RealtimeClient\n  /**\n   * Disconnects this client. The client will stop receiving events and you will\n   * need to create a new instance if you want to use it again.\n   *\n   * @example\n   *\n   * ```js\n   * client.disconnect()\n   * ```\n   */\n  disconnect(): void\n}\n\n/** @internal */\nclass TaskAPI extends BaseComponent<TaskClientApiEvents> {\n  constructor(options: BaseComponentOptions<TaskClientApiEvents>) {\n    super(options)\n\n    this.runWorker('taskWorker', {\n      worker: taskWorker,\n    })\n    this._attachListeners('')\n  }\n}\n\n/** @internal */\nexport const createTaskObject = (\n  params: BaseComponentOptions<TaskClientApiEvents>\n): Task => {\n  const task = connect<TaskClientApiEvents, TaskAPI, Task>({\n    store: params.store,\n    Component: TaskAPI,\n    componentListeners: {\n      errors: 'onError',\n      responses: 'onSuccess',\n    },\n  })(params)\n\n  return task\n}\n\nexport * from './TaskClient'\nexport * from './send'\nexport type { TaskReceivedEventName } from '@signalwire/core'\nexport type {\n  TaskClientApiEvents,\n  RealTimeTaskApiEventsHandlerMapping,\n} from '../types'\n", "import {\n  getLogger,\n  sagaEffects,\n  SagaIterator,\n  SDKWorker,\n  SDKActions,\n} from '@signalwire/core'\nimport type { Task } from './Task'\n\nexport const taskWorker: SDKWorker<Task> = function* (options): SagaIterator {\n  getLogger().trace('taskWorker started')\n  const { channels } = options\n  const { swEventChannel, pubSubChannel } = channels\n\n  while (true) {\n    const action = yield sagaEffects.take(\n      swEventChannel,\n      (action: SDKActions) => {\n        return action.type === 'queuing.relay.tasks'\n      }\n    )\n\n    yield sagaEffects.put(pubSubChannel, {\n      type: 'task.received',\n      payload: action.payload.message,\n    })\n  }\n\n  getLogger().trace('taskWorker ended')\n}\n", "import { RealtimeClient, clientConnect } from '../client/index'\nimport type { ExecuteParams } from '@signalwire/core'\n\nexport const clientContextInterceptorsFactory = (client: RealtimeClient) => {\n  return {\n    async addContexts(contexts: string[]) {\n      await clientConnect(client)\n      const executeParams: ExecuteParams = {\n        method: 'signalwire.receive',\n        params: {\n          contexts,\n        },\n      }\n\n      // @ts-expect-error\n      return client.execute(executeParams)\n    },\n    async removeContexts(contexts: string[]) {\n      await clientConnect(client)\n      const executeParams: ExecuteParams = {\n        method: 'signalwire.unreceive',\n        params: {\n          contexts,\n        },\n      }\n\n      // @ts-expect-error\n      return client.execute(executeParams)\n    },\n  }\n}\n", "import type { UserOptions } from '@signalwire/core'\nimport { setupClient, clientConnect } from '../client/index'\nimport type { Task } from './Task'\nimport { createTaskObject } from './Task'\nimport { clientContextInterceptorsFactory } from '../common/clientContext'\n\ninterface TaskClient extends Task {\n  new (opts: TaskClientOptions): this\n}\n\nexport interface TaskClientOptions\n  extends Omit<UserOptions, '_onRefreshToken'> {\n  contexts: string[]\n}\n\n/**\n * Creates a new Task client.\n *\n * @param options - {@link TaskClientOptions}\n *\n * @example\n *\n * ```js\n * import { Task } from '@signalwire/realtime-api'\n *\n * const taskClient = new Task.Client({\n *   project: '<project-id>',\n *   token: '<api-token>',\n *   contexts: ['<context-name>'],\n * })\n * ```\n */\nconst TaskClient = function (options?: TaskClientOptions) {\n  const { client, store, emitter } = setupClient(options)\n\n  const task = createTaskObject({\n    store,\n    emitter,\n  })\n\n  const disconnect = () => client.disconnect()\n\n  const interceptors = {\n    ...clientContextInterceptorsFactory(client),\n    _session: client,\n    disconnect,\n  } as const\n\n  return new Proxy<Omit<TaskClient, 'new'>>(task, {\n    get(target: TaskClient, prop: keyof TaskClient, receiver: any) {\n      if (prop in interceptors) {\n        // @ts-expect-error\n        return interceptors[prop]\n      }\n\n      // Always connect the underlying client if the user call a function on the Proxy\n      if (typeof target[prop] === 'function') {\n        clientConnect(client)\n      }\n\n      return Reflect.get(target, prop, receiver)\n    },\n  })\n  // For consistency with other constructors we'll make TS force the use of `new`\n} as unknown as { new (options?: TaskClientOptions): TaskClient }\n\nexport { TaskClient as Client }\n", "import { request } from 'node:https'\n\nconst PATH = '/api/relay/rest/tasks'\nconst HOST = 'relay.signalwire.com'\n\n/** Parameters for {@link send} */\nexport interface TaskSendParams {\n  /** @ignore */\n  host?: string\n  /** SignalWire project id, e.g. `a10d8a9f-2166-4e82-56ff-118bc3a4840f` */\n  project: string\n  /** SignalWire project token, e.g. `PT9e5660c101cd140a1c93a0197640a369cf5f16975a0079c9` */\n  token: string\n  /** Context to send the task to */\n  context: string\n  /** Message to send */\n  message: Record<string, unknown>\n}\n\n/**\n * Send a job to your Task Client in a specific context.\n *\n * @param params\n * @returns\n *\n * @example\n *\n * > Send a task with a message to then make an outbound Call.\n *\n * ```js\n * const message = {\n *   'action': 'call',\n *   'from': '+18881112222'\n *   'to': '+18881113333'\n * }\n *\n * await Task.send({\n *   project: \"<project-id>\",\n *   token: \"<api-token>\",\n *   context: 'office',\n *   message: message,\n * })\n * ```\n *\n */\nexport const send = ({\n  host = HOST,\n  project,\n  token,\n  context,\n  message,\n}: TaskSendParams) => {\n  if (!project || !token) {\n    throw new Error('Invalid options: project and token are required!')\n  }\n\n  return new Promise<void>((resolve, reject) => {\n    try {\n      const Authorization = `Basic ${Buffer.from(\n        `${project}:${token}`\n      ).toString('base64')}`\n\n      const data = JSON.stringify({ context, message })\n      const options = {\n        host,\n        port: 443,\n        method: 'POST',\n        path: PATH,\n        headers: {\n          Authorization,\n          'Content-Type': 'application/json',\n          'Content-Length': data.length,\n        },\n      }\n      const req = request(options, ({ statusCode }) => {\n        statusCode === 204 ? resolve() : reject()\n      })\n\n      req.on('error', reject)\n\n      req.write(data)\n      req.end()\n    } catch (error) {\n      reject(error)\n    }\n  })\n}\n", "import {\n  DisconnectableClientContract,\n  BaseComponentOptions,\n  EventTransform,\n  toExternalJSON,\n  ClientContextContract,\n} from '@signalwire/core'\nimport { connect, BaseComponent } from '@signalwire/core'\nimport type { MessagingClientApiEvents } from '../types'\nimport { RealtimeClient } from '../client/index'\nimport { messagingWorker } from './workers'\nimport { MessageContract, Message } from './Message'\n\ninterface MessagingSendParams {\n  context?: string\n  from: string\n  to: string\n  body?: string\n  tags?: string[]\n  region?: string\n  media?: string[]\n}\n\ninterface InternalMessagingSendParams\n  extends Omit<MessagingSendParams, 'from' | 'to'> {\n  from_number: string\n  to_number: string\n}\n\nexport interface MessagingSendResult {\n  message: string\n  code: string\n  messageId: string\n}\n\ninterface MessagingSendError {\n  message: string\n  code: string\n  errors: Record<any, any>\n}\n\n/** @internal */\nexport interface Messaging\n  extends DisconnectableClientContract<Messaging, MessagingClientApiEvents>,\n    ClientContextContract {\n  /** @internal */\n  _session: RealtimeClient\n  /**\n   * Disconnects this client. The client will stop receiving events and you will\n   * need to create a new instance if you want to use it again.\n   *\n   * @example\n   *\n   * ```js\n   * client.disconnect()\n   * ```\n   */\n  disconnect(): void\n\n  /**\n   * Send an outbound SMS or MMS message.\n   *\n   * @param params - {@link MessagingSendParams}\n   *\n   * @returns - {@link MessagingSendResult}\n   *\n   * @example\n   *\n   * > Send a message.\n   *\n   * ```js\n   * try {\n   *   const sendResult = await client.send({\n   *     from: '+1xxx',\n   *     to: '+1yyy',\n   *     body: 'Hello World!'\n   *   })\n   *   console.log('Message ID: ', sendResult.messageId)\n   * } catch (e) {\n   *   console.error(e.message)\n   * }\n   * ```\n   */\n  send(params: MessagingSendParams): Promise<MessagingSendResult>\n}\n\n/** @internal */\nclass MessagingAPI extends BaseComponent<MessagingClientApiEvents> {\n  /** @internal */\n\n  constructor(options: BaseComponentOptions<MessagingClientApiEvents>) {\n    super(options)\n\n    this.runWorker('messagingWorker', {\n      worker: messagingWorker,\n    })\n    this._attachListeners('')\n  }\n\n  /** @internal */\n  protected getEmitterTransforms() {\n    return new Map<string | string[], EventTransform>([\n      [\n        [\n          'messaging.state',\n          'messaging.receive',\n          'message.updated',\n          'message.received',\n        ],\n        {\n          type: 'messagingMessage',\n          instanceFactory: (payload: any) => {\n            return new Message(payload)\n          },\n          payloadTransform: (payload: any): MessageContract => {\n            /** Building a MessageContract to conform with our Proxy API */\n            const {\n              message_id,\n              message_state,\n              from_number,\n              to_number,\n              tag,\n              ...rest\n            } = payload\n\n            return toExternalJSON<MessageContract>({\n              ...rest,\n              id: message_id,\n              state: message_state,\n              from: from_number,\n              to: to_number,\n            })\n          },\n        },\n      ],\n    ])\n  }\n\n  async send(params: MessagingSendParams): Promise<any> {\n    const { from = '', to = '', ...rest } = params\n    const sendParams: InternalMessagingSendParams = {\n      ...rest,\n      from_number: from,\n      to_number: to,\n    }\n\n    try {\n      const response: any = await this.execute({\n        method: 'messaging.send',\n        params: sendParams,\n      })\n\n      return toExternalJSON<MessagingSendResult>(response)\n    } catch (error) {\n      this.logger.error('Error sending message', error.jsonrpc)\n      throw error.jsonrpc as MessagingSendError\n    }\n  }\n}\n\n/** @internal */\nexport const createMessagingObject = (\n  params: BaseComponentOptions<MessagingClientApiEvents>\n): Messaging => {\n  const messaging = connect<MessagingClientApiEvents, MessagingAPI, Messaging>({\n    store: params.store,\n    Component: MessagingAPI,\n    componentListeners: {\n      errors: 'onError',\n      responses: 'onSuccess',\n    },\n  })(params)\n\n  return messaging\n}\n\nexport * from './MessagingClient'\nexport * from './Message'\nexport type { MessagingMessageState } from '@signalwire/core'\n", "import {\n  sagaEffects,\n  SagaIterator,\n  SDKWorker,\n  getLogger,\n  SDKActions,\n} from '@signalwire/core'\nimport type { Messaging } from './Messaging'\n\nexport const messagingWorker: SDKWorker<Messaging> = function* (\n  options\n): SagaIterator {\n  const { channels } = options\n  const { swEventChannel, pubSubChannel } = channels\n  while (true) {\n    const action: SDKActions = yield sagaEffects.take(\n      swEventChannel,\n      (action: any) => {\n        return action.type.startsWith('messaging.')\n      }\n    )\n    getLogger().debug('messagingWorker:', action)\n\n    /**\n     * Rename the wire events to be consistent with other SDK events.\n     * messaging.receive => message.received\n     * messaging.state => message.updated\n     */\n\n    switch (action.type) {\n      case 'messaging.receive': {\n        // yield sagaEffects.put(pubSubChannel, action)\n\n        yield sagaEffects.put(pubSubChannel, {\n          type: 'message.received',\n          payload: action.payload,\n        })\n        break\n      }\n      case 'messaging.state': {\n        // yield sagaEffects.put(pubSubChannel, action)\n\n        yield sagaEffects.put(pubSubChannel, {\n          type: 'message.updated',\n          payload: action.payload,\n        })\n        break\n      }\n\n      default: {\n        getLogger().warn('[messagingWorker] Unrecognized Action', action)\n        break\n      }\n    }\n  }\n}\n", "import { MessagingMessageState } from '@signalwire/core'\n\n/**\n * An object representing an SMS or MMS message.\n */\nexport interface MessageContract {\n  /** The unique identifier of the message. */\n  id: string\n  /** The current state of the message. */\n  state: MessagingMessageState\n  /** The context of the message. */\n  context: string\n  /** The phone number the message comes from. */\n  from: string\n  /** The destination number of the message. */\n  to: string\n  /** The direction of the message: `inbound` or `outbound`. */\n  direction: string\n  /** Array of strings with message tags. */\n  tags: string[]\n  /** Body of the message */\n  body: string\n  /** Array of URLs media. */\n  media: string[]\n  /** Number of segments of the message. */\n  segments: number\n  /** Reason why the message was not sent. This is present only in case of failure. */\n  reason?: string\n}\n\ninterface MessageOptions {\n  message_id: string\n  message_state: MessagingMessageState\n  context: string\n  from_number: string\n  to_number: string\n  direction: 'inbound' | 'outbound'\n  tags: string[]\n  body: string\n  media: string[]\n  segments: number\n  reason?: string\n}\n\n/** @internal */\nexport class Message implements MessageContract {\n  public id: string\n  public state: MessagingMessageState\n  public context: string\n  public from: string\n  public to: string\n  public body: string\n  public direction: 'inbound' | 'outbound'\n  public media: string[]\n  public segments: number\n  public tags: string[]\n  public reason?: string\n\n  constructor(options: MessageOptions) {\n    this.id = options.message_id\n    this.state = options.message_state\n    this.context = options.context\n    this.from = options.from_number\n    this.to = options.to_number\n    this.body = options.body\n    this.direction = options.direction\n    this.media = options.media || []\n    this.segments = options.segments\n    this.tags = options.tags || []\n    this.reason = options.reason\n  }\n}\n", "import type { UserOptions } from '@signalwire/core'\nimport { setupClient, clientConnect } from '../client/index'\nimport type { Messaging } from './Messaging'\nimport { createMessagingObject } from './Messaging'\nimport { clientContextInterceptorsFactory } from '../common/clientContext'\nexport type {\n  MessagingClientApiEvents,\n  RealTimeMessagingApiEventsHandlerMapping,\n} from '../types'\nexport type {\n  MessageReceivedEventName,\n  MessageUpdatedEventName,\n} from '@signalwire/core'\n\ninterface MessagingClient extends Messaging {\n  new (opts: MessagingClientOptions): this\n}\n\nexport interface MessagingClientOptions\n  extends Omit<UserOptions, '_onRefreshToken'> {}\n\n/**\n * You can use instances of this class to send or receive messages. Please see\n * {@link MessagingClientApiEvents} for the full list of events you can subscribe\n * to.\n *\n * @param params - {@link MessagingClientOptions}\n *\n * @example\n *\n * ```javascript\n * const client = new Messaging.Client({\n *   project: \"<project-id>\",\n *   token: \"<api-token>\",\n *   contexts: ['office']\n * })\n *\n * client.on('message.received', (message) => {\n *   console.log('message.received', message)\n * })\n *\n * await client.send({\n *   context: 'office',\n *   from: '+1xxx',\n *   to: '+1yyy',\n *   body: 'Hello World!'\n * })\n * ```\n */\nconst MessagingClient = function (options?: MessagingClientOptions) {\n  const { client, store, emitter } = setupClient(options)\n\n  const messaging = createMessagingObject({\n    store,\n    emitter,\n  })\n\n  client.once('session.connected', () => {\n    // @ts-expect-error\n    messaging.applyEmitterTransforms()\n  })\n\n  const send: Messaging['send'] = async (...args) => {\n    await clientConnect(client)\n\n    return messaging.send(...args)\n  }\n  const disconnect = () => client.disconnect()\n\n  const interceptors = {\n    ...clientContextInterceptorsFactory(client),\n    send,\n    _session: client,\n    disconnect,\n  } as const\n\n  return new Proxy<Omit<MessagingClient, 'new'>>(messaging, {\n    get(target: MessagingClient, prop: keyof MessagingClient, receiver: any) {\n      if (prop in interceptors) {\n        // @ts-expect-error\n        return interceptors[prop]\n      }\n\n      // Always connect the underlying client if the user call a function on the Proxy\n      if (typeof target[prop] === 'function') {\n        clientConnect(client)\n      }\n\n      return Reflect.get(target, prop, receiver)\n    },\n  })\n  // For consistency with other constructors we'll make TS force the use of `new`\n} as unknown as { new (options?: MessagingClientOptions): MessagingClient }\n\nexport { MessagingClient as Client }\n", "import {\n  connect,\n  BaseComponentOptions,\n  toExternalJSON,\n  ClientContextContract,\n} from '@signalwire/core'\nimport type {\n  DisconnectableClientContract,\n  EventTransform,\n  CallingCallReceiveEventParams,\n  VoiceDeviceBuilder,\n  VoiceCallDialPhoneMethodParams,\n  VoiceCallDialSipMethodParams,\n} from '@signalwire/core'\nimport { RealtimeClient } from '../client/index'\nimport { createCallObject, Call } from './Call'\nimport { voiceCallReceiveWorker } from './workers'\nimport { DeviceBuilder } from './DeviceBuilder'\nimport type { RealTimeCallApiEvents } from '../types'\nimport { AutoApplyTransformsConsumer } from '../AutoApplyTransformsConsumer'\n\nexport * from './VoiceClient'\nexport { Call } from './Call'\nexport type { RealTimeCallApiEvents }\nexport { DeviceBuilder }\nexport { Playlist } from './Playlist'\nexport type { CallPlayback } from './CallPlayback'\nexport type { CallPrompt } from './CallPrompt'\nexport type { CallRecording } from './CallRecording'\nexport type { CallTap } from './CallTap'\nexport type {\n  CallingCallDirection,\n  CallingCallState,\n  CallingCallWaitForState,\n  ClientEvents,\n  CollectDigitsConfig,\n  CollectSpeechConfig,\n  CreateVoicePlaylistParams,\n  NestedArray,\n  RingtoneName,\n  SipCodec,\n  SipHeader,\n  SpeechOrDigits,\n  TapDevice,\n  TapDeviceRTP,\n  TapDeviceWS,\n  TapDirection,\n  VoiceCallConnectMethodParams,\n  VoiceCallConnectPhoneMethodParams,\n  VoiceCallConnectSipMethodParams,\n  VoiceCallContract,\n  VoiceCallDetectContract,\n  VoiceCallDetectDigitParams,\n  VoiceCallDetectFaxParams,\n  VoiceCallDetectMachineParams,\n  VoiceCallDetectMethodParams,\n  VoiceCallDeviceParams,\n  VoiceCallDialPhoneMethodParams,\n  VoiceCallDialRegionParams,\n  VoiceCallDialSipMethodParams,\n  VoiceCallDisconnectReason,\n  VoiceCallPhoneParams,\n  VoiceCallPlayAudioMethodParams,\n  VoiceCallPlayAudioParams,\n  VoiceCallPlaybackContract,\n  VoiceCallPlayParams,\n  VoiceCallPlayRingtoneMethodParams,\n  VoiceCallPlayRingtoneParams,\n  VoiceCallPlaySilenceMethodParams,\n  VoiceCallPlaySilenceParams,\n  VoiceCallPlayTTSMethodParams,\n  VoiceCallPlayTTSParams,\n  VoiceCallPromptAudioMethodParams,\n  VoiceCallPromptContract,\n  VoiceCallPromptMethodParams,\n  VoiceCallPromptRingtoneMethodParams,\n  VoiceCallPromptTTSMethodParams,\n  VoiceCallRecordingContract,\n  VoiceCallRecordMethodParams,\n  VoiceCallSipParams,\n  VoiceCallTapAudioMethodParams,\n  VoiceCallTapContract,\n  VoiceCallTapMethodParams,\n  VoiceDeviceBuilder,\n  VoiceDialerParams,\n  VoicePlaylist,\n} from '@signalwire/core'\n\n/**\n * List of events for {@link Voice.Call}.\n */\nexport interface VoiceClientApiEvents extends RealTimeCallApiEvents {}\n\ntype EmitterTransformsEvents = 'calling.call.received'\n\nexport interface Voice\n  extends DisconnectableClientContract<Voice, VoiceClientApiEvents>,\n    ClientContextContract {\n  /** @internal */\n  _session: RealtimeClient\n\n  /**\n   * Disconnects this client. The client will stop receiving events and you will\n   * need to create a new instance if you want to use it again.\n   *\n   * @example\n   *\n   * ```js\n   * client.disconnect()\n   * ```\n   */\n  disconnect(): void\n\n  /**\n   * Makes an outbound Call and waits until it has been answered or hung up.\n   * This is an advanced method that lets you call multiple devices in parallel\n   * or series: for simpler use cases, see {@link dialPhone} and\n   * {@link dialSip}.\n   *\n   * With this method you can specify a configuration of devices to call in\n   * series and/or in parallel: as soon as one device answers the call, the\n   * returned promise is resolved. You specify a configuration through a\n   * {@link VoiceDeviceBuilder} object.\n   *\n   * @param dialer - {@link VoiceDeviceBuilder}\n   *\n   * @example Calls a phone number. If the number doesn't answer within 30\n   * seconds, calls two different SIP endpoints in parallel.\n   *\n   * ```js\n   * const devices = new Voice.DeviceBuilder()\n   *   .add(Voice.DeviceBuilder.Phone({ from: '+XXXXXX', to: '+YYYYYY', timeout: 30 }))\n   *   .add([\n   *     Voice.DeviceBuilder.Sip({ from: 'sip:aaa@bbb.cc', to: 'sip:xxx@yyy.zz' }),\n   *     Voice.DeviceBuilder.Sip({ from: 'sip:aaa@bbb.cc', to: 'sip:ppp@qqq.rr' })\n   *   ])\n   *\n   * try {\n   *   const call = await client.dial(devices)\n   *   console.log(\"Call answered\")\n   * } catch (e) {\n   *   console.log(\"Call not answered\")\n   * }\n   * ```\n   *\n   * @param dialer The Dialer specifying the devices to call.\n   *\n   * @returns A call object.\n   */\n  dial(dialer: VoiceDeviceBuilder): Promise<Call>\n  /**\n   * Makes an outbound call to a PSTN number.\n   *\n   * @param params - {@link VoiceCallDialPhoneMethodParams}\n   *\n   * @example\n   *\n   * ```js\n   * try {\n   *   const call = await client.dialPhone({\n   *     from: '+YYYYYYYYYY',\n   *     to: '+XXXXXXXXXX',\n   *     timeout: 30,\n   *   })\n   * } catch (e) {\n   *   console.log(\"Call not answered.\")\n   * }\n   * ```\n   *\n   * @returns A call object.\n   */\n  dialPhone(params: VoiceCallDialPhoneMethodParams): Promise<Call>\n  /**\n   * Makes an outbound call to a SIP endpoint.\n   *\n   * @param params - {@link VoiceCallDialSipMethodParams}\n   *\n   * @example\n   *\n   * ```js\n   * try {\n   *   const call = await client.dialPhone({\n   *     from: 'sip:xxx@yyy.zz',\n   *     to: 'sip:ppp@qqq.rr',\n   *     timeout: 30,\n   *   })\n   * } catch (e) {\n   *   console.log(\"Call not answered.\")\n   * }\n   * ```\n   *\n   * @returns A call object.\n   */\n  dialSip(params: VoiceCallDialSipMethodParams): Promise<Call>\n}\n\n/** @internal */\nclass VoiceAPI extends AutoApplyTransformsConsumer<VoiceClientApiEvents> {\n  /** @internal */\n  protected _eventsPrefix = 'calling' as const\n\n  constructor(options: BaseComponentOptions<VoiceClientApiEvents>) {\n    super(options)\n\n    this.runWorker('voiceCallReceiveWorker', {\n      worker: voiceCallReceiveWorker,\n    })\n\n    this._attachListeners('')\n  }\n\n  /** @internal */\n  protected getEmitterTransforms() {\n    return new Map<\n      EmitterTransformsEvents | EmitterTransformsEvents[],\n      EventTransform\n    >([\n      [\n        'calling.call.received',\n        {\n          mode: 'no-cache',\n          type: 'voiceCallReceived',\n          instanceFactory: (_payload: any) => {\n            return createCallObject({\n              store: this.store,\n              // @ts-expect-error\n              emitter: this.emitter,\n            })\n          },\n          payloadTransform: (payload: CallingCallReceiveEventParams) => {\n            return toExternalJSON(payload)\n          },\n        },\n      ],\n    ])\n  }\n\n  dialPhone({ region, ...params }: VoiceCallDialPhoneMethodParams) {\n    const devices = new DeviceBuilder().add(DeviceBuilder.Phone(params))\n    // dial is available through the VoiceClient Proxy\n    // @ts-expect-error\n    return this.dial({\n      region,\n      devices,\n    })\n  }\n\n  dialSip({ region, ...params }: VoiceCallDialSipMethodParams) {\n    const devices = new DeviceBuilder().add(DeviceBuilder.Sip(params))\n    // dial is available through the VoiceClient Proxy\n    // @ts-expect-error\n    return this.dial({\n      region,\n      devices,\n    })\n  }\n}\n\n/** @internal */\nexport const createVoiceObject = (\n  params: BaseComponentOptions<VoiceClientApiEvents>\n): Voice => {\n  const voice = connect<VoiceClientApiEvents, VoiceAPI, Voice>({\n    store: params.store,\n    Component: VoiceAPI,\n    componentListeners: {\n      errors: 'onError',\n      responses: 'onSuccess',\n    },\n  })(params)\n\n  return voice\n}\n", "import {\n  uuid,\n  BaseComponentOptions,\n  connect,\n  EmitterContract,\n  extendComponent,\n  VoiceCallMethods,\n  VoiceCallContract,\n  VoiceCallDisconnectReason,\n  VoicePlaylist,\n  VoiceCallPlayAudioMethodParams,\n  VoiceCallPlaySilenceMethodParams,\n  VoiceCallPlayRingtoneMethodParams,\n  VoiceCallPlayTTSMethodParams,\n  CallingCallRecordEventParams,\n  VoiceCallRecordMethodParams,\n  CallingCallCollectEventParams,\n  VoiceCallPromptMethodParams,\n  VoiceCallPromptAudioMethodParams,\n  VoiceCallPromptRingtoneMethodParams,\n  VoiceCallPromptTTSMethodParams,\n  EventTransform,\n  toLocalEvent,\n  toExternalJSON,\n  toSnakeCaseKeys,\n  CallingCallPlayEventParams,\n  VoiceCallTapMethodParams,\n  VoiceCallTapAudioMethodParams,\n  CallingCallTapEventParams,\n  CallingCallState,\n  CallingCallStateEventParams,\n  VoiceCallConnectMethodParams,\n  VoiceCallConnectPhoneMethodParams,\n  VoiceCallConnectSipMethodParams,\n  CallingCallConnectEventParams,\n  VoiceCallDetectMethodParams,\n  VoiceCallDetectMachineParams,\n  VoiceCallDetectFaxParams,\n  VoiceCallDetectDigitParams,\n  CallingCallDetectEventParams,\n  VoiceDialerParams,\n  CallingCallWaitForState,\n} from '@signalwire/core'\nimport { RealTimeCallApiEvents } from '../types'\nimport { AutoApplyTransformsConsumer } from '../AutoApplyTransformsConsumer'\nimport { toInternalDevices, toInternalPlayParams } from './utils'\nimport { Playlist } from './Playlist'\nimport {\n  voiceCallStateWorker,\n  voiceCallPlayWorker,\n  voiceCallRecordWorker,\n  voiceCallPromptWorker,\n  voiceCallTapWorker,\n  voiceCallConnectWorker,\n  voiceCallDialWorker,\n  voiceCallSendDigitsWorker,\n  voiceCallDetectWorker,\n  VoiceCallDialWorkerHooks,\n  VoiceCallSendDigitsWorkerHooks,\n} from './workers'\nimport { CallPlayback, createCallPlaybackObject } from './CallPlayback'\nimport { CallRecording, createCallRecordingObject } from './CallRecording'\nimport { CallPrompt, createCallPromptObject } from './CallPrompt'\nimport { CallTap, createCallTapObject } from './CallTap'\nimport { CallDetect, createCallDetectObject } from './CallDetect'\nimport { DeviceBuilder } from './DeviceBuilder'\n\ntype EmitterTransformsEvents =\n  | 'calling.playback.start'\n  | 'calling.playback.started'\n  | 'calling.playback.updated'\n  | 'calling.playback.ended'\n  | 'calling.recording.started'\n  | 'calling.recording.updated'\n  | 'calling.recording.ended'\n  | 'calling.recording.failed'\n  | 'calling.prompt.started'\n  | 'calling.prompt.updated'\n  | 'calling.prompt.ended'\n  | 'calling.prompt.failed'\n  | 'calling.tap.started'\n  | 'calling.tap.ended'\n  | 'calling.detect.started'\n  | 'calling.detect.ended'\n  // events not exposed\n  | 'calling.call.state'\n  | 'calling.detect.updated'\n  | 'calling.connect.connected'\n\n/**\n * A Call object represents an active call. You can get instances of a Call\n * object from a {@link Voice.Client}, by answering or initiating calls.\n */\nexport interface Call\n  extends VoiceCallContract<Call>,\n    EmitterContract<RealTimeCallApiEvents> {}\n\n/**\n * Used to resolve the play() method and to update the CallPlayback object through the EmitterTransform\n */\nexport const callingPlaybackTriggerEvent =\n  toLocalEvent<EmitterTransformsEvents>('calling.playback.trigger')\n\n/**\n * Used to resolve the record() method and to update the CallRecording object through the EmitterTransform\n */\nexport const callingRecordTriggerEvent = toLocalEvent<EmitterTransformsEvents>(\n  'calling.recording.trigger'\n)\n\n/**\n * Used to resolve the prompt() method and to update the CallPrompt object through the EmitterTransform\n */\nexport const callingPromptTriggerEvent = toLocalEvent<EmitterTransformsEvents>(\n  'calling.prompt.trigger'\n)\n\n/**\n * Used to resolve the tap() method and to update the CallTap object through the EmitterTransform\n */\nexport const callingTapTriggerEvent = toLocalEvent<EmitterTransformsEvents>(\n  'calling.tap.trigger'\n)\n\n/**\n * Used to resolve the detect() method and to update the CallDetect object through the EmitterTransform\n */\nexport const callingDetectTriggerEvent = toLocalEvent<EmitterTransformsEvents>(\n  'calling.detect.trigger'\n)\n\nexport class CallConsumer extends AutoApplyTransformsConsumer<RealTimeCallApiEvents> {\n  protected _eventsPrefix = 'calling' as const\n\n  public callId: string\n  public nodeId: string\n  public peer: string\n  public callState: string\n\n  constructor(options: BaseComponentOptions<RealTimeCallApiEvents>) {\n    super(options)\n    this._attachListeners(this.__uuid)\n    this.applyEmitterTransforms({ local: true })\n\n    // @ts-expect-error\n    this.on('call.state', () => {\n      /**\n       * FIXME: this no-op listener is required for our EE transforms to\n       * update the call object via the `calling.call.state` transform\n       * and apply the \"peer\" property to the Proxy.\n       */\n    })\n\n    /**\n     * It will take care of keeping instances of this class\n     * up-to-date with the latest changes sent from the\n     * server. Changes will be available to the consumer via\n     * our Proxy API.\n     */\n    this.runWorker('voiceCallStateWorker', {\n      worker: voiceCallStateWorker,\n    })\n  }\n\n  /** Unique id for this voice call */\n  get id() {\n    return this.callId\n  }\n\n  get state() {\n    return this.callState\n  }\n\n  get tag() {\n    return this.__uuid\n  }\n\n  /** The type of call. Only phone and sip are currently supported. */\n  get type() {\n    // @ts-expect-error\n    return this.device?.type ?? ''\n  }\n\n  /** The phone number that the call is coming from. */\n  get from() {\n    if (this.type === 'phone') {\n      // @ts-expect-error\n      return this.device?.params?.fromNumber ?? ''\n    } else if (this.type === 'sip') {\n      // @ts-expect-error\n      return this.device?.params?.from ?? ''\n    }\n    // @ts-expect-error\n    return this.device?.params?.from ?? ''\n  }\n\n  /** The phone number you are attempting to call. */\n  get to() {\n    if (this.type === 'phone') {\n      // @ts-expect-error\n      return this.device?.params?.toNumber ?? ''\n    } else if (this.type === 'sip') {\n      // @ts-expect-error\n      return this.device?.params?.to ?? ''\n    }\n    // @ts-expect-error\n    return this.device?.params?.to ?? ''\n  }\n\n  get headers() {\n    // @ts-expect-error\n    return this.device?.params?.headers ?? []\n  }\n\n  /** @internal */\n  protected getEmitterTransforms() {\n    return new Map<\n      EmitterTransformsEvents | EmitterTransformsEvents[],\n      EventTransform\n    >([\n      [\n        [\n          callingPlaybackTriggerEvent,\n          'calling.playback.started',\n          'calling.playback.updated',\n          'calling.playback.ended',\n        ],\n        {\n          type: 'voiceCallPlayback',\n          instanceFactory: (_payload: any) => {\n            return createCallPlaybackObject({\n              store: this.store,\n              // @ts-expect-error\n              emitter: this.emitter,\n            })\n          },\n          payloadTransform: (payload: CallingCallPlayEventParams) => {\n            return toExternalJSON(payload)\n          },\n        },\n      ],\n      [\n        [\n          callingRecordTriggerEvent,\n          'calling.recording.started',\n          'calling.recording.updated',\n          'calling.recording.ended',\n          'calling.recording.failed',\n        ],\n        {\n          type: 'voiceCallRecord',\n          instanceFactory: (_payload: any) => {\n            return createCallRecordingObject({\n              store: this.store,\n              // @ts-expect-error\n              emitter: this.emitter,\n            })\n          },\n          payloadTransform: (payload: CallingCallRecordEventParams) => {\n            return toExternalJSON(payload)\n          },\n        },\n      ],\n      [\n        [\n          callingPromptTriggerEvent,\n          'calling.prompt.started',\n          'calling.prompt.updated',\n          'calling.prompt.ended',\n          'calling.prompt.failed',\n        ],\n        {\n          type: 'voiceCallPrompt',\n          instanceFactory: (_payload: any) => {\n            return createCallPromptObject({\n              store: this.store,\n              // @ts-expect-error\n              emitter: this.emitter,\n            })\n          },\n          payloadTransform: (payload: CallingCallCollectEventParams) => {\n            return toExternalJSON(payload)\n          },\n        },\n      ],\n      [\n        [callingTapTriggerEvent, 'calling.tap.started', 'calling.tap.ended'],\n        {\n          type: 'voiceCallTap',\n          instanceFactory: (_payload: any) => {\n            return createCallTapObject({\n              store: this.store,\n              // @ts-expect-error\n              emitter: this.emitter,\n            })\n          },\n          payloadTransform: (payload: CallingCallTapEventParams) => {\n            return toExternalJSON(payload)\n          },\n        },\n      ],\n      [\n        ['calling.call.state'],\n        {\n          type: 'voiceCallState',\n          instanceFactory: (_payload: any) => {\n            return this\n          },\n          payloadTransform: (payload: CallingCallStateEventParams) => {\n            return toExternalJSON(payload)\n          },\n        },\n      ],\n      [\n        ['calling.connect.connected'],\n        {\n          type: 'voiceCallConnect',\n          instanceFactory: (_payload: any) => {\n            return createCallObject({\n              store: this.store,\n              // @ts-expect-error\n              emitter: this.emitter,\n            })\n          },\n          payloadTransform: (payload: CallingCallConnectEventParams) => {\n            /**\n             * Within a `calling.connect` process `tag` refers to the originator leg.\n             * We need to remove tag from the server payload to let the new (connected)\n             * Call object to use its own tag value set to `this.__uuid`.\n             */\n            const { tag, ...peerParams } = payload.peer\n            return toExternalJSON(peerParams)\n          },\n        },\n      ],\n      [\n        [\n          callingDetectTriggerEvent,\n          'calling.detect.started',\n          'calling.detect.updated',\n          'calling.detect.ended',\n        ],\n        {\n          type: 'voiceCallDetect',\n          instanceFactory: (_payload: any) => {\n            return createCallDetectObject({\n              store: this.store,\n              // @ts-expect-error\n              emitter: this.emitter,\n            })\n          },\n          payloadTransform: (payload: CallingCallDetectEventParams) => {\n            return toExternalJSON(payload)\n          },\n        },\n      ],\n    ])\n  }\n\n  dial(params: VoiceDialerParams) {\n    return new Promise((resolve, reject) => {\n      this.runWorker<VoiceCallDialWorkerHooks>('voiceCallDialWorker', {\n        worker: voiceCallDialWorker,\n        onDone: resolve,\n        onFail: reject,\n      })\n\n      let executeParams: Record<string, any>\n      if (params instanceof DeviceBuilder) {\n        const { devices } = params\n        executeParams = {\n          tag: this.__uuid,\n          devices: toInternalDevices(devices),\n        }\n      } else if ('region' in params) {\n        const { region, devices: deviceBuilder } = params\n        executeParams = {\n          tag: this.__uuid,\n          region,\n          devices: toInternalDevices(deviceBuilder.devices),\n        }\n      } else {\n        throw new Error('[dial] Invalid input')\n      }\n\n      this.execute({\n        method: 'calling.dial',\n        params: executeParams,\n      }).catch((e) => {\n        reject(e)\n      })\n    })\n  }\n\n  /**\n   * Hangs up the call.\n   * @param reason Optional reason for hanging up\n   *\n   * @example\n   *\n   * ```js\n   * call.hangup();\n   * ```\n   */\n  hangup(reason: VoiceCallDisconnectReason = 'hangup') {\n    return new Promise((resolve, reject) => {\n      if (!this.callId || !this.nodeId) {\n        reject(\n          new Error(\n            `Can't call hangup() on a call that hasn't been established.`\n          )\n        )\n      }\n\n      // @ts-expect-error\n      this.on('call.state', (params) => {\n        if (params.callState === 'ended') {\n          resolve(new Error('Failed to hangup the call.'))\n        }\n      })\n\n      this.execute({\n        method: 'calling.end',\n        params: {\n          node_id: this.nodeId,\n          call_id: this.callId,\n          reason: reason,\n        },\n      }).catch((e) => {\n        reject(e)\n      })\n    })\n  }\n\n  /**\n   * Answers the incoming call.\n   *\n   * @example\n   *\n   * ```js\n   * client.on('call.received', async (call) => {\n   *   try {\n   *     await call.answer()\n   *     console.log('Inbound call answered')\n   *   } catch (error) {\n   *     console.error('Error answering inbound call', error)\n   *   }\n   * })\n   * ```\n   */\n  answer() {\n    return new Promise<this>((resolve, reject) => {\n      if (!this.callId || !this.nodeId) {\n        reject(new Error(`Can't call answer() on a call without callId.`))\n      }\n\n      // @ts-expect-error\n      this.on('call.state', (params) => {\n        if (params.callState === 'answered') {\n          resolve(this)\n        } else if (params.callState === 'ended') {\n          reject(new Error('Failed to answer the call.'))\n        }\n      })\n\n      this.execute({\n        method: 'calling.answer',\n        params: {\n          node_id: this.nodeId,\n          call_id: this.callId,\n        },\n      }).catch((e) => {\n        reject(e)\n      })\n    })\n  }\n\n  /**\n   * Play one or multiple media in a Call and waits until the playing has ended.\n   *\n   * The play method is a generic method for all types of media, see\n   * {@link playAudio}, {@link playSilence}, {@link playTTS} or\n   * {@link playRingtone} for more specific usages.\n   *\n   * @param params a media playlist. See {@link Voice.Playlist}.\n   *\n   * @example\n   *\n   * ```js\n   * await call.play(new Voice.Playlist({ volume: 1.0 }).add(\n   *   Voice.Playlist.TTS({\n   *     text: 'Welcome to SignalWire! Please enter your 4 digits PIN',\n   *   })\n   * ))\n   * ```\n   */\n  play(params: VoicePlaylist) {\n    return new Promise<CallPlayback>((resolve, reject) => {\n      if (!this.callId || !this.nodeId) {\n        reject(new Error(`Can't call play() on a call not established yet.`))\n      }\n\n      const controlId = uuid()\n\n      this.runWorker('voiceCallPlayWorker', {\n        worker: voiceCallPlayWorker,\n        initialState: {\n          controlId,\n        },\n      })\n\n      const resolveHandler = (callPlayback: any) => {\n        resolve(callPlayback)\n      }\n\n      // @ts-expect-error\n      this.on(callingPlaybackTriggerEvent, resolveHandler)\n\n      this.execute({\n        method: 'calling.play',\n        params: {\n          node_id: this.nodeId,\n          call_id: this.callId,\n          control_id: controlId,\n          volume: params.volume,\n          play: toInternalPlayParams(params.media),\n        },\n      })\n        .then(() => {\n          // We intentionally omit `state` since that\n          // property is handled internally by the instance.\n          const startEvent: Omit<CallingCallPlayEventParams, 'state'> = {\n            control_id: controlId,\n            call_id: this.id,\n            node_id: this.nodeId,\n          }\n          // @ts-expect-error\n          this.emit(callingPlaybackTriggerEvent, startEvent)\n        })\n        .catch((e) => {\n          // @ts-expect-error\n          this.off(callingPlaybackTriggerEvent, resolveHandler)\n          reject(e)\n        })\n    })\n  }\n\n  /**\n   * Plays an audio file.\n   *\n   * @example\n   *\n   * ```js\n   * const playback = await call.playAudio({ url: 'https://cdn.signalwire.com/default-music/welcome.mp3' });\n   * await playback.ended();\n   * ```\n   */\n  playAudio(params: VoiceCallPlayAudioMethodParams) {\n    const { volume, ...rest } = params\n    const playlist = new Playlist({ volume }).add(Playlist.Audio(rest))\n    return this.play(playlist)\n  }\n\n  /**\n   * Plays some silence.\n   *\n   * @example\n   *\n   * ```js\n   * const playback = await call.playSilence({ duration: 3 });\n   * await playback.ended();\n   * ```\n   */\n  playSilence(params: VoiceCallPlaySilenceMethodParams) {\n    const playlist = new Playlist().add(Playlist.Silence(params))\n    return this.play(playlist)\n  }\n\n  /**\n   * Plays a ringtone.\n   *\n   * @example\n   *\n   * ```js\n   * const playback = await call.playRingtone({ name: 'it' });\n   * await playback.ended();\n   * ```\n   */\n  playRingtone(params: VoiceCallPlayRingtoneMethodParams) {\n    const { volume, ...rest } = params\n    const playlist = new Playlist({ volume }).add(Playlist.Ringtone(rest))\n    return this.play(playlist)\n  }\n\n  /**\n   * Plays text-to-speech.\n   *\n   * @example\n   *\n   * ```js\n   * const playback = await call.playTTS({ text: 'Welcome to SignalWire!' });\n   * await playback.ended();\n   * ```\n   */\n  playTTS(params: VoiceCallPlayTTSMethodParams) {\n    const { volume, ...rest } = params\n    const playlist = new Playlist({ volume }).add(Playlist.TTS(rest))\n    return this.play(playlist)\n  }\n\n  /**\n   * Generic method to record a call. Please see {@link recordAudio}.\n   */\n  record(params: VoiceCallRecordMethodParams) {\n    return new Promise<CallRecording>((resolve, reject) => {\n      if (!this.callId || !this.nodeId) {\n        reject(new Error(`Can't call record() on a call not established yet.`))\n      }\n\n      const controlId = uuid()\n\n      this.runWorker('voiceCallRecordWorker', {\n        worker: voiceCallRecordWorker,\n        initialState: {\n          controlId,\n        },\n      })\n\n      const resolveHandler = (callRecording: CallRecording) => {\n        resolve(callRecording)\n      }\n\n      // @ts-expect-error\n      this.on(callingRecordTriggerEvent, resolveHandler)\n\n      const record = toSnakeCaseKeys(params)\n      this.execute({\n        method: 'calling.record',\n        params: {\n          node_id: this.nodeId,\n          call_id: this.callId,\n          control_id: controlId,\n          record,\n        },\n      })\n        .then(() => {\n          const startEvent: Omit<CallingCallRecordEventParams, 'state'> = {\n            control_id: controlId,\n            call_id: this.id,\n            node_id: this.nodeId,\n            // state: 'recording',\n            record,\n          }\n          // @ts-expect-error\n          this.emit(callingRecordTriggerEvent, startEvent)\n        })\n        .catch((e) => {\n          // @ts-expect-error\n          this.off(callingRecordTriggerEvent, resolveHandler)\n          reject(e)\n        })\n    })\n  }\n\n  /**\n   * Records the audio from the call.\n   *\n   * @example\n   *\n   * ```js\n   * const recording = await call.recordAudio({ direction: 'both' })\n   * await recording.stop()\n   * ```\n   */\n  recordAudio(params: VoiceCallRecordMethodParams['audio'] = {}) {\n    return this.record({\n      audio: params,\n    })\n  }\n\n  /**\n   * Generic method to prompt the user for input. Please see {@link promptAudio}, {@link promptRingtone}, {@link promptTTS}.\n   */\n  prompt(params: VoiceCallPromptMethodParams) {\n    return new Promise<CallPrompt>((resolve, reject) => {\n      if (!this.callId || !this.nodeId) {\n        reject(new Error(`Can't call record() on a call not established yet.`))\n      }\n      if (!params.playlist) {\n        reject(new Error(`Missing 'playlist' params.`))\n      }\n\n      const controlId = uuid()\n\n      this.runWorker('voiceCallPromptWorker', {\n        worker: voiceCallPromptWorker,\n        initialState: {\n          controlId,\n        },\n      })\n\n      const resolveHandler = (callRecording: CallPrompt) => {\n        resolve(callRecording)\n      }\n      // @ts-expect-error\n      this.on(callingPromptTriggerEvent, resolveHandler)\n\n      const { volume, media } = params.playlist\n      // TODO: move this to a method to build `collect`\n      const { initial_timeout, partial_results, digits, speech } =\n        toSnakeCaseKeys(params)\n      const collect = {\n        initial_timeout,\n        partial_results,\n        digits,\n        speech,\n      }\n      this.execute({\n        method: 'calling.play_and_collect',\n        params: {\n          node_id: this.nodeId,\n          call_id: this.callId,\n          control_id: controlId,\n          volume,\n          play: toInternalPlayParams(media),\n          collect,\n        },\n      })\n        .then(() => {\n          const startEvent: Omit<CallingCallCollectEventParams, 'result'> = {\n            control_id: controlId,\n            call_id: this.id,\n            node_id: this.nodeId,\n          }\n          // TODO: (review) There's no event for prompt started so we generate it here\n          this.emit('prompt.started', startEvent)\n\n          // @ts-expect-error\n          this.emit(callingPromptTriggerEvent, startEvent)\n        })\n        .catch((e) => {\n          this.off('prompt.started', resolveHandler)\n\n          // @ts-expect-error\n          this.off(callingPromptTriggerEvent, resolveHandler)\n          reject(e)\n        })\n    })\n  }\n\n  /**\n   * Play an audio while collecting user input from the call, such as `digits` or `speech`.\n   *\n   * @example\n   *\n   * Prompting for digits and waiting for a result:\n   *\n   * ```js\n   * const prompt = await call.promptAudio({\n   *   url: 'https://cdn.signalwire.com/default-music/welcome.mp3',\n   *   digits: {\n   *     max: 5,\n   *     digitTimeout: 2,\n   *     terminators: '#*'\n   *   }\n   * })\n   * const { type, digits, terminator } = await prompt.ended()\n   * ```\n   */\n  promptAudio(params: VoiceCallPromptAudioMethodParams) {\n    const { url, volume, ...rest } = params\n    const playlist = new Playlist({ volume }).add(Playlist.Audio({ url }))\n\n    return this.prompt({\n      playlist,\n      ...rest,\n    })\n  }\n\n  /**\n   * Play a ringtone while collecting user input from the call, such as `digits` or `speech`.\n   *\n   * @example\n   *\n   * Prompting for digits and waiting for a result:\n   *\n   * ```js\n   * const prompt = await call.promptRingtone({\n   *   name: 'it',\n   *   duration: 10,\n   *   digits: {\n   *     max: 5,\n   *     digitTimeout: 2,\n   *     terminators: '#*'\n   *   }\n   * })\n   * const { type, digits, terminator } = await prompt.ended()\n   * ```\n   */\n  promptRingtone(params: VoiceCallPromptRingtoneMethodParams) {\n    const { name, duration, volume, ...rest } = params\n    const playlist = new Playlist({ volume }).add(\n      Playlist.Ringtone({ name, duration })\n    )\n\n    return this.prompt({\n      playlist,\n      ...rest,\n    })\n  }\n\n  /**\n   * Say some text while collecting user input from the call, such as `digits` or `speech`.\n   *\n   * @example\n   *\n   * Prompting for digits and waiting for a result:\n   *\n   * ```js\n   * const prompt = await call.promptTTS({\n   *   text: 'Please enter your PIN',\n   *   digits: {\n   *     max: 5,\n   *     digitTimeout: 2,\n   *     terminators: '#*'\n   *   }\n   * })\n   * const { type, digits, terminator } = await prompt.ended()\n   * ```\n   */\n  promptTTS(params: VoiceCallPromptTTSMethodParams) {\n    const { text, language, gender, volume, ...rest } = params\n    const playlist = new Playlist({ volume }).add(\n      Playlist.TTS({ text, language, gender })\n    )\n\n    return this.prompt({\n      playlist,\n      ...rest,\n    })\n  }\n\n  /**\n   * Play DTMF digits to the other party on the call.\n   *\n   * @example\n   *\n   * ```js\n   * await call.sendDigits('123')\n   * ```\n   */\n  sendDigits(digits: string) {\n    return new Promise((resolve, reject) => {\n      if (!this.callId || !this.nodeId) {\n        reject(\n          new Error(`Can't call sendDigits() on a call not established yet.`)\n        )\n      }\n\n      const controlId = uuid()\n\n      const cleanup = () => {\n        // @ts-expect-error\n        this.off('call.state', callStateHandler)\n      }\n\n      this.runWorker<VoiceCallSendDigitsWorkerHooks>(\n        'voiceCallSendDigitsWorker',\n        {\n          worker: voiceCallSendDigitsWorker,\n          initialState: {\n            controlId,\n          },\n          onDone: (args) => {\n            cleanup()\n            resolve(args)\n          },\n          onFail: ({ error }) => {\n            cleanup()\n            reject(error)\n          },\n        }\n      )\n\n      const callStateHandler = (params: any) => {\n        if (params.callState === 'ended' || params.callState === 'ending') {\n          reject(\n            new Error(\n              \"Call is ended or about to end, couldn't send digits in time.\"\n            )\n          )\n        }\n      }\n      // @ts-expect-error\n      this.once('call.state', callStateHandler)\n\n      this.execute({\n        method: 'calling.send_digits',\n        params: {\n          node_id: this.nodeId,\n          call_id: this.callId,\n          control_id: controlId,\n          digits,\n        },\n      }).catch((e) => {\n        reject(e)\n      })\n    })\n  }\n\n  /**\n   * Intercept call media and stream it to the specified WebSocket endpoint.\n   * Prefer using {@link tapAudio} if you only need to tap audio.\n   *\n   * @example\n   *\n   * ```js\n   * const tap = await call.tapAudio({\n   *   audio: {\n   *     direction: 'both',\n   *   },\n   *   device: {\n   *     type: 'ws',\n   *     uri: 'wss://example.domain.com/endpoint',\n   *   },\n   * })\n   *\n   * await tap.stop()\n   * ```\n   */\n  tap(params: VoiceCallTapMethodParams) {\n    return new Promise<CallTap>((resolve, reject) => {\n      if (!this.callId || !this.nodeId) {\n        reject(new Error(`Can't call tap() on a call not established yet.`))\n      }\n\n      const controlId = uuid()\n\n      this.runWorker('voiceCallTapWorker', {\n        worker: voiceCallTapWorker,\n        initialState: {\n          controlId,\n        },\n      })\n\n      const resolveHandler = (callTap: CallTap) => {\n        resolve(callTap)\n      }\n\n      // @ts-expect-error\n      this.on(callingTapTriggerEvent, resolveHandler)\n\n      // TODO: Move to a method to build the objects and transform camelCase to snake_case\n      const {\n        audio = {},\n        device: { type, ...rest },\n      } = params\n\n      this.execute({\n        method: 'calling.tap',\n        params: {\n          node_id: this.nodeId,\n          call_id: this.callId,\n          control_id: controlId,\n          tap: {\n            type: 'audio',\n            params: audio,\n          },\n          device: {\n            type,\n            params: rest,\n          },\n        },\n      })\n        .then(() => {\n          const startEvent: Omit<\n            CallingCallTapEventParams,\n            'state' | 'tap' | 'device'\n          > = {\n            control_id: controlId,\n            call_id: this.id,\n            node_id: this.nodeId,\n          }\n          // @ts-expect-error\n          this.emit(callingTapTriggerEvent, startEvent)\n        })\n        .catch((e) => {\n          // @ts-expect-error\n          this.off(callingTapTriggerEvent, resolveHandler)\n          reject(e)\n        })\n    })\n  }\n\n  /**\n   * Intercept call audio and stream it to the specified WebSocket endpoint.\n   *\n   * @example\n   *\n   * ```js\n   * const tap = await call.tapAudio({\n   *   direction: 'both',\n   *   device: {\n   *     type: 'ws',\n   *     uri: 'wss://example.domain.com/endpoint',\n   *   },\n   * })\n   *\n   * await tap.stop()\n   * ```\n   */\n  tapAudio(params: VoiceCallTapAudioMethodParams) {\n    const { direction, device } = params\n    return this.tap({ audio: { direction }, device })\n  }\n\n  /**\n   * Attempt to connect an existing call to a new outbound call. You can wait\n   * until the call is disconnected by calling {@link waitForDisconnected}.\n   *\n   * This is a generic method that allows you to connect to multiple devices in\n   * series, parallel, or combinations of both with the use of a\n   * {@link Voice.DeviceBuilder}. For simpler use cases, prefer using\n   * {@link connectPhone} or {@link connectSip}.\n   *\n   * @example\n   *\n   * Connecting to a new SIP call.\n   *\n   * ```js\n   * const plan = new Voice.DeviceBuilder().add(\n   *   Voice.DeviceBuilder.Sip({\n   *     from: 'sip:user1@domain.com',\n   *     to: 'sip:user2@domain.com',\n   *     timeout: 30,\n   *   })\n   * )\n   *\n   * const peer = await call.connect(plan)\n   * ```\n   */\n  connect(params: VoiceCallConnectMethodParams) {\n    return new Promise<any>((resolve, reject) => {\n      if (!this.callId || !this.nodeId) {\n        reject(new Error(`Can't call connect() on a call not established yet.`))\n      }\n\n      let executeParams: Record<string, any>\n      if (params instanceof DeviceBuilder) {\n        const { devices } = params\n        executeParams = {\n          tag: this.__uuid,\n          devices: toInternalDevices(devices),\n        }\n      } else if ('ringback' in params) {\n        const { ringback, devices: deviceBuilder } = params\n        executeParams = {\n          tag: this.__uuid,\n          ringback: toInternalPlayParams(ringback?.media ?? []),\n          devices: toInternalDevices(deviceBuilder.devices),\n        }\n      } else {\n        throw new Error('[connect] Invalid input')\n      }\n\n      this.runWorker('voiceCallConnectWorker', {\n        worker: voiceCallConnectWorker,\n      })\n\n      const resolveHandler = (payload: CallingCallConnectEventParams) => {\n        // @ts-expect-error\n        this.off('connect.failed', rejectHandler)\n\n        resolve(payload)\n      }\n\n      const rejectHandler = (payload: CallingCallConnectEventParams) => {\n        // @ts-expect-error\n        this.off('connect.connected', resolveHandler)\n\n        reject(toExternalJSON(payload))\n      }\n\n      // @ts-expect-error\n      this.once('connect.connected', resolveHandler)\n      // @ts-expect-error\n      this.once('connect.failed', rejectHandler)\n\n      this.execute({\n        method: 'calling.connect',\n        params: {\n          node_id: this.nodeId,\n          call_id: this.callId,\n          tag: this.__uuid,\n          ...executeParams,\n        },\n      }).catch((e) => {\n        // @ts-expect-error\n        this.off('connect.connected', resolveHandler)\n        // @ts-expect-error\n        this.off('connect.failed', rejectHandler)\n\n        reject(e)\n      })\n    })\n  }\n\n  /**\n   * Attempt to connect an existing call to a new outbound phone call. You can\n   * wait until the call is disconnected by calling {@link waitForDisconnected}.\n   *\n   * @example\n   *\n   * ```js\n   * const peer = await call.connectPhone({\n   *   from: '+xxxxxx',\n   *   to: '+yyyyyy',\n   *   timeout: 30\n   * })\n   * ```\n   */\n  connectPhone({ ringback, ...params }: VoiceCallConnectPhoneMethodParams) {\n    const devices = new DeviceBuilder().add(DeviceBuilder.Phone(params))\n    return this.connect({ devices, ringback })\n  }\n\n  /**\n   * Attempt to connect an existing call to a new outbound SIP call. You can\n   * wait until the call is disconnected by calling {@link waitForDisconnected}.\n   *\n   * @example\n   *\n   * ```js\n   * const peer = await call.connectPhone({\n   *   from: 'sip:user1@domain.com',\n   *   to: 'sip:user2@domain.com',\n   *   timeout: 30\n   * })\n   * ```\n   */\n  connectSip({ ringback, ...params }: VoiceCallConnectSipMethodParams) {\n    const devices = new DeviceBuilder().add(DeviceBuilder.Sip(params))\n    return this.connect({ devices, ringback })\n  }\n\n  disconnect() {\n    return new Promise<void>((resolve, reject) => {\n      if (!this.callId || !this.nodeId || !this.peer) {\n        reject(\n          new Error(`Can't call disconnect() on a call not connected yet.`)\n        )\n      }\n\n      const resolveHandler = () => {\n        resolve()\n      }\n      // @ts-expect-error\n      this.once('connect.disconnected', resolveHandler)\n\n      this.execute({\n        method: 'calling.disconnect',\n        params: {\n          node_id: this.nodeId,\n          call_id: this.callId,\n        },\n      }).catch((e) => {\n        // @ts-expect-error\n        this.off('connect.disconnected', resolveHandler)\n\n        reject(e)\n      })\n    })\n  }\n\n  /**\n   * @deprecated use {@link disconnected} instead.\n   */\n  waitForDisconnected() {\n    return this.disconnect\n  }\n\n  disconnected() {\n    return new Promise<this>((resolve) => {\n      const resolveHandler = () => {\n        resolve(this)\n      }\n      // @ts-expect-error\n      this.once('connect.disconnected', resolveHandler)\n      // @ts-expect-error\n      this.once('connect.failed', resolveHandler)\n\n      if (this.state === 'ended' || this.state === 'ending') {\n        return resolveHandler()\n      }\n    })\n  }\n\n  /**\n   * Generic method. Please see {@link amd}, {@link detectFax}, {@link detectDigit}.\n   */\n  detect(params: VoiceCallDetectMethodParams) {\n    return new Promise<CallDetect>((resolve, reject) => {\n      if (!this.callId || !this.nodeId) {\n        reject(new Error(`Can't call detect() on a call not established yet.`))\n      }\n\n      // TODO: build params in a method\n      const { waitForBeep = false, timeout, type, ...rest } = params\n      const controlId = uuid()\n\n      this.runWorker('voiceCallDetectWorker', {\n        worker: voiceCallDetectWorker,\n        initialState: {\n          controlId,\n          waitForBeep,\n        },\n      })\n\n      const resolveHandler = (callDetect: CallDetect) => {\n        resolve(callDetect)\n      }\n\n      // @ts-expect-error\n      this.on(callingDetectTriggerEvent, resolveHandler)\n\n      this.execute({\n        method: 'calling.detect',\n        params: {\n          node_id: this.nodeId,\n          call_id: this.callId,\n          control_id: controlId,\n          timeout,\n          detect: {\n            type,\n            params: toSnakeCaseKeys(rest),\n          },\n        },\n      })\n        .then(() => {\n          const startEvent: CallingCallDetectEventParams = {\n            control_id: controlId,\n            call_id: this.id,\n            node_id: this.nodeId,\n          }\n          // @ts-expect-error\n          this.emit(callingDetectTriggerEvent, startEvent)\n        })\n        .catch((e) => {\n          // @ts-expect-error\n          this.off(callingDetectTriggerEvent, resolveHandler)\n          reject(e)\n        })\n    })\n  }\n\n  /**\n   * Detects the presence of an answering machine.\n   *\n   * @example\n   *\n   * ```js\n   * const detect = await call.amd()\n   * const result = await detect.ended()\n   *\n   * console.log('Detect result:', result.type)\n   * ```\n   */\n  amd(params: Omit<VoiceCallDetectMachineParams, 'type'> = {}) {\n    return this.detect({\n      ...params,\n      type: 'machine',\n    })\n  }\n\n  /**\n   * Alias for amd()\n   */\n  detectAnsweringMachine = this.amd\n\n  /**\n   * Detects the presence of a fax machine.\n   *\n   * @example\n   *\n   * ```js\n   * const detect = await call.detectFax()\n   * const result = await detect.ended()\n   *\n   * console.log('Detect result:', result.type)\n   * ```\n   */\n  detectFax(params: Omit<VoiceCallDetectFaxParams, 'type'> = {}) {\n    return this.detect({\n      ...params,\n      type: 'fax',\n    })\n  }\n\n  /**\n   * Detects digits in the audio stream.\n   *\n   * @example\n   *\n   * ```js\n   * const detect = await call.detectDigit()\n   * const result = await detect.ended()\n   *\n   * console.log('Detect result:', result.type)\n   * ```\n   */\n  detectDigit(params: Omit<VoiceCallDetectDigitParams, 'type'> = {}) {\n    return this.detect({\n      ...params,\n      type: 'digit',\n    })\n  }\n\n  /**\n   * Returns a promise that is resolved only after the current call is in one of\n   * the specified states.\n   *\n   * @returns true if the requested states have been reached, false if they\n   * won't be reached because the call ended.\n   *\n   * @example\n   *\n   * ```js\n   * await call.waitFor('ended')\n   * ```\n   */\n  waitFor(params: CallingCallWaitForState | CallingCallWaitForState[]) {\n    return new Promise((resolve) => {\n      if (!params) {\n        resolve(true)\n      }\n\n      const events = Array.isArray(params) ? params : [params]\n      const emittedCallStates = new Set<CallingCallState>()\n      const shouldResolve = () => emittedCallStates.size === events.length\n      const shouldWaitForEnded = events.includes('ended')\n      // If the user is not awaiting for the `ended` state\n      // and we've got that from the server then we won't\n      // get the event/s the user was awaiting for\n      const shouldResolveUnsuccessful = (state: CallingCallState) => {\n        return !shouldWaitForEnded && state === 'ended'\n      }\n\n      // @ts-expect-error\n      this.on('call.state', (params) => {\n        if (events.includes(params.callState)) {\n          emittedCallStates.add(params.callState)\n        } else if (shouldResolveUnsuccessful(params.callState)) {\n          return resolve(false)\n        }\n\n        if (shouldResolve()) {\n          resolve(true)\n        }\n      })\n    })\n  }\n}\n\n// FIXME: instead of Omit methods, i used \"Partial<VoiceCallMethods>\"\nexport const CallAPI = extendComponent<CallConsumer, Partial<VoiceCallMethods>>(\n  CallConsumer,\n  {}\n)\n\nexport const createCallObject = (\n  params: BaseComponentOptions<EmitterTransformsEvents>\n): Call => {\n  const call = connect<RealTimeCallApiEvents, CallConsumer, Call>({\n    store: params.store,\n    Component: CallAPI,\n    componentListeners: {\n      errors: 'onError',\n      responses: 'onSuccess',\n    },\n  })(params)\n\n  return call\n}\n", "import { BaseConsumer, EventEmitter } from '@signalwire/core'\n\n/**\n * This class is extended by Call and Voice since they don't\n * invoke \"signalwire.subscribe\" but they need to apply the\n * emitter transforms on each `.on()`/`.once()` call.\n * TODO: improve this logic.\n * https://github.com/signalwire/signalwire-js/pull/477#discussion_r841623381\n * https://github.com/signalwire/signalwire-js/pull/477#discussion_r841435646\n */\nexport class AutoApplyTransformsConsumer<\n  EventTypes extends EventEmitter.ValidEventTypes\n> extends BaseConsumer<EventTypes> {\n  override on(\n    event: EventEmitter.EventNames<EventTypes>,\n    fn: EventEmitter.EventListener<EventTypes, any>\n  ) {\n    const instance = super.on(event, fn)\n    this.applyEmitterTransforms()\n\n    return instance\n  }\n\n  override once(\n    event: EventEmitter.EventNames<EventTypes>,\n    fn: EventEmitter.EventListener<EventTypes, any>\n  ) {\n    const instance = super.once(event, fn)\n    this.applyEmitterTransforms()\n\n    return instance\n  }\n}\n", "import type {\n  VoiceCallDeviceParams,\n  VoiceCallDialMethodParams,\n  VoiceCallPlayParams,\n  VoiceCallPlayMethodParams,\n} from '@signalwire/core'\nimport { toSnakeCaseKeys } from '@signalwire/core'\n\nconst toInternalDevice = (device: VoiceCallDeviceParams) => {\n  switch (device.type) {\n    case 'sip': {\n      const { type, ...params } = device\n      return {\n        type,\n        params: toSnakeCaseKeys(params),\n      }\n    }\n    case 'phone': {\n      const { to, from, type, ...rest } = device\n      return {\n        type,\n        params: toSnakeCaseKeys({\n          ...rest,\n          to_number: to,\n          from_number: from,\n        }),\n      }\n    }\n\n    // TODO: handle other devices\n  }\n\n  return device\n}\n\n// TODO: add proper to internal mapping\ntype ToInternalDialParams<T> = T extends any ? any : any\n\nexport const toInternalDevices = (\n  params: VoiceCallDialMethodParams['devices'],\n  internalDevices: ToInternalDialParams<\n    VoiceCallDialMethodParams['devices']\n  > = []\n) => {\n  params.forEach((dev, index) => {\n    if (Array.isArray(dev)) {\n      internalDevices[index] = toInternalDevices(dev)\n    } else {\n      internalDevices[index] = toInternalDevice(dev)\n    }\n  })\n  return internalDevices\n}\n\nconst toInternalPlay = (media: VoiceCallPlayParams) => {\n  const { type, ...params } = media\n  return { type, params }\n}\n\n// TODO: add proper to internal mapping\ntype ToInternalPlayParams<T> = T extends any ? any : any\n\nexport const toInternalPlayParams = (\n  params: VoiceCallPlayMethodParams['media'],\n  result: ToInternalPlayParams<VoiceCallPlayMethodParams['media']> = []\n) => {\n  params.forEach((media, index) => {\n    if (Array.isArray(media)) {\n      result[index] = toInternalPlayParams(media)\n    } else {\n      result[index] = toInternalPlay(media)\n    }\n  })\n  return result\n}\n", "import type {\n  CreateVoicePlaylistParams,\n  VoicePlaylist,\n  VoiceCallPlayParams,\n  VoiceCallPlayAudioParams,\n  VoiceCallPlayTTSParams,\n  VoiceCallPlaySilenceParams,\n  VoiceCallPlayRingtoneParams,\n  VoicePlaylistAudioParams,\n  VoicePlaylistTTSParams,\n  VoicePlaylistSilenceParams,\n  VoicePlaylistRingtoneParams,\n} from '@signalwire/core'\n\n/**\n * A Playlist object allows you to specify a series of media which should be\n * played in sequence. You can then pass the playlist to the methods that\n * support it, for example {@link Call.play}.\n *\n * @example\n *\n * Creates a playlist for playing, in sequence, a TTS message, 1 second of\n * silence, and an mp3 file.\n *\n * ```js\n * const playlist = new Voice.Playlist({ volume: 1.0 })\n *   .add(Voice.Playlist.TTS({\n *     text: 'Welcome to SignalWire!',\n *   }))\n *   .add(Voice.Playlist.Silence({ duration: 1 }))\n *   .add(Voice.Playlist.Audio({\n *     url: 'https://cdn.signalwire.com/default-music/welcome.mp3'\n *   }))\n * ```\n */\nexport class Playlist implements VoicePlaylist {\n  private _media: VoicePlaylist['media'] = []\n\n  constructor(private params: CreateVoicePlaylistParams = {}) {}\n\n  /** Default volume for the audio in the playlist. */\n  get volume() {\n    return this.params?.volume\n  }\n\n  /** The media in this playlist. */\n  get media() {\n    return this._media\n  }\n\n  /** Adds a new media to the playlist*/\n  add(params: VoiceCallPlayParams) {\n    this._media.push(params)\n    return this\n  }\n\n  /**\n   * An audio media.\n   * @params params - {@link VoicePlaylistAudioParams}\n   * @returns - {@link VoiceCallPlayAudioParams}\n   **/\n  static Audio(params: VoicePlaylistAudioParams): VoiceCallPlayAudioParams {\n    return { type: 'audio', ...params }\n  }\n\n  /**\n   * A TTS media.\n   * @params params - {@link VoicePlaylistTTSParams}\n   * @returns - {@link VoiceCallPlayTTSParams}\n   **/\n  static TTS(params: VoicePlaylistTTSParams): VoiceCallPlayTTSParams {\n    return { type: 'tts', ...params }\n  }\n\n  /**\n   * A silence interval.\n   * @params params - {@link VoicePlaylistSilenceParams}\n   * @returns - {@link VoiceCallPlaySilenceParams}\n   **/\n  static Silence(\n    params: VoicePlaylistSilenceParams\n  ): VoiceCallPlaySilenceParams {\n    return { type: 'silence', ...params }\n  }\n\n  /**\n   * A ringtone media.\n   * @params param - {@link VoicePlaylistRingtoneParams}\n   * @returns - {@link VoiceCallPlayRingtoneParams}\n   **/\n  static Ringtone(\n    params: VoicePlaylistRingtoneParams\n  ): VoiceCallPlayRingtoneParams {\n    return { type: 'ringtone', ...params }\n  }\n}\n", "import {\n  getLogger,\n  sagaEffects,\n  SagaIterator,\n  SDKWorker,\n  SDKActions,\n  CallingCallStateEvent,\n  MapToPubSubShape,\n} from '@signalwire/core'\nimport type { Call } from '../Call'\n\nexport const voiceCallStateWorker: SDKWorker<Call> = function* (\n  options\n): SagaIterator {\n  const { channels, instance } = options\n  const { swEventChannel, pubSubChannel } = channels\n  getLogger().trace('voiceCallStateWorker started', instance.id, instance.tag)\n\n  let run = true\n  const done = () => (run = false)\n\n  while (run) {\n    const action: MapToPubSubShape<CallingCallStateEvent> =\n      yield sagaEffects.take(swEventChannel, (action: SDKActions) => {\n        if (action.type === 'calling.call.state') {\n          // To avoid mixing events on `connect` we check\n          // for `instance.id` if there's already a callId\n          // value.\n          if (instance.id) {\n            return instance.id === action.payload.call_id\n          }\n          return instance.tag === action.payload.tag\n        }\n        return false\n      })\n\n    /**\n     * Override (or inject) \"tag\" with `instance.tag`\n     * because we use it as namespace in the EE and:\n     * - all the inbound legs have no \"tag\" in the\n     *   `calling.call.state` events\n     * - all the legs created by a \"connect\" RPC will share\n     *   the same \"tag\" of the originator leg to allow the\n     *   SDK to make a relation\n     *\n     * Since in the SDK each Call has its own \"tag\"\n     * (__uuid), we need to target them through the EE with\n     * the right \"tag\".\n     */\n    const newPayload = {\n      ...action.payload,\n      tag: instance.tag,\n    }\n\n    /**\n     * Update the Call object payload with the new state\n     */\n    yield sagaEffects.put(pubSubChannel, {\n      type: 'calling.call.state',\n      payload: newPayload,\n    })\n\n    if (newPayload.call_state === 'ended') {\n      done()\n    }\n  }\n\n  getLogger().trace('voiceCallStateWorker ended', instance.id, instance.tag)\n}\n", "import {\n  getLogger,\n  sagaEffects,\n  SagaIterator,\n  SDKWorker,\n} from '@signalwire/core'\nimport type { Client } from '../../client/index'\n\nexport const voiceCallReceiveWorker: SDKWorker<Client> = function* (\n  options\n): SagaIterator {\n  getLogger().trace('voiceCallReceiveWorker started')\n  const { channels, instance } = options\n  const { swEventChannel, pubSubChannel } = channels\n  // contexts is required\n  const { contexts = [] } = instance?.options ?? {}\n  if (!contexts.length) {\n    throw new Error('Invalid contexts to receive inbound calls')\n  }\n\n  while (true) {\n    const action = yield sagaEffects.take(swEventChannel, (action: any) => {\n      return (\n        action.type === 'calling.call.receive' &&\n        contexts.includes(action.payload.context)\n      )\n    })\n\n    yield sagaEffects.put(pubSubChannel, {\n      type: 'calling.call.received',\n      payload: action.payload,\n    })\n  }\n\n  getLogger().trace('voiceCallReceiveWorker ended')\n}\n", "import {\n  getLogger,\n  sagaEffects,\n  SagaIterator,\n  SDKWorker,\n  SDKActions,\n  CallingCallPlayEvent,\n  MapToPubSubShape,\n} from '@signalwire/core'\nimport type { Call } from '../Call'\nimport { callingPlaybackTriggerEvent } from '../Call'\n\nexport const voiceCallPlayWorker: SDKWorker<Call> = function* (\n  options\n): SagaIterator {\n  getLogger().trace('voiceCallPlayWorker started')\n  const { channels, instance, initialState } = options\n  const { swEventChannel, pubSubChannel } = channels\n  const { controlId } = initialState\n  if (!controlId) {\n    throw new Error('Missing controlId for playback')\n  }\n\n  let paused = false\n  let run = true\n  const done = () => (run = false)\n\n  while (run) {\n    const action: MapToPubSubShape<CallingCallPlayEvent> =\n      yield sagaEffects.take(swEventChannel, (action: SDKActions) => {\n        return (\n          action.type === 'calling.call.play' &&\n          action.payload.control_id === controlId\n        )\n      })\n\n    /** Add `tag` to the payload to allow pubSubSaga to match it with the Call namespace */\n    const payloadWithTag = {\n      tag: instance.tag,\n      ...action.payload,\n    }\n\n    /**\n     * Update the original CallPlayback object using the\n     * transform pipeline\n     */\n     yield sagaEffects.put(pubSubChannel, {\n      // @ts-ignore\n      type: callingPlaybackTriggerEvent,\n      // @ts-ignore\n      payload: payloadWithTag,\n    })\n\n    switch (action.payload.state) {\n      case 'playing': {\n        const type = paused\n          ? 'calling.playback.updated'\n          : 'calling.playback.started'\n        paused = false\n\n        yield sagaEffects.put(pubSubChannel, {\n          type,\n          payload: payloadWithTag,\n        })\n        break\n      }\n      case 'paused': {\n        paused = true\n\n        yield sagaEffects.put(pubSubChannel, {\n          type: 'calling.playback.updated',\n          payload: payloadWithTag,\n        })\n        break\n      }\n      case 'error':\n        // TODO: dispatch calling.playback.error ?\n        break\n      case 'finished': {\n        yield sagaEffects.put(pubSubChannel, {\n          type: 'calling.playback.ended',\n          payload: payloadWithTag,\n        })\n\n        /**\n         * Dispatch an event to resolve `ended()` in CallPlayback\n         * when ended\n         */\n        yield sagaEffects.put(pubSubChannel, {\n          type: 'calling.playback.ended',\n          // @ts-ignore\n          payload: {\n            tag: controlId,\n            ...action.payload,\n          },\n        })\n\n        done()\n        break\n      }\n    }\n  }\n\n  getLogger().trace('voiceCallPlayWorker ended')\n}\n", "import {\n  getLogger,\n  sagaEffects,\n  SagaIterator,\n  SDKWorker,\n  SDKActions,\n  CallingCallRecordEvent,\n  MapToPubSubShape,\n} from '@signalwire/core'\nimport { callingRecordTriggerEvent } from '../Call'\nimport type { Call } from '../Call'\n\nexport const voiceCallRecordWorker: SDKWorker<Call> = function* (\n  options\n): SagaIterator {\n  getLogger().trace('voiceCallRecordWorker started')\n  const { channels, instance, initialState } = options\n  const { swEventChannel, pubSubChannel } = channels\n  const { controlId } = initialState\n  if (!controlId) {\n    throw new Error('Missing controlId for recording')\n  }\n\n  let run = true\n  const done = () => (run = false)\n\n  while (run) {\n    const action: MapToPubSubShape<CallingCallRecordEvent> =\n      yield sagaEffects.take(swEventChannel, (action: SDKActions) => {\n        return (\n          action.type === 'calling.call.record' &&\n          action.payload.control_id === controlId\n        )\n      })\n\n    /** Add `tag` to the payload to allow pubSubSaga to match it with the Call namespace */\n    const payloadWithTag = {\n      tag: instance.tag,\n      ...action.payload,\n    }\n\n    /**\n     * Update the original CallRecording object using the\n     * transform pipeline\n     */\n    yield sagaEffects.put(pubSubChannel, {\n      // @ts-ignore\n      type: callingRecordTriggerEvent,\n      // @ts-ignore\n      payload: payloadWithTag,\n    })\n\n    switch (action.payload.state) {\n      case 'recording': {\n        yield sagaEffects.put(pubSubChannel, {\n          type: 'calling.recording.started',\n          payload: payloadWithTag,\n        })\n        break\n      }\n\n      case 'no_input':\n      case 'finished': {\n        const typeToEmit =\n          action.payload.state === 'finished'\n            ? 'calling.recording.ended'\n            : 'calling.recording.failed'\n\n        yield sagaEffects.put(pubSubChannel, {\n          type: typeToEmit,\n          payload: payloadWithTag,\n        })\n\n        /**\n         * Dispatch an event to resolve `ended()` in CallRecord\n         * when ended\n         */\n        yield sagaEffects.put(pubSubChannel, {\n          type: typeToEmit,\n          payload: {\n            tag: controlId,\n            ...action.payload,\n          },\n        })\n\n        done()\n        break\n      }\n    }\n  }\n\n  getLogger().trace('voiceCallRecordWorker ended')\n}\n", "import {\n  getLogger,\n  sagaEffects,\n  SagaIterator,\n  SDKWorker,\n  SDKActions,\n  CallingCallCollectEvent,\n  MapToPubSubShape,\n} from '@signalwire/core'\nimport { callingPromptTriggerEvent } from '../Call'\nimport type { Call } from '../Call'\n\nexport const voiceCallPromptWorker: SDKWorker<Call> = function* (\n  options\n): SagaIterator {\n  getLogger().trace('voiceCallPromptWorker started')\n  const { channels, instance, initialState } = options\n  const { swEventChannel, pubSubChannel } = channels\n  const { controlId } = initialState\n  if (!controlId) {\n    throw new Error('Missing controlId for prompt')\n  }\n\n  let run = true\n  const done = () => (run = false)\n\n  while (run) {\n    const action: MapToPubSubShape<CallingCallCollectEvent> =\n      yield sagaEffects.take(swEventChannel, (action: SDKActions) => {\n        return (\n          action.type === 'calling.call.collect' &&\n          action.payload.control_id === controlId\n        )\n      })\n\n    /** Add `tag` to the payload to allow pubSubSaga to match it with the Call namespace */\n    const payloadWithTag = {\n      tag: instance.tag,\n      ...action.payload,\n    }\n\n    /**\n     * Update the original CallPrompt object using the transform pipeline\n     */\n    yield sagaEffects.put(pubSubChannel, {\n      // @ts-expect-error\n      type: callingPromptTriggerEvent,\n      // @ts-ignore\n      payload: payloadWithTag,\n    })\n\n    if (action.payload.result) {\n      let typeToEmit: 'calling.prompt.failed' | 'calling.prompt.ended'\n      switch (action.payload.result.type) {\n        case 'no_match':\n        case 'no_input':\n        case 'error': {\n          typeToEmit = 'calling.prompt.failed'\n          break\n        }\n        case 'speech':\n        case 'digit': {\n          typeToEmit = 'calling.prompt.ended'\n          break\n        }\n        // case 'start_of_speech': { TODO:\n        //   break\n        // }\n      }\n\n      yield sagaEffects.put(pubSubChannel, {\n        type: typeToEmit,\n        payload: payloadWithTag,\n      })\n\n      /**\n       * Dispatch an event to resolve `ended` in CallPrompt\n       * when ended\n       */\n      yield sagaEffects.put(pubSubChannel, {\n        type: typeToEmit,\n        // @ts-ignore\n        payload: {\n          tag: controlId,\n          ...action.payload,\n        },\n      })\n\n      done()\n    }\n\n    /**\n     * Only when partial_results: true\n     */\n    if (action.payload.final === false) {\n      yield sagaEffects.put(pubSubChannel, {\n        type: 'calling.prompt.updated',\n        payload: payloadWithTag,\n      })\n    }\n  }\n\n  getLogger().trace('voiceCallPromptWorker ended')\n}\n", "import {\n  getLogger,\n  sagaEffects,\n  SagaIterator,\n  SDKWorker,\n  SDKActions,\n  CallingCallTapEvent,\n  MapToPubSubShape,\n} from '@signalwire/core'\nimport { callingTapTriggerEvent } from '../Call'\nimport type { Call } from '../Call'\n\nexport const voiceCallTapWorker: SDKWorker<Call> = function* (\n  options\n): SagaIterator {\n  getLogger().trace('voiceCallTapWorker started')\n  const { channels, instance, initialState } = options\n  const { swEventChannel, pubSubChannel } = channels\n  const { controlId } = initialState\n  if (!controlId) {\n    throw new Error('Missing controlId for tapping')\n  }\n\n  let run = true\n  const done = () => (run = false)\n\n  while (run) {\n    const action: MapToPubSubShape<CallingCallTapEvent> =\n      yield sagaEffects.take(swEventChannel, (action: SDKActions) => {\n        return (\n          action.type === 'calling.call.tap' &&\n          action.payload.control_id === controlId\n        )\n      })\n\n    /** Add `tag` to the payload to allow pubSubSaga to match it with the Call namespace */\n    const payloadWithTag = {\n      tag: instance.tag,\n      ...action.payload,\n    }\n\n    /**\n     * Update the original CallTap object using the transform pipeline\n     */\n    yield sagaEffects.put(pubSubChannel, {\n      // @ts-ignore\n      type: callingTapTriggerEvent,\n      // @ts-ignore\n      payload: payloadWithTag,\n    })\n\n    switch (action.payload.state) {\n      case 'tapping': {\n        yield sagaEffects.put(pubSubChannel, {\n          type: 'calling.tap.started',\n          payload: payloadWithTag,\n        })\n        break\n      }\n      case 'finished': {\n        yield sagaEffects.put(pubSubChannel, {\n          type: 'calling.tap.ended',\n          payload: payloadWithTag,\n        })\n\n        /**\n         * Dispatch an event to resolve `ended()` in CallTap when ended\n         */\n        yield sagaEffects.put(pubSubChannel, {\n          type: 'calling.tap.ended',\n          payload: {\n            tag: controlId,\n            ...action.payload,\n          },\n        })\n\n        done()\n        break\n      }\n    }\n  }\n\n  getLogger().trace('voiceCallTapWorker ended')\n}\n", "import {\n  getLogger,\n  sagaEffects,\n  SagaIterator,\n  SDKWorker,\n  SDKActions,\n  CallingCallConnectEvent,\n  MapToPubSubShape,\n} from '@signalwire/core'\nimport type { Call } from '../Call'\n\nexport const voiceCallConnectWorker: SDKWorker<Call> = function* (\n  options\n): SagaIterator {\n  getLogger().trace('voiceCallConnectWorker started')\n  const { channels, instance } = options\n  const { swEventChannel, pubSubChannel } = channels\n\n  let run = true\n  const done = () => (run = false)\n\n  while (run) {\n    const action: MapToPubSubShape<CallingCallConnectEvent> =\n      yield sagaEffects.take(swEventChannel, (action: SDKActions) => {\n        return (\n          action.type === 'calling.call.connect' &&\n          (action.payload.call_id === instance.callId ||\n            action.payload.tag === instance.tag ||\n            /**\n             * This branch applies for Inbound calls that\n             * don't have a `tag` at the payload's root\n             * level.\n             */\n            action.payload.peer?.tag === instance.tag)\n        )\n      })\n\n    /**\n     * Add `tag` to the payload to allow pubSubSaga to match\n     * it with the Call namespace\n     */\n    const payloadWithTag = {\n      // @ts-expect-error\n      tag: instance.tag,\n      ...action.payload,\n    }\n\n    /**\n     * Dispatch public events for each connect_state\n     */\n    yield sagaEffects.put(pubSubChannel, {\n      type: `calling.connect.${action.payload.connect_state}`,\n      payload: payloadWithTag,\n    })\n\n    switch (action.payload.connect_state) {\n      case 'connected': {\n        /**\n         * Update the Call object payload with the new state\n         */\n        yield sagaEffects.put(pubSubChannel, {\n          type: 'calling.call.state',\n          payload: {\n            call_id: instance.callId,\n            call_state: instance.state,\n            context: instance.context,\n            tag: instance.tag,\n            direction: instance.direction,\n            device: instance.device,\n            node_id: instance.nodeId,\n            peer: action.payload.peer,\n          },\n        })\n        break\n      }\n      case 'disconnected':\n      case 'failed': {\n        done()\n        break\n      }\n    }\n  }\n\n  getLogger().trace('voiceCallConnectWorker ended')\n}\n", "import {\n  getLogger,\n  sagaEffects,\n  SagaIterator,\n  SDKWorker,\n  SDKActions,\n  MapToPubSubShape,\n  CallingCallDialEvent,\n  SDKWorkerHooks,\n  ToExternalJSONResult,\n  CallingCallDialFailedEventParams,\n  toExternalJSON,\n} from '@signalwire/core'\nimport type { Call } from '../Call'\n\nconst TARGET_DIAL_STATES: CallingCallDialEvent['params']['dial_state'][] = [\n  'answered',\n  'failed',\n]\n\ntype VoiceCallDialWorkerOnDone = (args: Call) => void\ntype VoiceCallDialWorkerOnFail = (\n  args: ToExternalJSONResult<CallingCallDialFailedEventParams>\n) => void\n\nexport type VoiceCallDialWorkerHooks = SDKWorkerHooks<\n  VoiceCallDialWorkerOnDone,\n  VoiceCallDialWorkerOnFail\n>\n\nexport const voiceCallDialWorker: SDKWorker<Call, VoiceCallDialWorkerHooks> =\n  function* (options): SagaIterator {\n    const { channels, instance, onDone, onFail } = options\n    const { swEventChannel } = channels\n    getLogger().trace('voiceCallDialWorker started')\n\n    const action: MapToPubSubShape<CallingCallDialEvent> =\n      yield sagaEffects.take(swEventChannel, (action: SDKActions) => {\n        if (\n          action.type === 'calling.call.dial' &&\n          TARGET_DIAL_STATES.includes(action.payload.dial_state)\n        ) {\n          return instance.tag === action.payload.tag\n        }\n        return false\n      })\n\n    if (action.payload.dial_state === 'answered') {\n      onDone?.(instance)\n    } else if (action.payload.dial_state === 'failed') {\n      onFail?.(toExternalJSON(action.payload))\n    } else {\n      throw new Error('[voiceCallDialWorker] unhandled call_state')\n    }\n\n    getLogger().trace('voiceCallDialWorker ended')\n  }\n", "import {\n  getLogger,\n  sagaEffects,\n  SagaIterator,\n  SDKWorker,\n  SDKActions,\n  MapToPubSubShape,\n  CallingCallSendDigitsEvent,\n  SDKWorkerHooks,\n} from '@signalwire/core'\nimport type { Call } from '../Call'\n\nconst TARGET_STATES: CallingCallSendDigitsEvent['params']['state'][] = [\n  'finished',\n]\n\ntype VoiceCallSendDigitsWorkerOnDone = (args: Call) => void\ntype VoiceCallSendDigitsWorkerOnFail = (args: { error: Error }) => void\n\nexport type VoiceCallSendDigitsWorkerHooks = SDKWorkerHooks<\n  VoiceCallSendDigitsWorkerOnDone,\n  VoiceCallSendDigitsWorkerOnFail\n>\n\nexport const voiceCallSendDigitsWorker: SDKWorker<\n  Call,\n  VoiceCallSendDigitsWorkerHooks\n> = function* (options): SagaIterator {\n  getLogger().trace('voiceCallSendDigitsWorker started')\n  const { channels, onDone, onFail, initialState = {}, instance } = options\n  const { swEventChannel } = channels\n  const { controlId } = initialState\n\n  if (!controlId) {\n    throw new Error('Missing controlId for sendDigits')\n  }\n\n  const action: MapToPubSubShape<CallingCallSendDigitsEvent> =\n    yield sagaEffects.take(swEventChannel, (action: SDKActions) => {\n      if (\n        action.type === 'calling.call.send_digits' &&\n        TARGET_STATES.includes(action.payload.state)\n      ) {\n        return action.payload.control_id === controlId\n      }\n      return false\n    })\n\n  if (action.payload.state === 'finished') {\n    onDone?.(instance)\n  } else {\n    const error = new Error(\n      `[voiceCallSendDigitsWorker] unhandled state: '${action.payload.state}'`\n    )\n    if (typeof onFail === 'function') {\n      onFail({ error })\n    } else {\n      throw error\n    }\n  }\n\n  getLogger().trace('voiceCallSendDigitsWorker ended')\n}\n", "import {\n  getLogger,\n  sagaEffects,\n  SagaIterator,\n  SDKWorker,\n  SDKActions,\n  CallingCallDetectEvent,\n  MapToPubSubShape,\n} from '@signalwire/core'\nimport { callingDetectTriggerEvent } from '../Call'\nimport type { Call } from '../Call'\n\nexport const voiceCallDetectWorker: SDKWorker<Call> = function* (\n  options\n): SagaIterator {\n  getLogger().trace('voiceCallDetectWorker started')\n  const { channels, instance, initialState } = options\n  const { swEventChannel, pubSubChannel } = channels\n  const { controlId, waitForBeep = false } = initialState\n  if (!controlId) {\n    throw new Error('Missing controlId for tapping')\n  }\n\n  let waitingForReady = false\n  let run = true\n  let lastAction!: MapToPubSubShape<CallingCallDetectEvent>\n  const done = () => (run = false)\n\n  while (run) {\n    const action: MapToPubSubShape<CallingCallDetectEvent> =\n      yield sagaEffects.take(swEventChannel, (action: SDKActions) => {\n        return (\n          action.type === 'calling.call.detect' &&\n          action.payload.control_id === controlId\n        )\n      })\n\n    const { detect } = action.payload\n    if (!detect) {\n      // Ignore events without detect and (also) make TS happy\n      continue\n    }\n    lastAction = action\n\n    /** Add `tag` to the payload to allow pubSubSaga to match it with the Call namespace */\n    const payloadWithTag = {\n      tag: instance.tag,\n      ...action.payload,\n    }\n\n    /**\n     * Update the original CallDetect object using the transform pipeline\n     */\n    yield sagaEffects.put(pubSubChannel, {\n      // @ts-ignore\n      type: callingDetectTriggerEvent,\n      // @ts-ignore\n      payload: payloadWithTag,\n    })\n\n    const {\n      type,\n      params: { event },\n    } = detect\n\n    if (event === 'error' || event === 'finished') {\n      yield sagaEffects.put(pubSubChannel, {\n        type: 'calling.detect.ended',\n        payload: payloadWithTag,\n      })\n\n      done()\n      continue\n    }\n\n    yield sagaEffects.put(pubSubChannel, {\n      type: 'calling.detect.updated',\n      payload: payloadWithTag,\n    })\n\n    switch (type) {\n      // case 'digit':\n      // case 'fax': {\n      //   break\n      // }\n      case 'machine': {\n        if (waitingForReady && event === 'READY') {\n          yield sagaEffects.put(pubSubChannel, {\n            type: 'calling.detect.ended',\n            payload: payloadWithTag,\n          })\n\n          done()\n        }\n        if (waitForBeep) {\n          waitingForReady = true\n        }\n        break\n      }\n    }\n  }\n\n  if (lastAction) {\n    /**\n     * On endef, dispatch an event to resolve `ended` in CallDetect\n     * overriding the `tag` to be the controlId\n     */\n    yield sagaEffects.put(pubSubChannel, {\n      type: 'calling.detect.ended',\n      payload: {\n        ...lastAction.payload,\n        tag: controlId,\n      },\n    })\n  }\n\n  getLogger().trace('voiceCallDetectWorker ended')\n}\n", "import {\n  connect,\n  BaseComponent,\n  BaseComponentOptions,\n  VoiceCallPlaybackContract,\n  CallingCallPlayState,\n} from '@signalwire/core'\n\n/**\n * Instances of this class allow you to control (e.g., pause, resume, stop) the\n * playback inside a Voice Call. You can obtain instances of this class by\n * starting a playback from the desired {@link Call} (see\n * {@link Call.play})\n */\nexport interface CallPlayback extends VoiceCallPlaybackContract {}\n\n// export type CallPlaybackEventsHandlerMapping = Record<\n//   VideoPlaybackEventNames,\n//   (playback: CallPlayback) => void\n// >\nexport type CallPlaybackEventsHandlerMapping = {}\n\nexport interface CallPlaybackOptions\n  extends BaseComponentOptions<CallPlaybackEventsHandlerMapping> {}\n\nexport class CallPlaybackAPI\n  extends BaseComponent<CallPlaybackEventsHandlerMapping>\n  implements VoiceCallPlaybackContract\n{\n  protected _eventsPrefix = 'calling' as const\n\n  callId: string\n  nodeId: string\n  controlId: string\n  state: CallingCallPlayState = 'playing'\n  private _volume: number\n\n  get id() {\n    return this.controlId\n  }\n\n  get volume() {\n    return this._volume\n  }\n\n  async pause() {\n    await this.execute({\n      method: 'calling.play.pause',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n      },\n    })\n\n    return this\n  }\n\n  async resume() {\n    await this.execute({\n      method: 'calling.play.resume',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n      },\n    })\n\n    return this\n  }\n\n  async stop() {\n    await this.execute({\n      method: 'calling.play.stop',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n      },\n    })\n\n    return this\n  }\n\n  async setVolume(volume: number) {\n    this._volume = volume\n\n    await this.execute({\n      method: 'calling.play.volume',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n        volume,\n      },\n    })\n\n    return this\n  }\n\n  /** @deprecated */\n  waitForEnded() {\n    return this.ended()\n  }\n\n  ended() {\n    return new Promise<this>((resolve) => {\n      this._attachListeners(this.controlId)\n\n      const handler = () => {\n        // It's important to notice that we're returning\n        // `this` instead of creating a brand new instance\n        // using the payload + EventEmitter Transform\n        // pipeline. `this` is the instance created by the\n        // `Call` Emitter Transform pipeline (singleton per\n        // `Call.play()`) that gets auto updated (using\n        // the latest payload per event) by the\n        // `voiceCallPlayWorker`\n        resolve(this)\n      }\n      // @ts-expect-error\n      this.once('playback.ended', handler)\n      // // @ts-expect-error\n      // this.on('prompt.failed', handler)\n    })\n  }\n}\n\nexport const createCallPlaybackObject = (\n  params: CallPlaybackOptions\n): CallPlayback => {\n  const playback = connect<\n    CallPlaybackEventsHandlerMapping,\n    CallPlaybackAPI,\n    CallPlayback\n  >({\n    store: params.store,\n    Component: CallPlaybackAPI,\n    componentListeners: {\n      errors: 'onError',\n      responses: 'onSuccess',\n    },\n  })(params)\n\n  return playback\n}\n", "import {\n  connect,\n  BaseComponent,\n  BaseComponentOptions,\n  VoiceCallRecordingContract,\n  CallingCallRecordState,\n} from '@signalwire/core'\n\n/**\n * Instances of this class allow you to control (e.g., resume) the\n * recording inside a Voice Call. You can obtain instances of this class by\n * starting a recording from the desired {@link Call} (see\n * {@link Call.record})\n */\nexport interface CallRecording extends VoiceCallRecordingContract {}\n\nexport type CallRecordingEventsHandlerMapping = {}\n\nexport interface CallRecordingOptions\n  extends BaseComponentOptions<CallRecordingEventsHandlerMapping> {}\n\nexport class CallRecordingAPI\n  extends BaseComponent<CallRecordingEventsHandlerMapping>\n  implements VoiceCallRecordingContract\n{\n  protected _eventsPrefix = 'calling' as const\n\n  callId: string\n  nodeId: string\n  controlId: string\n  state: CallingCallRecordState = 'recording'\n\n  get id() {\n    return this.controlId\n  }\n\n  async stop() {\n    await this.execute({\n      method: 'calling.record.stop',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n      },\n    })\n\n    /**\n     * TODO: we should wait for the recording `finished` event to allow\n     * the CallRecording/Proxy object to update the payload properly\n     */\n\n    return this\n  }\n\n  ended() {\n    return new Promise<this>((resolve) => {\n      this._attachListeners(this.controlId)\n      const handler = () => {\n        // @ts-expect-error\n        this.off('recording.ended', handler)\n        // @ts-expect-error\n        this.off('recording.failed', handler)\n        // It's important to notice that we're returning\n        // `this` instead of creating a brand new instance\n        // using the payload + EventEmitter Transform\n        // pipeline. `this` is the instance created by the\n        // `Call` Emitter Transform pipeline (singleton per\n        // `Call.record()`) that gets auto updated (using\n        // the latest payload per event) by the\n        // `voiceCallRecordWorker`\n        resolve(this)\n      }\n      // @ts-expect-error\n      this.once('recording.ended', handler)\n      // TODO: review what else to return when `recording.failed` happens.\n      // @ts-expect-error\n      this.once('recording.failed', handler)\n    })\n  }\n}\n\nexport const createCallRecordingObject = (\n  params: CallRecordingOptions\n): CallRecording => {\n  const record = connect<\n    CallRecordingEventsHandlerMapping,\n    CallRecordingAPI,\n    CallRecording\n  >({\n    store: params.store,\n    Component: CallRecordingAPI,\n    componentListeners: {\n      errors: 'onError',\n      responses: 'onSuccess',\n    },\n  })(params)\n\n  return record\n}\n", "import {\n  connect,\n  BaseComponentOptions,\n  VoiceCallPromptContract,\n  CallingCallCollectResult,\n  BaseComponent,\n  CallPromptEndedEvent,\n} from '@signalwire/core'\n\n/**\n * Instances of this class allow you to control (e.g., resume) the\n * prompt inside a Voice Call. You can obtain instances of this class by\n * starting a Prompt from the desired {@link Call} (see\n * {@link Call.prompt})\n */\nexport interface CallPrompt extends VoiceCallPromptContract {}\n\nexport type CallPromptEventsHandlerMapping = {}\n\nexport interface CallPromptOptions\n  extends BaseComponentOptions<CallPromptEventsHandlerMapping> {}\n\nexport class CallPromptAPI\n  extends BaseComponent<CallPromptEventsHandlerMapping>\n  implements VoiceCallPromptContract\n{\n  protected _eventsPrefix = 'calling' as const\n\n  callId: string\n  nodeId: string\n  controlId: string\n  result?: CallingCallCollectResult\n\n  get id() {\n    return this.controlId\n  }\n\n  get type() {\n    return this.result?.type\n  }\n\n  /**\n   * User-friendly alias to understand the reason in case of errors\n   * no_match | no_input | error\n   */\n  get reason() {\n    return this.type\n  }\n\n  get digits() {\n    if (this.result?.type === 'digit') {\n      return this.result.params.digits\n    }\n    return undefined\n  }\n\n  get terminator() {\n    if (this.result?.type === 'digit') {\n      return this.result.params.terminator\n    }\n    return undefined\n  }\n\n  get text() {\n    if (this.result?.type === 'speech') {\n      return this.result.params.text\n    }\n    return undefined\n  }\n\n  get confidence() {\n    if (this.result?.type === 'speech') {\n      return this.result.params.confidence\n    }\n    return undefined\n  }\n\n  async stop() {\n    // Execute stop only if we don't have result yet\n    if (!this.result) {\n      await this.execute({\n        method: 'calling.play_and_collect.stop',\n        params: {\n          node_id: this.nodeId,\n          call_id: this.callId,\n          control_id: this.controlId,\n        },\n      })\n    }\n\n    /**\n     * TODO: we should wait for the prompt to be finished to allow\n     * the CallPrompt/Proxy object to update the payload properly\n     */\n\n    return this\n  }\n\n  async setVolume(volume: number): Promise<this> {\n    await this.execute({\n      method: 'calling.play_and_collect.volume',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n        volume,\n      },\n    })\n\n    return this\n  }\n\n  /** @deprecated */\n  waitForResult() {\n    return this.ended()\n  }\n\n  ended() {\n    return new Promise<this>((resolve) => {\n      this._attachListeners(this.controlId)\n      const handler = (_callPrompt: CallPromptEndedEvent['params']) => {\n        // @ts-expect-error\n        this.off('prompt.ended', handler)\n        // @ts-expect-error\n        this.off('prompt.failed', handler)\n        // It's important to notice that we're returning\n        // `this` instead of creating a brand new instance\n        // using the payload + EventEmitter Transform\n        // pipeline. `this` is the instance created by the\n        // `Call` Emitter Transform pipeline (singleton per\n        // `Call.prompt()`) that gets auto updated (using\n        // the latest payload per event) by the\n        // `voiceCallPromptWorker`\n        resolve(this)\n      }\n      // @ts-expect-error\n      this.once('prompt.ended', handler)\n      // @ts-expect-error\n      this.once('prompt.failed', handler)\n    })\n  }\n}\n\nexport const createCallPromptObject = (\n  params: CallPromptOptions\n): CallPrompt => {\n  const record = connect<\n    CallPromptEventsHandlerMapping,\n    CallPromptAPI,\n    CallPrompt\n  >({\n    store: params.store,\n    Component: CallPromptAPI,\n    componentListeners: {\n      errors: 'onError',\n      responses: 'onSuccess',\n    },\n  })(params)\n\n  return record\n}\n", "import {\n  connect,\n  BaseComponent,\n  BaseComponentOptions,\n  VoiceCallTapContract,\n  CallingCallTapState,\n} from '@signalwire/core'\n\n/**\n * Instances of this class allow you to control (e.g., resume) the\n * tap inside a Voice Call. You can obtain instances of this class by\n * starting a Tap from the desired {@link Call} (see\n * {@link Call.tap})\n */\nexport interface CallTap extends VoiceCallTapContract {}\n\nexport type CallTapEventsHandlerMapping = {}\n\nexport interface CallTapOptions\n  extends BaseComponentOptions<CallTapEventsHandlerMapping> {}\n\nexport class CallTapAPI\n  extends BaseComponent<CallTapEventsHandlerMapping>\n  implements VoiceCallTapContract\n{\n  callId: string\n  nodeId: string\n  controlId: string\n  state: CallingCallTapState\n\n  get id() {\n    return this.controlId\n  }\n\n  async stop() {\n    if (this.state !== 'finished') {\n      await this.execute({\n        method: 'calling.tap.stop',\n        params: {\n          node_id: this.nodeId,\n          call_id: this.callId,\n          control_id: this.controlId,\n        },\n      })\n    }\n\n    return this\n  }\n\n  ended() {\n    return new Promise<this>((resolve) => {\n      this._attachListeners(this.controlId)\n\n      const handler = () => {\n        // It's important to notice that we're returning\n        // `this` instead of creating a brand new instance\n        // using the payload + EventEmitter Transform\n        // pipeline. `this` is the instance created by the\n        // `Call` Emitter Transform pipeline (singleton per\n        // `Call.tap()`) that gets auto updated (using\n        // the latest payload per event) by the\n        // `voiceCallTapWorker`\n        resolve(this)\n      }\n      // @ts-expect-error\n      this.once('tap.ended', handler)\n    })\n  }\n}\n\nexport const createCallTapObject = (params: CallTapOptions): CallTap => {\n  const tap = connect<CallTapEventsHandlerMapping, CallTapAPI, CallTap>({\n    store: params.store,\n    Component: CallTapAPI,\n    componentListeners: {\n      errors: 'onError',\n      responses: 'onSuccess',\n    },\n  })(params)\n\n  return tap\n}\n", "import {\n  connect,\n  BaseComponent,\n  BaseComponentOptions,\n  VoiceCallDetectContract,\n  Detector,\n} from '@signalwire/core'\n\n/**\n * Instances of this class allow you to control (e.g., resume) the\n * detect inside a Voice Call. You can obtain instances of this class by\n * starting a Detect from the desired {@link Call} (see\n * {@link Call.detect})\n */\nexport interface CallDetect extends VoiceCallDetectContract {}\n\nexport type CallDetectEventsHandlerMapping = {}\n\nexport interface CallDetectOptions\n  extends BaseComponentOptions<CallDetectEventsHandlerMapping> {}\n\nexport class CallDetectAPI\n  extends BaseComponent<CallDetectEventsHandlerMapping>\n  implements VoiceCallDetectContract\n{\n  protected _eventsPrefix = 'calling' as const\n\n  callId: string\n  nodeId: string\n  controlId: string\n  detect?: Detector\n\n  get id() {\n    return this.controlId\n  }\n\n  get type() {\n    return this?.detect?.type\n  }\n\n  async stop() {\n    // if (this.state !== 'finished') {\n    await this.execute({\n      method: 'calling.detect.stop',\n      params: {\n        node_id: this.nodeId,\n        call_id: this.callId,\n        control_id: this.controlId,\n      },\n    })\n    // }\n\n    return this\n  }\n\n  /** @deprecated */\n  waitForResult() {\n    return this.ended()\n  }\n\n  ended() {\n    return new Promise<this>((resolve) => {\n      this._attachListeners(this.controlId)\n\n      // @ts-expect-error\n      this.once('detect.ended', () => {\n        // It's important to notice that we're returning\n        // `this` instead of creating a brand new instance\n        // using the payload + EventEmitter Transform\n        // pipeline. `this` is the instance created by the\n        // `Call` Emitter Transform pipeline (singleton per\n        // `Call.detect()`) that gets auto updated (using\n        // the latest payload per event) by the\n        // `voiceCallDetectWorker`\n        resolve(this)\n      })\n    })\n  }\n}\n\nexport const createCallDetectObject = (\n  params: CallDetectOptions\n): CallDetect => {\n  const detect = connect<\n    CallDetectEventsHandlerMapping,\n    CallDetectAPI,\n    CallDetect\n  >({\n    store: params.store,\n    Component: CallDetectAPI,\n    componentListeners: {\n      errors: 'onError',\n      responses: 'onSuccess',\n    },\n  })(params)\n\n  return detect\n}\n", "import type {\n  VoiceDeviceBuilder,\n  VoiceCallDeviceParams,\n  VoiceCallPhoneParams,\n  VoiceCallDialPhoneMethodParams,\n  VoiceCallSipParams,\n  VoiceCallDialSipMethodParams,\n} from '@signalwire/core'\n\n/**\n * A DeviceBuilder object allows you to specify a set of devices which should be\n * dialed in sequence or parallel. You can then pass the device plan to the\n * methods that support it, for example {@link Call.connect}.\n *\n * @example\n *\n * Creates a plan which specifies to dial a SIP endpoint. If there is no answer\n * within 30 seconds, calls two phone numbers in parallel (as indicated by the\n * array syntax). As soon as one of the two answers, the operation is\n * considered successful.\n *\n * ```js\n * const plan = new Voice.DeviceBuilder()\n *   .add(Voice.DeviceBuilder.Sip({\n *     from: 'sip:user1@domain.com',\n *     to: 'sip:user2@domain.com',\n *     timeout: 30,\n *   }))\n *   .add([\n *     Voice.DeviceBuilder.Phone({ to: '+yyyyyy', timeout: 30 }),\n *     Voice.DeviceBuilder.Phone({ to: '+zzzzzz', timeout: 30 })\n *   ])\n * ```\n */\nexport class DeviceBuilder implements VoiceDeviceBuilder {\n  private _devices: VoiceDeviceBuilder['devices'] = []\n\n  get devices() {\n    return this._devices\n  }\n\n  add(params: VoiceCallDeviceParams | VoiceCallDeviceParams[]) {\n    if (Array.isArray(params)) {\n      this._devices.push(params)\n    } else {\n      this._devices.push([params])\n    }\n\n    return this\n  }\n\n  static Phone(params: VoiceCallDialPhoneMethodParams): VoiceCallPhoneParams {\n    return { type: 'phone', ...params }\n  }\n\n  static Sip(params: VoiceCallDialSipMethodParams): VoiceCallSipParams {\n    return { type: 'sip', ...params }\n  }\n}\n", "import type { UserOptions } from '@signalwire/core'\nimport { setupClient, clientConnect } from '../client/index'\nimport { createCallObject, Call } from './Call'\nimport { createVoiceObject, Voice } from './Voice'\nimport { clientContextInterceptorsFactory } from '../common/clientContext'\n\ninterface VoiceClient extends Voice {\n  new (opts: VoiceClientOptions): this\n}\n\nexport interface VoiceClientOptions\n  extends Omit<UserOptions, '_onRefreshToken'> {\n  contexts: string[]\n}\n\n/**\n * You can use instances of this class to initiate or receive calls. Please see\n * {@link VoiceClientApiEvents} for the full list of events you can subscribe to.\n *\n * @params options - {@link VoiceClientOptions}\n *\n * @example\n *\n * The following example answers any call in the \"office\" context.\n *\n * ```javascript\n * const client = new Voice.Client({\n *   project: \"<project-id>\",\n *   token: \"<api-token>\",\n *   contexts: ['office']\n * })\n *\n * client.on('call.received', async (call) => {\n *   console.log('Got call', call.from, call.to)\n *\n *   try {\n *     await call.answer()\n *     console.log('Inbound call answered')\n *   } catch (error) {\n *     console.error('Error answering inbound call', error)\n *   }\n * })\n * ```\n *\n * @example\n *\n * The following example initiates a new call.\n *\n * ```javascript\n * const client = new Voice.Client({\n *   project: \"<project-id>\",\n *   token: \"<api-token>\",\n *   contexts: ['office']\n * })\n *\n * try {\n *   const call = await client.dialPhone({\n *     from: '+YYYYYYYYYY',\n *     to: '+XXXXXXXXXX',\n *     timeout: 30,\n *   })\n * } catch (e) {\n *   console.log(\"Call not answered.\")\n * }\n * ```\n */\nconst VoiceClient = function (options?: VoiceClientOptions) {\n  const { client, store, emitter } = setupClient(options)\n\n  const voice = createVoiceObject({\n    store,\n    emitter,\n    ...options,\n  })\n\n  const callDial: Call['dial'] = async (dialer) => {\n    await clientConnect(client)\n\n    const call = createCallObject({\n      store,\n      emitter,\n    })\n\n    await call.dial(dialer)\n\n    return call\n  }\n  const disconnect = () => client.disconnect()\n\n  const interceptors = {\n    ...clientContextInterceptorsFactory(client),\n    dial: callDial,\n    _session: client,\n    disconnect,\n  } as const\n\n  return new Proxy<Omit<Voice, 'new'>>(voice, {\n    get(target: Voice, prop: keyof Voice, receiver: any) {\n      if (prop in interceptors) {\n        // @ts-expect-error\n        return interceptors[prop]\n      }\n\n      // Always connect the underlying client if the user call a function on the Proxy\n      if (typeof target[prop] === 'function') {\n        clientConnect(client)\n      }\n\n      return Reflect.get(target, prop, receiver)\n    },\n  })\n  // For consistency with other constructors we'll make TS force the use of `new`\n} as unknown as { new (options?: VoiceClientOptions): VoiceClient }\n\nexport { VoiceClient as Client }\n"],
  "mappings": "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",
  "names": []
}
