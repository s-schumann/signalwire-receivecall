var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/video/Video.ts
var Video_exports = {};
__export(Video_exports, {
  Client: () => VideoClient,
  createVideoObject: () => createVideoObject
});
import {
  connect as connect4,
  toExternalJSON as toExternalJSON2,
  toLocalEvent as toLocalEvent2
} from "@signalwire/core";

// src/AutoSubscribeConsumer.ts
import {
  BaseConsumer,
  debounce
} from "@signalwire/core";
var AutoSubscribeConsumer = class extends BaseConsumer {
  constructor(options) {
    super(options);
    __publicField(this, "debouncedSubscribe");
    this.debouncedSubscribe = debounce(this.subscribe, 100);
  }
  on(event, fn) {
    const instance = super.on(event, fn);
    this.debouncedSubscribe();
    return instance;
  }
  once(event, fn) {
    const instance = super.once(event, fn);
    this.debouncedSubscribe();
    return instance;
  }
};

// src/video/RoomSession.ts
import {
  connect as connect2,
  extendComponent as extendComponent2,
  INTERNAL_MEMBER_UPDATED_EVENTS,
  Rooms as Rooms2,
  toExternalJSON,
  toLocalEvent,
  BaseConsumer as BaseConsumer2,
  MemberPosition as MemberPosition2,
  debounce as debounce2
} from "@signalwire/core";

// src/video/RoomSessionMember.ts
import {
  connect,
  BaseComponent,
  extendComponent,
  Rooms
} from "@signalwire/core";
var RoomSessionMemberComponent = class extends BaseComponent {
  async remove() {
    await this.execute({
      method: "video.member.remove",
      params: {
        room_session_id: this.getStateProperty("roomSessionId"),
        member_id: this.getStateProperty("memberId")
      }
    });
  }
};
var RoomSessionMemberAPI = extendComponent(RoomSessionMemberComponent, {
  audioMute: Rooms.audioMuteMember,
  audioUnmute: Rooms.audioUnmuteMember,
  videoMute: Rooms.videoMuteMember,
  videoUnmute: Rooms.videoUnmuteMember,
  setDeaf: Rooms.setDeaf,
  setMicrophoneVolume: Rooms.setInputVolumeMember,
  setInputVolume: Rooms.setInputVolumeMember,
  setSpeakerVolume: Rooms.setOutputVolumeMember,
  setOutputVolume: Rooms.setOutputVolumeMember,
  setInputSensitivity: Rooms.setInputSensitivityMember
});
var createRoomSessionMemberObject = (params) => {
  const member = connect({
    store: params.store,
    Component: RoomSessionMemberAPI,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(params);
  return member;
};

// src/video/memberPosition/workers.ts
import {
  sagaEffects,
  MemberPosition,
  findNamespaceInPayload
} from "@signalwire/core";
var memberPositionWorker = function* memberPositionWorker2(options) {
  const { instance, channels } = options;
  const { swEventChannel } = channels;
  const action = yield sagaEffects.take(swEventChannel, (action2) => {
    const istargetEvent = action2.type === "video.room.subscribed";
    return istargetEvent && findNamespaceInPayload(action2) === instance._eventsNamespace;
  });
  yield sagaEffects.fork(MemberPosition.memberPositionWorker, __spreadProps(__spreadValues({}, options), {
    initialState: action.payload
  }));
};

// src/video/RoomSession.ts
var RoomSessionConsumer = class extends BaseConsumer2 {
  constructor(options) {
    super(options);
    __publicField(this, "_eventsPrefix", "video");
    __publicField(this, "subscribeParams", {
      get_initial_state: true
    });
    __publicField(this, "debouncedSubscribe");
    this.debouncedSubscribe = debounce2(this.subscribe, 100);
    this.runWorker("memberPositionWorker", {
      worker: memberPositionWorker
    });
  }
  _internal_on(event, fn) {
    return super.on(event, fn);
  }
  on(event, fn) {
    const instance = super.on(event, fn);
    this.debouncedSubscribe();
    return instance;
  }
  once(event, fn) {
    const instance = super.once(event, fn);
    this.debouncedSubscribe();
    return instance;
  }
  subscribe() {
    return new Promise(async (resolve, reject) => {
      const handler = (payload) => {
        resolve(payload);
      };
      const subscriptions = this.getSubscriptions();
      if (subscriptions.length === 0) {
        this.logger.debug("`subscribe()` was called without any listeners attached.");
        return;
      }
      try {
        super.once("room.subscribed", handler);
        await super.subscribe();
      } catch (error) {
        super.off("room.subscribed", handler);
        return reject(error);
      }
    });
  }
  getCompoundEvents() {
    return new Map([
      ...MemberPosition2.MEMBER_POSITION_COMPOUND_EVENTS
    ]);
  }
  getEmitterTransforms() {
    return /* @__PURE__ */ new Map([
      [
        "video.room.subscribed",
        {
          type: "roomSessionSubscribed",
          instanceFactory: () => {
            return this;
          },
          payloadTransform: (payload) => {
            return toExternalJSON(payload.room_session);
          },
          nestedFieldsToProcess: {
            members: {
              eventTransformType: "roomSessionMember",
              processInstancePayload: (payload) => {
                return {
                  room_session_id: this.getStateProperty("roomSessionId"),
                  member: payload
                };
              }
            },
            recordings: {
              eventTransformType: "roomSessionRecording",
              processInstancePayload: (payload) => {
                return {
                  room_session_id: this.getStateProperty("roomSessionId"),
                  recording: payload
                };
              }
            },
            streams: {
              eventTransformType: "roomSessionStream",
              processInstancePayload: (payload) => {
                return {
                  room_session_id: this.getStateProperty("roomSessionId"),
                  stream: payload
                };
              }
            }
          },
          getInstanceEventNamespace: (payload) => {
            return payload.room_session.id;
          },
          getInstanceEventChannel: (payload) => {
            return payload.room_session.event_channel;
          }
        }
      ],
      [
        [toLocalEvent("video.recording.list")],
        {
          type: "roomSessionRecordingList",
          instanceFactory: (_payload) => {
            return {};
          },
          payloadTransform: (payload) => {
            return payload;
          },
          nestedFieldsToProcess: {
            recordings: {
              eventTransformType: "roomSessionRecording",
              processInstancePayload: (payload) => {
                return {
                  room_session_id: this.getStateProperty("roomSessionId"),
                  recording: payload
                };
              }
            }
          }
        }
      ],
      [
        [toLocalEvent("video.playback.list")],
        {
          type: "roomSessionPlaybackList",
          instanceFactory: (_payload) => {
            return {};
          },
          payloadTransform: (payload) => {
            return payload;
          },
          nestedFieldsToProcess: {
            playbacks: {
              eventTransformType: "roomSessionPlayback",
              processInstancePayload: (payload) => {
                return {
                  room_session_id: this.getStateProperty("roomSessionId"),
                  playback: payload
                };
              }
            }
          }
        }
      ],
      [
        "video.room.updated",
        {
          type: "roomSession",
          instanceFactory: () => {
            return this;
          },
          payloadTransform: (payload) => {
            return toExternalJSON(__spreadProps(__spreadValues({}, payload.room_session), {
              room_session_id: payload.room_session.id
            }));
          },
          getInstanceEventNamespace: (payload) => {
            return payload.room_session.id;
          },
          getInstanceEventChannel: (payload) => {
            return payload.room_session.event_channel;
          }
        }
      ],
      [
        "video.layout.changed",
        {
          type: "roomSessionLayout",
          instanceFactory: () => {
            return {};
          },
          payloadTransform: (payload) => {
            return toExternalJSON(payload.layout);
          }
        }
      ],
      [
        [
          "video.member.joined",
          "video.member.left",
          "video.member.talking",
          "video.member.talking.start",
          "video.member.talking.started",
          "video.member.talking.stop",
          "video.member.talking.ended",
          "video.member.updated",
          ...INTERNAL_MEMBER_UPDATED_EVENTS
        ],
        {
          type: "roomSessionMember",
          instanceFactory: (_payload) => {
            return createRoomSessionMemberObject({
              store: this.store,
              emitter: this.options.emitter
            });
          },
          payloadTransform: (payload) => {
            return toExternalJSON(__spreadProps(__spreadValues({}, payload.member), {
              member_id: payload.member.id
            }));
          }
        }
      ],
      [
        [
          toLocalEvent("video.recording.start"),
          "video.recording.started",
          "video.recording.updated",
          "video.recording.ended"
        ],
        {
          type: "roomSessionRecording",
          instanceFactory: (_payload) => {
            return Rooms2.createRoomSessionRecordingObject({
              store: this.store,
              emitter: this.emitter
            });
          },
          payloadTransform: (payload) => {
            return toExternalJSON(__spreadProps(__spreadValues({}, payload.recording), {
              room_session_id: payload.room_session_id
            }));
          }
        }
      ],
      [
        [
          toLocalEvent("video.playback.start"),
          "video.playback.started",
          "video.playback.updated",
          "video.playback.ended"
        ],
        {
          type: "roomSessionPlayback",
          instanceFactory: (_payload) => {
            return Rooms2.createRoomSessionPlaybackObject({
              store: this.store,
              emitter: this.emitter
            });
          },
          payloadTransform: (payload) => {
            return toExternalJSON(__spreadProps(__spreadValues({}, payload.playback), {
              room_session_id: payload.room_session_id
            }));
          }
        }
      ],
      [
        ["video.room.audience_count", "video.room.audienceCount"],
        {
          type: "roomSessionAudienceCount",
          instanceFactory: (_payload) => {
            return {};
          },
          payloadTransform: (payload) => {
            return toExternalJSON(payload);
          }
        }
      ],
      [
        [toLocalEvent("video.stream.list")],
        {
          type: "roomSessionStreamList",
          instanceFactory: (_payload) => {
            return {};
          },
          payloadTransform: (payload) => {
            return payload;
          },
          nestedFieldsToProcess: {
            streams: {
              eventTransformType: "roomSessionStream",
              processInstancePayload: (payload) => {
                return {
                  room_session_id: this.getStateProperty("roomSessionId"),
                  stream: payload
                };
              }
            }
          }
        }
      ],
      [
        [
          toLocalEvent("video.stream.start"),
          "video.stream.started",
          "video.stream.ended"
        ],
        {
          type: "roomSessionStream",
          instanceFactory: (_payload) => {
            return Rooms2.createRoomSessionStreamObject({
              store: this.store,
              emitter: this.emitter
            });
          },
          payloadTransform: (payload) => {
            return toExternalJSON(__spreadProps(__spreadValues({}, payload.stream), {
              room_session_id: payload.room_session_id
            }));
          }
        }
      ]
    ]);
  }
};
var RoomSessionAPI = extendComponent2(RoomSessionConsumer, {
  videoMute: Rooms2.videoMuteMember,
  videoUnmute: Rooms2.videoUnmuteMember,
  getMembers: Rooms2.getMembers,
  audioMute: Rooms2.audioMuteMember,
  audioUnmute: Rooms2.audioUnmuteMember,
  deaf: Rooms2.deafMember,
  undeaf: Rooms2.undeafMember,
  setInputVolume: Rooms2.setInputVolumeMember,
  setOutputVolume: Rooms2.setOutputVolumeMember,
  setMicrophoneVolume: Rooms2.setInputVolumeMember,
  setSpeakerVolume: Rooms2.setOutputVolumeMember,
  setInputSensitivity: Rooms2.setInputSensitivityMember,
  removeMember: Rooms2.removeMember,
  removeAllMembers: Rooms2.removeAllMembers,
  setHideVideoMuted: Rooms2.setHideVideoMuted,
  getLayouts: Rooms2.getLayouts,
  setLayout: Rooms2.setLayout,
  setPositions: Rooms2.setPositions,
  setMemberPosition: Rooms2.setMemberPosition,
  getRecordings: Rooms2.getRecordings,
  startRecording: Rooms2.startRecording,
  getPlaybacks: Rooms2.getPlaybacks,
  play: Rooms2.play,
  getMeta: Rooms2.getMeta,
  setMeta: Rooms2.setMeta,
  updateMeta: Rooms2.updateMeta,
  deleteMeta: Rooms2.deleteMeta,
  getMemberMeta: Rooms2.getMemberMeta,
  setMemberMeta: Rooms2.setMemberMeta,
  updateMemberMeta: Rooms2.updateMemberMeta,
  deleteMemberMeta: Rooms2.deleteMemberMeta,
  promote: Rooms2.promote,
  demote: Rooms2.demote,
  getStreams: Rooms2.getStreams,
  startStream: Rooms2.startStream
});
var createRoomSessionObject = (params) => {
  const roomSession = connect2({
    store: params.store,
    Component: RoomSessionAPI,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(params);
  return roomSession;
};

// src/client/Client.ts
import {
  BaseClient as CoreBaseClient
} from "@signalwire/core";
var Client = class extends CoreBaseClient {
};

// src/client/clientConnect.ts
var clientConnect = (client) => {
  return client.connect().catch(() => {
  });
};

// src/client/setupClient.ts
import { getLogger } from "@signalwire/core";

// src/utils/internals.ts
import { configureStore, getEventEmitter } from "@signalwire/core";

// src/configure/index.ts
var GLOBAL_CONFIG = {};
var getConfig = () => {
  return GLOBAL_CONFIG;
};
var config = (_a) => {
  var _b = _a, {
    cache = GLOBAL_CONFIG
  } = _b, options = __objRest(_b, [
    "cache"
  ]);
  if (cache) {
    GLOBAL_CONFIG = cache;
  }
  Object.entries(options).forEach(([key, value]) => {
    GLOBAL_CONFIG[key] = value;
  });
};

// src/Session.ts
import { BaseSession } from "@signalwire/core";
import WebSocket from "ws";
var Session = class extends BaseSession {
  constructor() {
    super(...arguments);
    __publicField(this, "WebSocketConstructor", WebSocket);
    __publicField(this, "agent", "@signalwire/nodejs/realtime-api/3.6.0");
  }
};

// src/utils/internals.ts
var setupInternals = (userOptions) => {
  const emitter = getEventEmitter();
  const baseOptions = __spreadProps(__spreadValues({}, userOptions), {
    emitter
  });
  const store = configureStore({
    userOptions: baseOptions,
    SessionConstructor: Session
  });
  return { store, emitter };
};
var getToken = (userToken) => {
  const globalConfig = getConfig();
  const token = userToken || globalConfig.token || process.env.SW_TOKEN;
  if (!token) {
    throw new Error("Missing `token`");
  }
  return token;
};
var getProject = (userProject) => {
  const globalConfig = getConfig();
  const project = userProject || globalConfig.project || process.env.SW_PROJECT;
  if (!project) {
    throw new Error("Missing `project`");
  }
  return project;
};
var getCredentials = (options) => {
  const project = getProject(options == null ? void 0 : options.project);
  const token = getToken(options == null ? void 0 : options.token);
  return { project, token };
};

// src/client/clientProxyFactory.ts
var defaultInterceptors = {
  connect: clientConnect
};
var clientProxyFactory = (client, interceptors = defaultInterceptors) => {
  const clientConnect2 = interceptors.connect || clientConnect;
  const clientOn = (...args) => {
    clientConnect2(client);
    return client.on(...args);
  };
  const clientOnce = (...args) => {
    clientConnect2(client);
    return client.once(...args);
  };
  return new Proxy(client, {
    get(target, prop, receiver) {
      if (prop === "on") {
        return clientOn;
      } else if (prop === "once") {
        return clientOnce;
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/client/getClient.ts
import {
  connect as connect3
} from "@signalwire/core";
var CLIENTS_MAP = /* @__PURE__ */ new Map();
var createClient = (userOptions) => {
  const client = connect3({
    store: userOptions.store,
    Component: Client,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(userOptions);
  return client;
};
var getClient = (_a) => {
  var _b = _a, {
    cache = CLIENTS_MAP
  } = _b, userOptions = __objRest(_b, [
    "cache"
  ]);
  const { emitter, store } = setupInternals(userOptions);
  const client = createClient(__spreadProps(__spreadValues({}, userOptions), {
    store,
    emitter
  }));
  const config2 = {
    client,
    store,
    emitter
  };
  return config2;
};

// src/client/setupClient.ts
var setupClient = (userOptions) => {
  const credentials = getCredentials({
    token: userOptions == null ? void 0 : userOptions.token,
    project: userOptions == null ? void 0 : userOptions.project
  });
  const { client, store, emitter } = getClient(__spreadValues(__spreadValues({}, userOptions), credentials));
  client.on("session.auth_error", () => {
    getLogger().error("Wrong credentials: couldn't connect the client.");
  });
  const proxiedClient = clientProxyFactory(client);
  return {
    client: proxiedClient,
    store,
    emitter
  };
};

// src/video/VideoClient.ts
var VideoClient = function(options) {
  const { client, store, emitter } = setupClient(options);
  const video = createVideoObject({
    store,
    emitter
  });
  const videoSubscribe = async () => {
    await clientConnect(client);
    return video.subscribe();
  };
  const interceptors = {
    subscribe: videoSubscribe,
    _session: client,
    disconnect: () => client.disconnect()
  };
  return new Proxy(video, {
    get(target, prop, receiver) {
      if (prop in interceptors) {
        return interceptors[prop];
      }
      if (typeof target[prop] === "function") {
        clientConnect(client);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/video/Video.ts
var videoRoomGetTriggerEvent = toLocalEvent2("video.room.get");
var VideoAPI = class extends AutoSubscribeConsumer {
  constructor() {
    super(...arguments);
    __publicField(this, "_eventsPrefix", "video");
    __publicField(this, "subscribeParams", {
      get_initial_state: true
    });
  }
  getEmitterTransforms() {
    return /* @__PURE__ */ new Map([
      [
        [videoRoomGetTriggerEvent, "video.room.started", "video.room.ended"],
        {
          type: "roomSession",
          instanceFactory: () => {
            return createRoomSessionObject({
              store: this.store,
              emitter: this.options.emitter
            });
          },
          payloadTransform: (payload) => {
            return toExternalJSON2(__spreadProps(__spreadValues({}, payload.room_session), {
              room_session_id: payload.room_session.id
            }));
          },
          getInstanceEventNamespace: (payload) => {
            return payload.room_session.id;
          },
          getInstanceEventChannel: (payload) => {
            return payload.room_session.event_channel;
          }
        }
      ]
    ]);
  }
  async getRoomSessions() {
    return new Promise(async (resolve, reject) => {
      try {
        const { rooms = [] } = await this.execute({
          method: "video.rooms.get",
          params: {}
        });
        const roomSessions = [];
        const handler = (instance) => roomSessions.push(instance);
        this.on(videoRoomGetTriggerEvent, handler);
        rooms.forEach((room_session) => {
          this.emit(videoRoomGetTriggerEvent, { room_session });
        });
        resolve({ roomSessions });
      } catch (error) {
        console.error("Error listing room sessions", error);
        reject(error);
      }
    });
  }
  async getRoomSessionById(id) {
    return new Promise(async (resolve, reject) => {
      try {
        const { room } = await this.execute({
          method: "video.room.get",
          params: {
            room_session_id: id
          }
        });
        this.once(videoRoomGetTriggerEvent, (instance) => {
          resolve({ roomSession: instance });
        });
        this.emit(videoRoomGetTriggerEvent, { room_session: room });
      } catch (error) {
        console.error("Error retrieving the room session", error);
        reject(error);
      }
    });
  }
};
var createVideoObject = (params) => {
  const video = connect4({
    store: params.store,
    Component: VideoAPI,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(params);
  const proxy = new Proxy(video, {
    get(target, prop, receiver) {
      if (prop === "_eventsNamespace") {
        return "";
      } else if (prop === "eventChannel") {
        return "video.rooms";
      }
      return Reflect.get(target, prop, receiver);
    }
  });
  return proxy;
};

// src/createClient.ts
import {
  configureStore as configureStore3,
  connect as connect5,
  getEventEmitter as getEventEmitter2
} from "@signalwire/core";

// src/Client.ts
import {
  BaseClient
} from "@signalwire/core";
var Client2 = class extends BaseClient {
  constructor() {
    super(...arguments);
    __publicField(this, "_consumers", /* @__PURE__ */ new Map());
  }
  async onAuth(session) {
    try {
      if (session.authStatus === "authorized") {
        this._consumers.forEach((consumer) => {
          consumer.subscribe();
        });
      }
    } catch (error) {
      this.logger.error("Client subscription failed.");
      this.disconnect();
      throw error;
    }
  }
  get video() {
    if (this._consumers.has("video")) {
      return this._consumers.get("video");
    }
    const video = createVideoObject({
      store: this.store,
      emitter: this.options.emitter
    });
    this._consumers.set("video", video);
    return video;
  }
};

// src/createClient.ts
var createClient2 = async (userOptions) => {
  const baseUserOptions = __spreadProps(__spreadValues({}, userOptions), {
    emitter: getEventEmitter2()
  });
  const store = configureStore3({
    userOptions: baseUserOptions,
    SessionConstructor: Session
  });
  const client = connect5({
    store,
    Component: Client2,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    },
    sessionListeners: {
      authStatus: "onAuth"
    }
  })(baseUserOptions);
  return client;
};

// src/chat/Chat.ts
var Chat_exports = {};
__export(Chat_exports, {
  ChatMember: () => ChatMember,
  ChatMessage: () => ChatMessage,
  Client: () => ChatClient
});
import { ChatMember, ChatMessage } from "@signalwire/core";

// src/chat/ChatClient.ts
import {
  Chat as ChatNamespace
} from "@signalwire/core";
var INTERCEPTED_METHODS = [
  "subscribe",
  "publish",
  "getMessages",
  "getMembers",
  "getMemberState",
  "setMemberState"
];
var UNSUPPORTED_METHODS = ["getAllowedChannels", "updateToken"];
var ChatClient = function(options) {
  const { client, store, emitter } = setupClient(options);
  const chat = ChatNamespace.createBaseChatObject({
    store,
    emitter
  });
  const createInterceptor = (prop) => {
    return async (...params) => {
      await clientConnect(client);
      return chat[prop](...params);
    };
  };
  const interceptors = {
    _session: client,
    disconnect: () => client.disconnect()
  };
  return new Proxy(chat, {
    get(target, prop, receiver) {
      if (prop in interceptors) {
        return interceptors[prop];
      }
      if (prop !== "_session" && INTERCEPTED_METHODS.includes(prop)) {
        return createInterceptor(prop);
      } else if (UNSUPPORTED_METHODS.includes(prop)) {
        return void 0;
      }
      if (typeof target[prop] === "function") {
        clientConnect(client);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/pubSub/PubSub.ts
var PubSub_exports = {};
__export(PubSub_exports, {
  Client: () => PubSubClient,
  PubSubMessage: () => PubSubMessage
});
import { PubSubMessage } from "@signalwire/core";

// src/pubSub/PubSubClient.ts
import {
  PubSub as PubSubNamespace
} from "@signalwire/core";
var INTERCEPTED_METHODS2 = ["subscribe", "publish"];
var UNSUPPORTED_METHODS2 = ["getAllowedChannels", "updateToken"];
var PubSubClient = function(options) {
  const { client, store, emitter } = setupClient(options);
  const pubSub = PubSubNamespace.createBasePubSubObject({
    store,
    emitter
  });
  const createInterceptor = (prop) => {
    return async (...params) => {
      await clientConnect(client);
      return pubSub[prop](...params);
    };
  };
  const interceptors = {
    _session: client,
    disconnect: () => client.disconnect()
  };
  return new Proxy(pubSub, {
    get(target, prop, receiver) {
      if (prop in interceptors) {
        return interceptors[prop];
      }
      if (prop !== "_session" && INTERCEPTED_METHODS2.includes(prop)) {
        return createInterceptor(prop);
      } else if (UNSUPPORTED_METHODS2.includes(prop)) {
        return void 0;
      }
      if (typeof target[prop] === "function") {
        clientConnect(client);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/task/Task.ts
var Task_exports = {};
__export(Task_exports, {
  Client: () => TaskClient,
  createTaskObject: () => createTaskObject,
  send: () => send
});
import {
  BaseComponent as BaseComponent2
} from "@signalwire/core";
import { connect as connect6 } from "@signalwire/core";

// src/task/workers.ts
import {
  getLogger as getLogger2,
  sagaEffects as sagaEffects2
} from "@signalwire/core";
var taskWorker = function* (options) {
  getLogger2().trace("taskWorker started");
  const { channels } = options;
  const { swEventChannel, pubSubChannel } = channels;
  while (true) {
    const action = yield sagaEffects2.take(swEventChannel, (action2) => {
      return action2.type === "queuing.relay.tasks";
    });
    yield sagaEffects2.put(pubSubChannel, {
      type: "task.received",
      payload: action.payload.message
    });
  }
  getLogger2().trace("taskWorker ended");
};

// src/common/clientContext.ts
var clientContextInterceptorsFactory = (client) => {
  return {
    async addContexts(contexts) {
      await clientConnect(client);
      const executeParams = {
        method: "signalwire.receive",
        params: {
          contexts
        }
      };
      return client.execute(executeParams);
    },
    async removeContexts(contexts) {
      await clientConnect(client);
      const executeParams = {
        method: "signalwire.unreceive",
        params: {
          contexts
        }
      };
      return client.execute(executeParams);
    }
  };
};

// src/task/TaskClient.ts
var TaskClient = function(options) {
  const { client, store, emitter } = setupClient(options);
  const task = createTaskObject({
    store,
    emitter
  });
  const disconnect = () => client.disconnect();
  const interceptors = __spreadProps(__spreadValues({}, clientContextInterceptorsFactory(client)), {
    _session: client,
    disconnect
  });
  return new Proxy(task, {
    get(target, prop, receiver) {
      if (prop in interceptors) {
        return interceptors[prop];
      }
      if (typeof target[prop] === "function") {
        clientConnect(client);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/task/send.ts
import { request } from "https";
var PATH = "/api/relay/rest/tasks";
var HOST = "relay.signalwire.com";
var send = ({
  host = HOST,
  project,
  token,
  context,
  message
}) => {
  if (!project || !token) {
    throw new Error("Invalid options: project and token are required!");
  }
  return new Promise((resolve, reject) => {
    try {
      const Authorization = `Basic ${Buffer.from(`${project}:${token}`).toString("base64")}`;
      const data = JSON.stringify({ context, message });
      const options = {
        host,
        port: 443,
        method: "POST",
        path: PATH,
        headers: {
          Authorization,
          "Content-Type": "application/json",
          "Content-Length": data.length
        }
      };
      const req = request(options, ({ statusCode }) => {
        statusCode === 204 ? resolve() : reject();
      });
      req.on("error", reject);
      req.write(data);
      req.end();
    } catch (error) {
      reject(error);
    }
  });
};

// src/task/Task.ts
var TaskAPI = class extends BaseComponent2 {
  constructor(options) {
    super(options);
    this.runWorker("taskWorker", {
      worker: taskWorker
    });
    this._attachListeners("");
  }
};
var createTaskObject = (params) => {
  const task = connect6({
    store: params.store,
    Component: TaskAPI,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(params);
  return task;
};

// src/messaging/Messaging.ts
var Messaging_exports = {};
__export(Messaging_exports, {
  Client: () => MessagingClient,
  Message: () => Message,
  createMessagingObject: () => createMessagingObject
});
import {
  toExternalJSON as toExternalJSON3
} from "@signalwire/core";
import { connect as connect7, BaseComponent as BaseComponent3 } from "@signalwire/core";

// src/messaging/workers.ts
import {
  sagaEffects as sagaEffects3,
  getLogger as getLogger3
} from "@signalwire/core";
var messagingWorker = function* (options) {
  const { channels } = options;
  const { swEventChannel, pubSubChannel } = channels;
  while (true) {
    const action = yield sagaEffects3.take(swEventChannel, (action2) => {
      return action2.type.startsWith("messaging.");
    });
    getLogger3().debug("messagingWorker:", action);
    switch (action.type) {
      case "messaging.receive": {
        yield sagaEffects3.put(pubSubChannel, {
          type: "message.received",
          payload: action.payload
        });
        break;
      }
      case "messaging.state": {
        yield sagaEffects3.put(pubSubChannel, {
          type: "message.updated",
          payload: action.payload
        });
        break;
      }
      default: {
        getLogger3().warn("[messagingWorker] Unrecognized Action", action);
        break;
      }
    }
  }
};

// src/messaging/Message.ts
var Message = class {
  constructor(options) {
    __publicField(this, "id");
    __publicField(this, "state");
    __publicField(this, "context");
    __publicField(this, "from");
    __publicField(this, "to");
    __publicField(this, "body");
    __publicField(this, "direction");
    __publicField(this, "media");
    __publicField(this, "segments");
    __publicField(this, "tags");
    __publicField(this, "reason");
    this.id = options.message_id;
    this.state = options.message_state;
    this.context = options.context;
    this.from = options.from_number;
    this.to = options.to_number;
    this.body = options.body;
    this.direction = options.direction;
    this.media = options.media || [];
    this.segments = options.segments;
    this.tags = options.tags || [];
    this.reason = options.reason;
  }
};

// src/messaging/MessagingClient.ts
var MessagingClient = function(options) {
  const { client, store, emitter } = setupClient(options);
  const messaging = createMessagingObject({
    store,
    emitter
  });
  client.once("session.connected", () => {
    messaging.applyEmitterTransforms();
  });
  const send2 = async (...args) => {
    await clientConnect(client);
    return messaging.send(...args);
  };
  const disconnect = () => client.disconnect();
  const interceptors = __spreadProps(__spreadValues({}, clientContextInterceptorsFactory(client)), {
    send: send2,
    _session: client,
    disconnect
  });
  return new Proxy(messaging, {
    get(target, prop, receiver) {
      if (prop in interceptors) {
        return interceptors[prop];
      }
      if (typeof target[prop] === "function") {
        clientConnect(client);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/messaging/Messaging.ts
var MessagingAPI = class extends BaseComponent3 {
  constructor(options) {
    super(options);
    this.runWorker("messagingWorker", {
      worker: messagingWorker
    });
    this._attachListeners("");
  }
  getEmitterTransforms() {
    return /* @__PURE__ */ new Map([
      [
        [
          "messaging.state",
          "messaging.receive",
          "message.updated",
          "message.received"
        ],
        {
          type: "messagingMessage",
          instanceFactory: (payload) => {
            return new Message(payload);
          },
          payloadTransform: (payload) => {
            const _a = payload, {
              message_id,
              message_state,
              from_number,
              to_number,
              tag
            } = _a, rest = __objRest(_a, [
              "message_id",
              "message_state",
              "from_number",
              "to_number",
              "tag"
            ]);
            return toExternalJSON3(__spreadProps(__spreadValues({}, rest), {
              id: message_id,
              state: message_state,
              from: from_number,
              to: to_number
            }));
          }
        }
      ]
    ]);
  }
  async send(params) {
    const _a = params, { from = "", to = "" } = _a, rest = __objRest(_a, ["from", "to"]);
    const sendParams = __spreadProps(__spreadValues({}, rest), {
      from_number: from,
      to_number: to
    });
    try {
      const response = await this.execute({
        method: "messaging.send",
        params: sendParams
      });
      return toExternalJSON3(response);
    } catch (error) {
      this.logger.error("Error sending message", error.jsonrpc);
      throw error.jsonrpc;
    }
  }
};
var createMessagingObject = (params) => {
  const messaging = connect7({
    store: params.store,
    Component: MessagingAPI,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(params);
  return messaging;
};

// src/voice/Voice.ts
var Voice_exports = {};
__export(Voice_exports, {
  Client: () => VoiceClient,
  DeviceBuilder: () => DeviceBuilder,
  Playlist: () => Playlist,
  createVoiceObject: () => createVoiceObject
});
import {
  connect as connect14,
  toExternalJSON as toExternalJSON6
} from "@signalwire/core";

// src/voice/Call.ts
import {
  uuid,
  connect as connect13,
  extendComponent as extendComponent3,
  toLocalEvent as toLocalEvent3,
  toExternalJSON as toExternalJSON5,
  toSnakeCaseKeys as toSnakeCaseKeys2
} from "@signalwire/core";

// src/AutoApplyTransformsConsumer.ts
import { BaseConsumer as BaseConsumer3 } from "@signalwire/core";
var AutoApplyTransformsConsumer = class extends BaseConsumer3 {
  on(event, fn) {
    const instance = super.on(event, fn);
    this.applyEmitterTransforms();
    return instance;
  }
  once(event, fn) {
    const instance = super.once(event, fn);
    this.applyEmitterTransforms();
    return instance;
  }
};

// src/voice/utils.ts
import { toSnakeCaseKeys } from "@signalwire/core";
var toInternalDevice = (device) => {
  switch (device.type) {
    case "sip": {
      const _a = device, { type } = _a, params = __objRest(_a, ["type"]);
      return {
        type,
        params: toSnakeCaseKeys(params)
      };
    }
    case "phone": {
      const _b = device, { to, from, type } = _b, rest = __objRest(_b, ["to", "from", "type"]);
      return {
        type,
        params: toSnakeCaseKeys(__spreadProps(__spreadValues({}, rest), {
          to_number: to,
          from_number: from
        }))
      };
    }
  }
  return device;
};
var toInternalDevices = (params, internalDevices = []) => {
  params.forEach((dev, index) => {
    if (Array.isArray(dev)) {
      internalDevices[index] = toInternalDevices(dev);
    } else {
      internalDevices[index] = toInternalDevice(dev);
    }
  });
  return internalDevices;
};
var toInternalPlay = (media) => {
  const _a = media, { type } = _a, params = __objRest(_a, ["type"]);
  return { type, params };
};
var toInternalPlayParams = (params, result = []) => {
  params.forEach((media, index) => {
    if (Array.isArray(media)) {
      result[index] = toInternalPlayParams(media);
    } else {
      result[index] = toInternalPlay(media);
    }
  });
  return result;
};

// src/voice/Playlist.ts
var Playlist = class {
  constructor(params = {}) {
    this.params = params;
    __publicField(this, "_media", []);
  }
  get volume() {
    var _a;
    return (_a = this.params) == null ? void 0 : _a.volume;
  }
  get media() {
    return this._media;
  }
  add(params) {
    this._media.push(params);
    return this;
  }
  static Audio(params) {
    return __spreadValues({ type: "audio" }, params);
  }
  static TTS(params) {
    return __spreadValues({ type: "tts" }, params);
  }
  static Silence(params) {
    return __spreadValues({ type: "silence" }, params);
  }
  static Ringtone(params) {
    return __spreadValues({ type: "ringtone" }, params);
  }
};

// src/voice/workers/voiceCallStateWorker.ts
import {
  getLogger as getLogger4,
  sagaEffects as sagaEffects4
} from "@signalwire/core";
var voiceCallStateWorker = function* (options) {
  const { channels, instance } = options;
  const { swEventChannel, pubSubChannel } = channels;
  getLogger4().trace("voiceCallStateWorker started", instance.id, instance.tag);
  let run = true;
  const done = () => run = false;
  while (run) {
    const action = yield sagaEffects4.take(swEventChannel, (action2) => {
      if (action2.type === "calling.call.state") {
        if (instance.id) {
          return instance.id === action2.payload.call_id;
        }
        return instance.tag === action2.payload.tag;
      }
      return false;
    });
    const newPayload = __spreadProps(__spreadValues({}, action.payload), {
      tag: instance.tag
    });
    yield sagaEffects4.put(pubSubChannel, {
      type: "calling.call.state",
      payload: newPayload
    });
    if (newPayload.call_state === "ended") {
      done();
    }
  }
  getLogger4().trace("voiceCallStateWorker ended", instance.id, instance.tag);
};

// src/voice/workers/voiceCallReceiveWorker.ts
import {
  getLogger as getLogger5,
  sagaEffects as sagaEffects5
} from "@signalwire/core";
var voiceCallReceiveWorker = function* (options) {
  var _a;
  getLogger5().trace("voiceCallReceiveWorker started");
  const { channels, instance } = options;
  const { swEventChannel, pubSubChannel } = channels;
  const { contexts = [] } = (_a = instance == null ? void 0 : instance.options) != null ? _a : {};
  if (!contexts.length) {
    throw new Error("Invalid contexts to receive inbound calls");
  }
  while (true) {
    const action = yield sagaEffects5.take(swEventChannel, (action2) => {
      return action2.type === "calling.call.receive" && contexts.includes(action2.payload.context);
    });
    yield sagaEffects5.put(pubSubChannel, {
      type: "calling.call.received",
      payload: action.payload
    });
  }
  getLogger5().trace("voiceCallReceiveWorker ended");
};

// src/voice/workers/voiceCallPlayWorker.ts
import {
  getLogger as getLogger6,
  sagaEffects as sagaEffects6
} from "@signalwire/core";
var voiceCallPlayWorker = function* (options) {
  getLogger6().trace("voiceCallPlayWorker started");
  const { channels, instance, initialState } = options;
  const { swEventChannel, pubSubChannel } = channels;
  const { controlId } = initialState;
  if (!controlId) {
    throw new Error("Missing controlId for playback");
  }
  let paused = false;
  let run = true;
  const done = () => run = false;
  while (run) {
    const action = yield sagaEffects6.take(swEventChannel, (action2) => {
      return action2.type === "calling.call.play" && action2.payload.control_id === controlId;
    });
    const payloadWithTag = __spreadValues({
      tag: instance.tag
    }, action.payload);
    yield sagaEffects6.put(pubSubChannel, {
      type: callingPlaybackTriggerEvent,
      payload: payloadWithTag
    });
    switch (action.payload.state) {
      case "playing": {
        const type = paused ? "calling.playback.updated" : "calling.playback.started";
        paused = false;
        yield sagaEffects6.put(pubSubChannel, {
          type,
          payload: payloadWithTag
        });
        break;
      }
      case "paused": {
        paused = true;
        yield sagaEffects6.put(pubSubChannel, {
          type: "calling.playback.updated",
          payload: payloadWithTag
        });
        break;
      }
      case "error":
        break;
      case "finished": {
        yield sagaEffects6.put(pubSubChannel, {
          type: "calling.playback.ended",
          payload: payloadWithTag
        });
        yield sagaEffects6.put(pubSubChannel, {
          type: "calling.playback.ended",
          payload: __spreadValues({
            tag: controlId
          }, action.payload)
        });
        done();
        break;
      }
    }
  }
  getLogger6().trace("voiceCallPlayWorker ended");
};

// src/voice/workers/voiceCallRecordWorker.ts
import {
  getLogger as getLogger7,
  sagaEffects as sagaEffects7
} from "@signalwire/core";
var voiceCallRecordWorker = function* (options) {
  getLogger7().trace("voiceCallRecordWorker started");
  const { channels, instance, initialState } = options;
  const { swEventChannel, pubSubChannel } = channels;
  const { controlId } = initialState;
  if (!controlId) {
    throw new Error("Missing controlId for recording");
  }
  let run = true;
  const done = () => run = false;
  while (run) {
    const action = yield sagaEffects7.take(swEventChannel, (action2) => {
      return action2.type === "calling.call.record" && action2.payload.control_id === controlId;
    });
    const payloadWithTag = __spreadValues({
      tag: instance.tag
    }, action.payload);
    yield sagaEffects7.put(pubSubChannel, {
      type: callingRecordTriggerEvent,
      payload: payloadWithTag
    });
    switch (action.payload.state) {
      case "recording": {
        yield sagaEffects7.put(pubSubChannel, {
          type: "calling.recording.started",
          payload: payloadWithTag
        });
        break;
      }
      case "no_input":
      case "finished": {
        const typeToEmit = action.payload.state === "finished" ? "calling.recording.ended" : "calling.recording.failed";
        yield sagaEffects7.put(pubSubChannel, {
          type: typeToEmit,
          payload: payloadWithTag
        });
        yield sagaEffects7.put(pubSubChannel, {
          type: typeToEmit,
          payload: __spreadValues({
            tag: controlId
          }, action.payload)
        });
        done();
        break;
      }
    }
  }
  getLogger7().trace("voiceCallRecordWorker ended");
};

// src/voice/workers/voiceCallPromptWorker.ts
import {
  getLogger as getLogger8,
  sagaEffects as sagaEffects8
} from "@signalwire/core";
var voiceCallPromptWorker = function* (options) {
  getLogger8().trace("voiceCallPromptWorker started");
  const { channels, instance, initialState } = options;
  const { swEventChannel, pubSubChannel } = channels;
  const { controlId } = initialState;
  if (!controlId) {
    throw new Error("Missing controlId for prompt");
  }
  let run = true;
  const done = () => run = false;
  while (run) {
    const action = yield sagaEffects8.take(swEventChannel, (action2) => {
      return action2.type === "calling.call.collect" && action2.payload.control_id === controlId;
    });
    const payloadWithTag = __spreadValues({
      tag: instance.tag
    }, action.payload);
    yield sagaEffects8.put(pubSubChannel, {
      type: callingPromptTriggerEvent,
      payload: payloadWithTag
    });
    if (action.payload.result) {
      let typeToEmit;
      switch (action.payload.result.type) {
        case "no_match":
        case "no_input":
        case "error": {
          typeToEmit = "calling.prompt.failed";
          break;
        }
        case "speech":
        case "digit": {
          typeToEmit = "calling.prompt.ended";
          break;
        }
      }
      yield sagaEffects8.put(pubSubChannel, {
        type: typeToEmit,
        payload: payloadWithTag
      });
      yield sagaEffects8.put(pubSubChannel, {
        type: typeToEmit,
        payload: __spreadValues({
          tag: controlId
        }, action.payload)
      });
      done();
    }
    if (action.payload.final === false) {
      yield sagaEffects8.put(pubSubChannel, {
        type: "calling.prompt.updated",
        payload: payloadWithTag
      });
    }
  }
  getLogger8().trace("voiceCallPromptWorker ended");
};

// src/voice/workers/voiceCallTapWorker.ts
import {
  getLogger as getLogger9,
  sagaEffects as sagaEffects9
} from "@signalwire/core";
var voiceCallTapWorker = function* (options) {
  getLogger9().trace("voiceCallTapWorker started");
  const { channels, instance, initialState } = options;
  const { swEventChannel, pubSubChannel } = channels;
  const { controlId } = initialState;
  if (!controlId) {
    throw new Error("Missing controlId for tapping");
  }
  let run = true;
  const done = () => run = false;
  while (run) {
    const action = yield sagaEffects9.take(swEventChannel, (action2) => {
      return action2.type === "calling.call.tap" && action2.payload.control_id === controlId;
    });
    const payloadWithTag = __spreadValues({
      tag: instance.tag
    }, action.payload);
    yield sagaEffects9.put(pubSubChannel, {
      type: callingTapTriggerEvent,
      payload: payloadWithTag
    });
    switch (action.payload.state) {
      case "tapping": {
        yield sagaEffects9.put(pubSubChannel, {
          type: "calling.tap.started",
          payload: payloadWithTag
        });
        break;
      }
      case "finished": {
        yield sagaEffects9.put(pubSubChannel, {
          type: "calling.tap.ended",
          payload: payloadWithTag
        });
        yield sagaEffects9.put(pubSubChannel, {
          type: "calling.tap.ended",
          payload: __spreadValues({
            tag: controlId
          }, action.payload)
        });
        done();
        break;
      }
    }
  }
  getLogger9().trace("voiceCallTapWorker ended");
};

// src/voice/workers/voiceCallConnectWorker.ts
import {
  getLogger as getLogger10,
  sagaEffects as sagaEffects10
} from "@signalwire/core";
var voiceCallConnectWorker = function* (options) {
  getLogger10().trace("voiceCallConnectWorker started");
  const { channels, instance } = options;
  const { swEventChannel, pubSubChannel } = channels;
  let run = true;
  const done = () => run = false;
  while (run) {
    const action = yield sagaEffects10.take(swEventChannel, (action2) => {
      var _a;
      return action2.type === "calling.call.connect" && (action2.payload.call_id === instance.callId || action2.payload.tag === instance.tag || ((_a = action2.payload.peer) == null ? void 0 : _a.tag) === instance.tag);
    });
    const payloadWithTag = __spreadValues({
      tag: instance.tag
    }, action.payload);
    yield sagaEffects10.put(pubSubChannel, {
      type: `calling.connect.${action.payload.connect_state}`,
      payload: payloadWithTag
    });
    switch (action.payload.connect_state) {
      case "connected": {
        yield sagaEffects10.put(pubSubChannel, {
          type: "calling.call.state",
          payload: {
            call_id: instance.callId,
            call_state: instance.state,
            context: instance.context,
            tag: instance.tag,
            direction: instance.direction,
            device: instance.device,
            node_id: instance.nodeId,
            peer: action.payload.peer
          }
        });
        break;
      }
      case "disconnected":
      case "failed": {
        done();
        break;
      }
    }
  }
  getLogger10().trace("voiceCallConnectWorker ended");
};

// src/voice/workers/voiceCallDialWorker.ts
import {
  getLogger as getLogger11,
  sagaEffects as sagaEffects11,
  toExternalJSON as toExternalJSON4
} from "@signalwire/core";
var TARGET_DIAL_STATES = [
  "answered",
  "failed"
];
var voiceCallDialWorker = function* (options) {
  const { channels, instance, onDone, onFail } = options;
  const { swEventChannel } = channels;
  getLogger11().trace("voiceCallDialWorker started");
  const action = yield sagaEffects11.take(swEventChannel, (action2) => {
    if (action2.type === "calling.call.dial" && TARGET_DIAL_STATES.includes(action2.payload.dial_state)) {
      return instance.tag === action2.payload.tag;
    }
    return false;
  });
  if (action.payload.dial_state === "answered") {
    onDone == null ? void 0 : onDone(instance);
  } else if (action.payload.dial_state === "failed") {
    onFail == null ? void 0 : onFail(toExternalJSON4(action.payload));
  } else {
    throw new Error("[voiceCallDialWorker] unhandled call_state");
  }
  getLogger11().trace("voiceCallDialWorker ended");
};

// src/voice/workers/VoiceCallSendDigitWorker.ts
import {
  getLogger as getLogger12,
  sagaEffects as sagaEffects12
} from "@signalwire/core";
var TARGET_STATES = [
  "finished"
];
var voiceCallSendDigitsWorker = function* (options) {
  getLogger12().trace("voiceCallSendDigitsWorker started");
  const { channels, onDone, onFail, initialState = {}, instance } = options;
  const { swEventChannel } = channels;
  const { controlId } = initialState;
  if (!controlId) {
    throw new Error("Missing controlId for sendDigits");
  }
  const action = yield sagaEffects12.take(swEventChannel, (action2) => {
    if (action2.type === "calling.call.send_digits" && TARGET_STATES.includes(action2.payload.state)) {
      return action2.payload.control_id === controlId;
    }
    return false;
  });
  if (action.payload.state === "finished") {
    onDone == null ? void 0 : onDone(instance);
  } else {
    const error = new Error(`[voiceCallSendDigitsWorker] unhandled state: '${action.payload.state}'`);
    if (typeof onFail === "function") {
      onFail({ error });
    } else {
      throw error;
    }
  }
  getLogger12().trace("voiceCallSendDigitsWorker ended");
};

// src/voice/workers/voiceCallDetectWorker.ts
import {
  getLogger as getLogger13,
  sagaEffects as sagaEffects13
} from "@signalwire/core";
var voiceCallDetectWorker = function* (options) {
  getLogger13().trace("voiceCallDetectWorker started");
  const { channels, instance, initialState } = options;
  const { swEventChannel, pubSubChannel } = channels;
  const { controlId, waitForBeep = false } = initialState;
  if (!controlId) {
    throw new Error("Missing controlId for tapping");
  }
  let waitingForReady = false;
  let run = true;
  let lastAction;
  const done = () => run = false;
  while (run) {
    const action = yield sagaEffects13.take(swEventChannel, (action2) => {
      return action2.type === "calling.call.detect" && action2.payload.control_id === controlId;
    });
    const { detect } = action.payload;
    if (!detect) {
      continue;
    }
    lastAction = action;
    const payloadWithTag = __spreadValues({
      tag: instance.tag
    }, action.payload);
    yield sagaEffects13.put(pubSubChannel, {
      type: callingDetectTriggerEvent,
      payload: payloadWithTag
    });
    const {
      type,
      params: { event }
    } = detect;
    if (event === "error" || event === "finished") {
      yield sagaEffects13.put(pubSubChannel, {
        type: "calling.detect.ended",
        payload: payloadWithTag
      });
      done();
      continue;
    }
    yield sagaEffects13.put(pubSubChannel, {
      type: "calling.detect.updated",
      payload: payloadWithTag
    });
    switch (type) {
      case "machine": {
        if (waitingForReady && event === "READY") {
          yield sagaEffects13.put(pubSubChannel, {
            type: "calling.detect.ended",
            payload: payloadWithTag
          });
          done();
        }
        if (waitForBeep) {
          waitingForReady = true;
        }
        break;
      }
    }
  }
  if (lastAction) {
    yield sagaEffects13.put(pubSubChannel, {
      type: "calling.detect.ended",
      payload: __spreadProps(__spreadValues({}, lastAction.payload), {
        tag: controlId
      })
    });
  }
  getLogger13().trace("voiceCallDetectWorker ended");
};

// src/voice/CallPlayback.ts
import {
  connect as connect8,
  BaseComponent as BaseComponent4
} from "@signalwire/core";
var CallPlaybackAPI = class extends BaseComponent4 {
  constructor() {
    super(...arguments);
    __publicField(this, "_eventsPrefix", "calling");
    __publicField(this, "callId");
    __publicField(this, "nodeId");
    __publicField(this, "controlId");
    __publicField(this, "state", "playing");
    __publicField(this, "_volume");
  }
  get id() {
    return this.controlId;
  }
  get volume() {
    return this._volume;
  }
  async pause() {
    await this.execute({
      method: "calling.play.pause",
      params: {
        node_id: this.nodeId,
        call_id: this.callId,
        control_id: this.controlId
      }
    });
    return this;
  }
  async resume() {
    await this.execute({
      method: "calling.play.resume",
      params: {
        node_id: this.nodeId,
        call_id: this.callId,
        control_id: this.controlId
      }
    });
    return this;
  }
  async stop() {
    await this.execute({
      method: "calling.play.stop",
      params: {
        node_id: this.nodeId,
        call_id: this.callId,
        control_id: this.controlId
      }
    });
    return this;
  }
  async setVolume(volume) {
    this._volume = volume;
    await this.execute({
      method: "calling.play.volume",
      params: {
        node_id: this.nodeId,
        call_id: this.callId,
        control_id: this.controlId,
        volume
      }
    });
    return this;
  }
  waitForEnded() {
    return this.ended();
  }
  ended() {
    return new Promise((resolve) => {
      this._attachListeners(this.controlId);
      const handler = () => {
        resolve(this);
      };
      this.once("playback.ended", handler);
    });
  }
};
var createCallPlaybackObject = (params) => {
  const playback = connect8({
    store: params.store,
    Component: CallPlaybackAPI,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(params);
  return playback;
};

// src/voice/CallRecording.ts
import {
  connect as connect9,
  BaseComponent as BaseComponent5
} from "@signalwire/core";
var CallRecordingAPI = class extends BaseComponent5 {
  constructor() {
    super(...arguments);
    __publicField(this, "_eventsPrefix", "calling");
    __publicField(this, "callId");
    __publicField(this, "nodeId");
    __publicField(this, "controlId");
    __publicField(this, "state", "recording");
  }
  get id() {
    return this.controlId;
  }
  async stop() {
    await this.execute({
      method: "calling.record.stop",
      params: {
        node_id: this.nodeId,
        call_id: this.callId,
        control_id: this.controlId
      }
    });
    return this;
  }
  ended() {
    return new Promise((resolve) => {
      this._attachListeners(this.controlId);
      const handler = () => {
        this.off("recording.ended", handler);
        this.off("recording.failed", handler);
        resolve(this);
      };
      this.once("recording.ended", handler);
      this.once("recording.failed", handler);
    });
  }
};
var createCallRecordingObject = (params) => {
  const record = connect9({
    store: params.store,
    Component: CallRecordingAPI,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(params);
  return record;
};

// src/voice/CallPrompt.ts
import {
  connect as connect10,
  BaseComponent as BaseComponent6
} from "@signalwire/core";
var CallPromptAPI = class extends BaseComponent6 {
  constructor() {
    super(...arguments);
    __publicField(this, "_eventsPrefix", "calling");
    __publicField(this, "callId");
    __publicField(this, "nodeId");
    __publicField(this, "controlId");
    __publicField(this, "result");
  }
  get id() {
    return this.controlId;
  }
  get type() {
    var _a;
    return (_a = this.result) == null ? void 0 : _a.type;
  }
  get reason() {
    return this.type;
  }
  get digits() {
    var _a;
    if (((_a = this.result) == null ? void 0 : _a.type) === "digit") {
      return this.result.params.digits;
    }
    return void 0;
  }
  get terminator() {
    var _a;
    if (((_a = this.result) == null ? void 0 : _a.type) === "digit") {
      return this.result.params.terminator;
    }
    return void 0;
  }
  get text() {
    var _a;
    if (((_a = this.result) == null ? void 0 : _a.type) === "speech") {
      return this.result.params.text;
    }
    return void 0;
  }
  get confidence() {
    var _a;
    if (((_a = this.result) == null ? void 0 : _a.type) === "speech") {
      return this.result.params.confidence;
    }
    return void 0;
  }
  async stop() {
    if (!this.result) {
      await this.execute({
        method: "calling.play_and_collect.stop",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: this.controlId
        }
      });
    }
    return this;
  }
  async setVolume(volume) {
    await this.execute({
      method: "calling.play_and_collect.volume",
      params: {
        node_id: this.nodeId,
        call_id: this.callId,
        control_id: this.controlId,
        volume
      }
    });
    return this;
  }
  waitForResult() {
    return this.ended();
  }
  ended() {
    return new Promise((resolve) => {
      this._attachListeners(this.controlId);
      const handler = (_callPrompt) => {
        this.off("prompt.ended", handler);
        this.off("prompt.failed", handler);
        resolve(this);
      };
      this.once("prompt.ended", handler);
      this.once("prompt.failed", handler);
    });
  }
};
var createCallPromptObject = (params) => {
  const record = connect10({
    store: params.store,
    Component: CallPromptAPI,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(params);
  return record;
};

// src/voice/CallTap.ts
import {
  connect as connect11,
  BaseComponent as BaseComponent7
} from "@signalwire/core";
var CallTapAPI = class extends BaseComponent7 {
  constructor() {
    super(...arguments);
    __publicField(this, "callId");
    __publicField(this, "nodeId");
    __publicField(this, "controlId");
    __publicField(this, "state");
  }
  get id() {
    return this.controlId;
  }
  async stop() {
    if (this.state !== "finished") {
      await this.execute({
        method: "calling.tap.stop",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: this.controlId
        }
      });
    }
    return this;
  }
  ended() {
    return new Promise((resolve) => {
      this._attachListeners(this.controlId);
      const handler = () => {
        resolve(this);
      };
      this.once("tap.ended", handler);
    });
  }
};
var createCallTapObject = (params) => {
  const tap = connect11({
    store: params.store,
    Component: CallTapAPI,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(params);
  return tap;
};

// src/voice/CallDetect.ts
import {
  connect as connect12,
  BaseComponent as BaseComponent8
} from "@signalwire/core";
var CallDetectAPI = class extends BaseComponent8 {
  constructor() {
    super(...arguments);
    __publicField(this, "_eventsPrefix", "calling");
    __publicField(this, "callId");
    __publicField(this, "nodeId");
    __publicField(this, "controlId");
    __publicField(this, "detect");
  }
  get id() {
    return this.controlId;
  }
  get type() {
    var _a;
    return (_a = this == null ? void 0 : this.detect) == null ? void 0 : _a.type;
  }
  async stop() {
    await this.execute({
      method: "calling.detect.stop",
      params: {
        node_id: this.nodeId,
        call_id: this.callId,
        control_id: this.controlId
      }
    });
    return this;
  }
  waitForResult() {
    return this.ended();
  }
  ended() {
    return new Promise((resolve) => {
      this._attachListeners(this.controlId);
      this.once("detect.ended", () => {
        resolve(this);
      });
    });
  }
};
var createCallDetectObject = (params) => {
  const detect = connect12({
    store: params.store,
    Component: CallDetectAPI,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(params);
  return detect;
};

// src/voice/DeviceBuilder.ts
var DeviceBuilder = class {
  constructor() {
    __publicField(this, "_devices", []);
  }
  get devices() {
    return this._devices;
  }
  add(params) {
    if (Array.isArray(params)) {
      this._devices.push(params);
    } else {
      this._devices.push([params]);
    }
    return this;
  }
  static Phone(params) {
    return __spreadValues({ type: "phone" }, params);
  }
  static Sip(params) {
    return __spreadValues({ type: "sip" }, params);
  }
};

// src/voice/Call.ts
var callingPlaybackTriggerEvent = toLocalEvent3("calling.playback.trigger");
var callingRecordTriggerEvent = toLocalEvent3("calling.recording.trigger");
var callingPromptTriggerEvent = toLocalEvent3("calling.prompt.trigger");
var callingTapTriggerEvent = toLocalEvent3("calling.tap.trigger");
var callingDetectTriggerEvent = toLocalEvent3("calling.detect.trigger");
var CallConsumer = class extends AutoApplyTransformsConsumer {
  constructor(options) {
    super(options);
    __publicField(this, "_eventsPrefix", "calling");
    __publicField(this, "callId");
    __publicField(this, "nodeId");
    __publicField(this, "peer");
    __publicField(this, "callState");
    __publicField(this, "detectAnsweringMachine", this.amd);
    this._attachListeners(this.__uuid);
    this.applyEmitterTransforms({ local: true });
    this.on("call.state", () => {
    });
    this.runWorker("voiceCallStateWorker", {
      worker: voiceCallStateWorker
    });
  }
  get id() {
    return this.callId;
  }
  get state() {
    return this.callState;
  }
  get tag() {
    return this.__uuid;
  }
  get type() {
    var _a, _b;
    return (_b = (_a = this.device) == null ? void 0 : _a.type) != null ? _b : "";
  }
  get from() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    if (this.type === "phone") {
      return (_c = (_b = (_a = this.device) == null ? void 0 : _a.params) == null ? void 0 : _b.fromNumber) != null ? _c : "";
    } else if (this.type === "sip") {
      return (_f = (_e = (_d = this.device) == null ? void 0 : _d.params) == null ? void 0 : _e.from) != null ? _f : "";
    }
    return (_i = (_h = (_g = this.device) == null ? void 0 : _g.params) == null ? void 0 : _h.from) != null ? _i : "";
  }
  get to() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    if (this.type === "phone") {
      return (_c = (_b = (_a = this.device) == null ? void 0 : _a.params) == null ? void 0 : _b.toNumber) != null ? _c : "";
    } else if (this.type === "sip") {
      return (_f = (_e = (_d = this.device) == null ? void 0 : _d.params) == null ? void 0 : _e.to) != null ? _f : "";
    }
    return (_i = (_h = (_g = this.device) == null ? void 0 : _g.params) == null ? void 0 : _h.to) != null ? _i : "";
  }
  get headers() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this.device) == null ? void 0 : _a.params) == null ? void 0 : _b.headers) != null ? _c : [];
  }
  getEmitterTransforms() {
    return /* @__PURE__ */ new Map([
      [
        [
          callingPlaybackTriggerEvent,
          "calling.playback.started",
          "calling.playback.updated",
          "calling.playback.ended"
        ],
        {
          type: "voiceCallPlayback",
          instanceFactory: (_payload) => {
            return createCallPlaybackObject({
              store: this.store,
              emitter: this.emitter
            });
          },
          payloadTransform: (payload) => {
            return toExternalJSON5(payload);
          }
        }
      ],
      [
        [
          callingRecordTriggerEvent,
          "calling.recording.started",
          "calling.recording.updated",
          "calling.recording.ended",
          "calling.recording.failed"
        ],
        {
          type: "voiceCallRecord",
          instanceFactory: (_payload) => {
            return createCallRecordingObject({
              store: this.store,
              emitter: this.emitter
            });
          },
          payloadTransform: (payload) => {
            return toExternalJSON5(payload);
          }
        }
      ],
      [
        [
          callingPromptTriggerEvent,
          "calling.prompt.started",
          "calling.prompt.updated",
          "calling.prompt.ended",
          "calling.prompt.failed"
        ],
        {
          type: "voiceCallPrompt",
          instanceFactory: (_payload) => {
            return createCallPromptObject({
              store: this.store,
              emitter: this.emitter
            });
          },
          payloadTransform: (payload) => {
            return toExternalJSON5(payload);
          }
        }
      ],
      [
        [callingTapTriggerEvent, "calling.tap.started", "calling.tap.ended"],
        {
          type: "voiceCallTap",
          instanceFactory: (_payload) => {
            return createCallTapObject({
              store: this.store,
              emitter: this.emitter
            });
          },
          payloadTransform: (payload) => {
            return toExternalJSON5(payload);
          }
        }
      ],
      [
        ["calling.call.state"],
        {
          type: "voiceCallState",
          instanceFactory: (_payload) => {
            return this;
          },
          payloadTransform: (payload) => {
            return toExternalJSON5(payload);
          }
        }
      ],
      [
        ["calling.connect.connected"],
        {
          type: "voiceCallConnect",
          instanceFactory: (_payload) => {
            return createCallObject({
              store: this.store,
              emitter: this.emitter
            });
          },
          payloadTransform: (payload) => {
            const _a = payload.peer, { tag } = _a, peerParams = __objRest(_a, ["tag"]);
            return toExternalJSON5(peerParams);
          }
        }
      ],
      [
        [
          callingDetectTriggerEvent,
          "calling.detect.started",
          "calling.detect.updated",
          "calling.detect.ended"
        ],
        {
          type: "voiceCallDetect",
          instanceFactory: (_payload) => {
            return createCallDetectObject({
              store: this.store,
              emitter: this.emitter
            });
          },
          payloadTransform: (payload) => {
            return toExternalJSON5(payload);
          }
        }
      ]
    ]);
  }
  dial(params) {
    return new Promise((resolve, reject) => {
      this.runWorker("voiceCallDialWorker", {
        worker: voiceCallDialWorker,
        onDone: resolve,
        onFail: reject
      });
      let executeParams;
      if (params instanceof DeviceBuilder) {
        const { devices } = params;
        executeParams = {
          tag: this.__uuid,
          devices: toInternalDevices(devices)
        };
      } else if ("region" in params) {
        const { region, devices: deviceBuilder } = params;
        executeParams = {
          tag: this.__uuid,
          region,
          devices: toInternalDevices(deviceBuilder.devices)
        };
      } else {
        throw new Error("[dial] Invalid input");
      }
      this.execute({
        method: "calling.dial",
        params: executeParams
      }).catch((e) => {
        reject(e);
      });
    });
  }
  hangup(reason = "hangup") {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call hangup() on a call that hasn't been established.`));
      }
      this.on("call.state", (params) => {
        if (params.callState === "ended") {
          resolve(new Error("Failed to hangup the call."));
        }
      });
      this.execute({
        method: "calling.end",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          reason
        }
      }).catch((e) => {
        reject(e);
      });
    });
  }
  answer() {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call answer() on a call without callId.`));
      }
      this.on("call.state", (params) => {
        if (params.callState === "answered") {
          resolve(this);
        } else if (params.callState === "ended") {
          reject(new Error("Failed to answer the call."));
        }
      });
      this.execute({
        method: "calling.answer",
        params: {
          node_id: this.nodeId,
          call_id: this.callId
        }
      }).catch((e) => {
        reject(e);
      });
    });
  }
  play(params) {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call play() on a call not established yet.`));
      }
      const controlId = uuid();
      this.runWorker("voiceCallPlayWorker", {
        worker: voiceCallPlayWorker,
        initialState: {
          controlId
        }
      });
      const resolveHandler = (callPlayback) => {
        resolve(callPlayback);
      };
      this.on(callingPlaybackTriggerEvent, resolveHandler);
      this.execute({
        method: "calling.play",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: controlId,
          volume: params.volume,
          play: toInternalPlayParams(params.media)
        }
      }).then(() => {
        const startEvent = {
          control_id: controlId,
          call_id: this.id,
          node_id: this.nodeId
        };
        this.emit(callingPlaybackTriggerEvent, startEvent);
      }).catch((e) => {
        this.off(callingPlaybackTriggerEvent, resolveHandler);
        reject(e);
      });
    });
  }
  playAudio(params) {
    const _a = params, { volume } = _a, rest = __objRest(_a, ["volume"]);
    const playlist = new Playlist({ volume }).add(Playlist.Audio(rest));
    return this.play(playlist);
  }
  playSilence(params) {
    const playlist = new Playlist().add(Playlist.Silence(params));
    return this.play(playlist);
  }
  playRingtone(params) {
    const _a = params, { volume } = _a, rest = __objRest(_a, ["volume"]);
    const playlist = new Playlist({ volume }).add(Playlist.Ringtone(rest));
    return this.play(playlist);
  }
  playTTS(params) {
    const _a = params, { volume } = _a, rest = __objRest(_a, ["volume"]);
    const playlist = new Playlist({ volume }).add(Playlist.TTS(rest));
    return this.play(playlist);
  }
  record(params) {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call record() on a call not established yet.`));
      }
      const controlId = uuid();
      this.runWorker("voiceCallRecordWorker", {
        worker: voiceCallRecordWorker,
        initialState: {
          controlId
        }
      });
      const resolveHandler = (callRecording) => {
        resolve(callRecording);
      };
      this.on(callingRecordTriggerEvent, resolveHandler);
      const record = toSnakeCaseKeys2(params);
      this.execute({
        method: "calling.record",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: controlId,
          record
        }
      }).then(() => {
        const startEvent = {
          control_id: controlId,
          call_id: this.id,
          node_id: this.nodeId,
          record
        };
        this.emit(callingRecordTriggerEvent, startEvent);
      }).catch((e) => {
        this.off(callingRecordTriggerEvent, resolveHandler);
        reject(e);
      });
    });
  }
  recordAudio(params = {}) {
    return this.record({
      audio: params
    });
  }
  prompt(params) {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call record() on a call not established yet.`));
      }
      if (!params.playlist) {
        reject(new Error(`Missing 'playlist' params.`));
      }
      const controlId = uuid();
      this.runWorker("voiceCallPromptWorker", {
        worker: voiceCallPromptWorker,
        initialState: {
          controlId
        }
      });
      const resolveHandler = (callRecording) => {
        resolve(callRecording);
      };
      this.on(callingPromptTriggerEvent, resolveHandler);
      const { volume, media } = params.playlist;
      const { initial_timeout, partial_results, digits, speech } = toSnakeCaseKeys2(params);
      const collect = {
        initial_timeout,
        partial_results,
        digits,
        speech
      };
      this.execute({
        method: "calling.play_and_collect",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: controlId,
          volume,
          play: toInternalPlayParams(media),
          collect
        }
      }).then(() => {
        const startEvent = {
          control_id: controlId,
          call_id: this.id,
          node_id: this.nodeId
        };
        this.emit("prompt.started", startEvent);
        this.emit(callingPromptTriggerEvent, startEvent);
      }).catch((e) => {
        this.off("prompt.started", resolveHandler);
        this.off(callingPromptTriggerEvent, resolveHandler);
        reject(e);
      });
    });
  }
  promptAudio(params) {
    const _a = params, { url, volume } = _a, rest = __objRest(_a, ["url", "volume"]);
    const playlist = new Playlist({ volume }).add(Playlist.Audio({ url }));
    return this.prompt(__spreadValues({
      playlist
    }, rest));
  }
  promptRingtone(params) {
    const _a = params, { name, duration, volume } = _a, rest = __objRest(_a, ["name", "duration", "volume"]);
    const playlist = new Playlist({ volume }).add(Playlist.Ringtone({ name, duration }));
    return this.prompt(__spreadValues({
      playlist
    }, rest));
  }
  promptTTS(params) {
    const _a = params, { text, language, gender, volume } = _a, rest = __objRest(_a, ["text", "language", "gender", "volume"]);
    const playlist = new Playlist({ volume }).add(Playlist.TTS({ text, language, gender }));
    return this.prompt(__spreadValues({
      playlist
    }, rest));
  }
  sendDigits(digits) {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call sendDigits() on a call not established yet.`));
      }
      const controlId = uuid();
      const cleanup = () => {
        this.off("call.state", callStateHandler);
      };
      this.runWorker("voiceCallSendDigitsWorker", {
        worker: voiceCallSendDigitsWorker,
        initialState: {
          controlId
        },
        onDone: (args) => {
          cleanup();
          resolve(args);
        },
        onFail: ({ error }) => {
          cleanup();
          reject(error);
        }
      });
      const callStateHandler = (params) => {
        if (params.callState === "ended" || params.callState === "ending") {
          reject(new Error("Call is ended or about to end, couldn't send digits in time."));
        }
      };
      this.once("call.state", callStateHandler);
      this.execute({
        method: "calling.send_digits",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: controlId,
          digits
        }
      }).catch((e) => {
        reject(e);
      });
    });
  }
  tap(params) {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call tap() on a call not established yet.`));
      }
      const controlId = uuid();
      this.runWorker("voiceCallTapWorker", {
        worker: voiceCallTapWorker,
        initialState: {
          controlId
        }
      });
      const resolveHandler = (callTap) => {
        resolve(callTap);
      };
      this.on(callingTapTriggerEvent, resolveHandler);
      const {
        audio = {},
        device: _a
      } = params, _b = _a, { type } = _b, rest = __objRest(_b, ["type"]);
      this.execute({
        method: "calling.tap",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: controlId,
          tap: {
            type: "audio",
            params: audio
          },
          device: {
            type,
            params: rest
          }
        }
      }).then(() => {
        const startEvent = {
          control_id: controlId,
          call_id: this.id,
          node_id: this.nodeId
        };
        this.emit(callingTapTriggerEvent, startEvent);
      }).catch((e) => {
        this.off(callingTapTriggerEvent, resolveHandler);
        reject(e);
      });
    });
  }
  tapAudio(params) {
    const { direction, device } = params;
    return this.tap({ audio: { direction }, device });
  }
  connect(params) {
    return new Promise((resolve, reject) => {
      var _a;
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call connect() on a call not established yet.`));
      }
      let executeParams;
      if (params instanceof DeviceBuilder) {
        const { devices } = params;
        executeParams = {
          tag: this.__uuid,
          devices: toInternalDevices(devices)
        };
      } else if ("ringback" in params) {
        const { ringback, devices: deviceBuilder } = params;
        executeParams = {
          tag: this.__uuid,
          ringback: toInternalPlayParams((_a = ringback == null ? void 0 : ringback.media) != null ? _a : []),
          devices: toInternalDevices(deviceBuilder.devices)
        };
      } else {
        throw new Error("[connect] Invalid input");
      }
      this.runWorker("voiceCallConnectWorker", {
        worker: voiceCallConnectWorker
      });
      const resolveHandler = (payload) => {
        this.off("connect.failed", rejectHandler);
        resolve(payload);
      };
      const rejectHandler = (payload) => {
        this.off("connect.connected", resolveHandler);
        reject(toExternalJSON5(payload));
      };
      this.once("connect.connected", resolveHandler);
      this.once("connect.failed", rejectHandler);
      this.execute({
        method: "calling.connect",
        params: __spreadValues({
          node_id: this.nodeId,
          call_id: this.callId,
          tag: this.__uuid
        }, executeParams)
      }).catch((e) => {
        this.off("connect.connected", resolveHandler);
        this.off("connect.failed", rejectHandler);
        reject(e);
      });
    });
  }
  connectPhone(_a) {
    var _b = _a, { ringback } = _b, params = __objRest(_b, ["ringback"]);
    const devices = new DeviceBuilder().add(DeviceBuilder.Phone(params));
    return this.connect({ devices, ringback });
  }
  connectSip(_c) {
    var _d = _c, { ringback } = _d, params = __objRest(_d, ["ringback"]);
    const devices = new DeviceBuilder().add(DeviceBuilder.Sip(params));
    return this.connect({ devices, ringback });
  }
  disconnect() {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId || !this.peer) {
        reject(new Error(`Can't call disconnect() on a call not connected yet.`));
      }
      const resolveHandler = () => {
        resolve();
      };
      this.once("connect.disconnected", resolveHandler);
      this.execute({
        method: "calling.disconnect",
        params: {
          node_id: this.nodeId,
          call_id: this.callId
        }
      }).catch((e) => {
        this.off("connect.disconnected", resolveHandler);
        reject(e);
      });
    });
  }
  waitForDisconnected() {
    return this.disconnect;
  }
  disconnected() {
    return new Promise((resolve) => {
      const resolveHandler = () => {
        resolve(this);
      };
      this.once("connect.disconnected", resolveHandler);
      this.once("connect.failed", resolveHandler);
      if (this.state === "ended" || this.state === "ending") {
        return resolveHandler();
      }
    });
  }
  detect(params) {
    return new Promise((resolve, reject) => {
      if (!this.callId || !this.nodeId) {
        reject(new Error(`Can't call detect() on a call not established yet.`));
      }
      const _a = params, { waitForBeep = false, timeout, type } = _a, rest = __objRest(_a, ["waitForBeep", "timeout", "type"]);
      const controlId = uuid();
      this.runWorker("voiceCallDetectWorker", {
        worker: voiceCallDetectWorker,
        initialState: {
          controlId,
          waitForBeep
        }
      });
      const resolveHandler = (callDetect) => {
        resolve(callDetect);
      };
      this.on(callingDetectTriggerEvent, resolveHandler);
      this.execute({
        method: "calling.detect",
        params: {
          node_id: this.nodeId,
          call_id: this.callId,
          control_id: controlId,
          timeout,
          detect: {
            type,
            params: toSnakeCaseKeys2(rest)
          }
        }
      }).then(() => {
        const startEvent = {
          control_id: controlId,
          call_id: this.id,
          node_id: this.nodeId
        };
        this.emit(callingDetectTriggerEvent, startEvent);
      }).catch((e) => {
        this.off(callingDetectTriggerEvent, resolveHandler);
        reject(e);
      });
    });
  }
  amd(params = {}) {
    return this.detect(__spreadProps(__spreadValues({}, params), {
      type: "machine"
    }));
  }
  detectFax(params = {}) {
    return this.detect(__spreadProps(__spreadValues({}, params), {
      type: "fax"
    }));
  }
  detectDigit(params = {}) {
    return this.detect(__spreadProps(__spreadValues({}, params), {
      type: "digit"
    }));
  }
  waitFor(params) {
    return new Promise((resolve) => {
      if (!params) {
        resolve(true);
      }
      const events = Array.isArray(params) ? params : [params];
      const emittedCallStates = /* @__PURE__ */ new Set();
      const shouldResolve = () => emittedCallStates.size === events.length;
      const shouldWaitForEnded = events.includes("ended");
      const shouldResolveUnsuccessful = (state) => {
        return !shouldWaitForEnded && state === "ended";
      };
      this.on("call.state", (params2) => {
        if (events.includes(params2.callState)) {
          emittedCallStates.add(params2.callState);
        } else if (shouldResolveUnsuccessful(params2.callState)) {
          return resolve(false);
        }
        if (shouldResolve()) {
          resolve(true);
        }
      });
    });
  }
};
var CallAPI = extendComponent3(CallConsumer, {});
var createCallObject = (params) => {
  const call = connect13({
    store: params.store,
    Component: CallAPI,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(params);
  return call;
};

// src/voice/VoiceClient.ts
var VoiceClient = function(options) {
  const { client, store, emitter } = setupClient(options);
  const voice = createVoiceObject(__spreadValues({
    store,
    emitter
  }, options));
  const callDial = async (dialer) => {
    await clientConnect(client);
    const call = createCallObject({
      store,
      emitter
    });
    await call.dial(dialer);
    return call;
  };
  const disconnect = () => client.disconnect();
  const interceptors = __spreadProps(__spreadValues({}, clientContextInterceptorsFactory(client)), {
    dial: callDial,
    _session: client,
    disconnect
  });
  return new Proxy(voice, {
    get(target, prop, receiver) {
      if (prop in interceptors) {
        return interceptors[prop];
      }
      if (typeof target[prop] === "function") {
        clientConnect(client);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
};

// src/voice/Voice.ts
var VoiceAPI = class extends AutoApplyTransformsConsumer {
  constructor(options) {
    super(options);
    __publicField(this, "_eventsPrefix", "calling");
    this.runWorker("voiceCallReceiveWorker", {
      worker: voiceCallReceiveWorker
    });
    this._attachListeners("");
  }
  getEmitterTransforms() {
    return /* @__PURE__ */ new Map([
      [
        "calling.call.received",
        {
          mode: "no-cache",
          type: "voiceCallReceived",
          instanceFactory: (_payload) => {
            return createCallObject({
              store: this.store,
              emitter: this.emitter
            });
          },
          payloadTransform: (payload) => {
            return toExternalJSON6(payload);
          }
        }
      ]
    ]);
  }
  dialPhone(_a) {
    var _b = _a, { region } = _b, params = __objRest(_b, ["region"]);
    const devices = new DeviceBuilder().add(DeviceBuilder.Phone(params));
    return this.dial({
      region,
      devices
    });
  }
  dialSip(_c) {
    var _d = _c, { region } = _d, params = __objRest(_d, ["region"]);
    const devices = new DeviceBuilder().add(DeviceBuilder.Sip(params));
    return this.dial({
      region,
      devices
    });
  }
};
var createVoiceObject = (params) => {
  const voice = connect14({
    store: params.store,
    Component: VoiceAPI,
    componentListeners: {
      errors: "onError",
      responses: "onSuccess"
    }
  })(params);
  return voice;
};
export {
  Chat_exports as Chat,
  Messaging_exports as Messaging,
  PubSub_exports as PubSub,
  Task_exports as Task,
  Video_exports as Video,
  Voice_exports as Voice,
  config,
  createClient2 as createClient,
  getConfig
};
//# sourceMappingURL=index.node.mjs.map
